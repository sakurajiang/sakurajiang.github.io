<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sakurajiang的个人博客</title>
  
  <subtitle>心有猛虎&amp;&amp;细嗅蔷薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sakurajiang.github.io/"/>
  <updated>2020-07-25T10:07:56.332Z</updated>
  <id>http://sakurajiang.github.io/</id>
  
  <author>
    <name>sakurajiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mmap_understand</title>
    <link href="http://sakurajiang.github.io/2020/06/20/mmap_mapping_file/"/>
    <id>http://sakurajiang.github.io/2020/06/20/mmap_mapping_file/</id>
    <published>2020-06-19T16:00:00.000Z</published>
    <updated>2020-07-25T10:07:56.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网络上有很多描述mmap的文章，但是看完之后还是会让人感觉迷惑，原因是只是单纯的介绍了mmap的使用，其中提的最多的就是减少拷贝次数，并没有解释为什么要这样做。在计算机中，所有东西的出现必然有其原因，了解整个的前因对于对mmap的理解会很有好处，下面我们就从前因开始。</p><h3 id="操作系统如何访问文件"><a href="#操作系统如何访问文件" class="headerlink" title="操作系统如何访问文件"></a>操作系统如何访问文件</h3><p>要说这个就得先说下虚拟内存</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>现代的操作系统，都会支持虚拟内存，它将物理内存对应用层开发透明，应用程序都是使用虚拟地址，其在编译的时候就确定，当然在链接的时候可能还会重定位修改。虚拟内存让进程以为自己独占系统所有的内存，当然是以一种欺骗的方式，因为现在的操作系统都支持多进程，比如我现在就在写这篇文章的同时，在听着杰伦的Mojito。且为了效率，虚拟地址的单位大小是页，一般是4096字节。也就是4kb。从前面的描述可以看出，虚拟内存和进程其实是密切相关的，一般来说两个不同的进程，同样的虚拟地址映射的是不同的物理内存(如果是同样的，岂不是乱套了)，所以在操作系统内部必然要存在物理地址和虚拟地址的转换，这个就是MMU，即memory manage unit。转换的时候需要使用到Page Tables，Page Tables包含Page Directory(PGD)、Page mid-level Directory(PMD)、Page Table(PT)。三者都是链表的结构，主要介绍一下PT，里面的每个元素被称为Page Table Entry，其中包含的值就是物理地址。</p><p>说了这么多，还是没开始说操作系统如何访问文件，别急，前置知识还是要了解的，还需要再介绍的前置知识就是用户空间和内核空间。</p><h4 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h4><p>我们假设虚拟地址的大小是4G，那么用户空间和内核空间分别占有3G和1G的空间，且内核空间的地址是高地址，即0xC0000000 到 0xFFFFFFFF，两者权限不同，内核可以访问计算机所有的资源，比如磁盘、所有的CPU指令、所有的虚拟空间。而用户空间只能访问受限的资源，一个常见的用户空间结构包含：stack、heap、text、data、bss、内存映射区域等。引入内核空间主要是基于系统的安全考量。因为如果所有的进程都可以访问系统资源，那么恶意进程对计算机的破坏就太恐怖了，比如一个恶意进程将计算机所有的文件删除。</p><h4 id="操作系统如何访问文件-1"><a href="#操作系统如何访问文件-1" class="headerlink" title="操作系统如何访问文件"></a>操作系统如何访问文件</h4><p>说了这么多，终于到重头戏了，有了这些前置知识，假如你是一个操作系统的设计者，你会如何设计一个文件操作子系统。不妨停下想一想。</p><p>我们知道磁盘的读写速度和内存的读写速度不在一个量级上，加上前面说的用户空间和内核空间，因此频繁的访问磁盘肯定会降低程序的速度，因为会涉及到用户态和内核态的切换，正如解决计算机问题的经典方式，加一个中间层，那么自然就会想到在内核中使用一个buffer存储用户态传来的数据，当到一个容量的时候，再将数据写会磁盘。而且这样还有好处，比如，当进程A访问文件B，而进程B也访问文件B，在进程访问文件A后，文件的内容已经在内核的buffer中了，此时，进程B访问的时候就不需要再从磁盘将数据读入内核了。加快了进程B访问文件的速度。事实上，现代操作系统就是这样做的，负责磁盘和内核交互的模块是DMA，即direct memory access，而负责内核和用户空间的数据交互是CPU，分开的好处在于减轻CPU的工作，在从磁盘读文件的时候可以做其他事，此时的buffer有一个专门的名字叫做page cache。但是细想一下，如果只提供这样一种方式，是不是不友好，因为在文件的访问过程中可能会涉及到多次的用户态和内核态切换。那么有什么方式呢？也可以停下想一想。</p><p>上述的过程中，直接将内核空间的page cache和用户空间的映射，如何实现映射呢？只要内核空间的page cache中对应那块文件的内存的PT和用户空间需要映射的内存相同就行，这样两者所访问的物理内存就相同，当然最后映射返回的地址肯定要属于用户空间，因为只有这样用户空间才能访问。这样就可以减少一次内核态到用户态的一次拷贝。即现代操作系统的mmap，返回的值便是映射区域的地址(可以将地址打印出来，用于验证前面说的返回的地址是属于用户空间)，关于mmap的介绍可以直接看<a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener">官方文档</a>这里停下思考下，为什么我说的是内核态到用户态的一次拷贝，而不是双向的，<strong>即为什么只是read减少了一次拷贝，而write没有呢</strong>。</p><p>我们想下，在实际的代码中，当我们需要往某块地址中写数据的时候，比如我们有数据char *data = “hello world”，那么当我们拿到mmap返回的地址后，我们假设是mmapAddress，我们往mmapAddress写数据的数据，肯定需要将数据从data中拷贝到mmapAddress，只不过相比直接使用fwrite方法而言，少了内核态和用户态的切换。而读数据的时候就会减少拷贝，即我们可以直接访问mmapAddress地址。下面直接给代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">int</span> fd, offset = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> fileSizeOld, fileSizeNew, textSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *text = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filePath = <span class="string">"/Users/jdk/TestMMAP/testmmap.txt"</span>; <span class="comment">//your mapping file path</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"We will write text '%s' to '%s'.\n"</span>, text, filePath);</span><br><span class="line">    <span class="comment">// Open a file for writing.</span></span><br><span class="line">    <span class="comment">// Creating the file if it doesn't exist.</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filePath, O_RDWR | O_CREAT, (<span class="keyword">mode_t</span>)<span class="number">0664</span> )) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(filePath, &amp;fileInfo) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the file is not empty, show its content</span></span><br><span class="line">    <span class="keyword">if</span> (fileInfo.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">map</span> = mmap(<span class="number">0</span>, fileInfo.st_size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            perror(<span class="string">"mmap"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The content in '%s' before writing:\n"</span>, filePath);</span><br><span class="line">        <span class="keyword">while</span> (offset &lt; fileInfo.st_size) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="built_in">map</span>[offset]);</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (munmap(<span class="built_in">map</span>, fileInfo.st_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            perror(<span class="string">"Error un-mmapping the file"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Stretch the file size to write the array of char</span></span><br><span class="line">    fileSizeOld = fileInfo.st_size;</span><br><span class="line"></span><br><span class="line">    textSize = <span class="built_in">strlen</span>(text);</span><br><span class="line">    fileSizeNew = fileInfo.st_size + textSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ftruncate(fd, fileSizeNew) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        perror(<span class="string">"Error resizing the file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mmap to write</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="number">0</span>, fileSizeNew, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        perror(<span class="string">"mmap"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);\</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmap address= %p"</span>,<span class="built_in">map</span>);</span><br><span class="line">    <span class="comment">//memcpy(map,text,textSize);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; textSize; i++) &#123;</span><br><span class="line">        <span class="comment">/* printf("Writing character %c at %zu\n", text[i], i); */</span></span><br><span class="line">        <span class="built_in">map</span>[i+fileSizeOld] = text[i]; <span class="comment">//copy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write it now to disk</span></span><br><span class="line">    <span class="keyword">if</span> (msync(<span class="built_in">map</span>, fileSizeNew, MS_SYNC) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Could not sync the file to disk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>  i =<span class="number">0</span>;i&lt;textSize;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"value =%c \n"</span>,<span class="built_in">map</span>[i]); <span class="comment">//no need to copy</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Free the mmapped memory</span></span><br><span class="line">    <span class="keyword">if</span> (munmap(<span class="built_in">map</span>, fileSizeNew) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        perror(<span class="string">"Error un-mmapping the file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Un-mmaping doesn't close the file, so we still need to do that</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="mmap" scheme="http://sakurajiang.github.io/tags/mmap/"/>
    
      <category term="linux" scheme="http://sakurajiang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://sakurajiang.github.io/2020/06/19/CAS/"/>
    <id>http://sakurajiang.github.io/2020/06/19/CAS/</id>
    <published>2020-06-18T16:00:00.000Z</published>
    <updated>2020-07-06T12:48:46.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="what"><a href="#what" class="headerlink" title="what"></a>what</h3><p>CAS全称是compare and swap，将内存中的值和一个给定的值对比，如果相等该内存的值修改为给定的新值。注意这一步是属于原子操作。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>通过简单的例子看一下本质，版本是jdk8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger mAtomicInteger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAtomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接看AtomicInteger.java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下unsafe变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe(); <span class="comment">//Unsafe是sun.misc.Unsafe类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset; <span class="comment">//表示AtomicInteger类value的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>跳转到Unsafe.java的getAndAddInt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the current value of a field</span></span><br><span class="line"><span class="comment">     * or array element within the given object &lt;code&gt;o&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * at the given &lt;code&gt;offset&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o object/array to update the field/element in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset field/element offset</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = getIntVolatile(o, offset); </span><br><span class="line">        &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>跳转到getIntVolatile方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Volatile version of &#123;<span class="doctag">@link</span> #getInt(Object, long)&#125;  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span>     <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@see</span> #getByte(long) */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span>     <span class="title">getInt</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fetches a value from a given memory address.  If the address is zero, or</span></span><br><span class="line"><span class="comment">     * does not point into a block obtained from &#123;<span class="doctag">@link</span> #allocateMemory&#125;, the</span></span><br><span class="line"><span class="comment">     * results are undefined.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #allocateMemory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span>    <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure><p>很明显getIntVolatile的作用是获取给定地址的值。接下来看compareAndSwapInt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently</span></span><br><span class="line"><span class="comment">     * holding &lt;tt&gt;expected&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if successful</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p>我们直接到UnSafe.cpp类查找compareAndSwapInt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// These are the methods for 1.8.0</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods_18[] = &#123;</span><br><span class="line">    &#123;CC<span class="string">"getObject"</span>,        CC<span class="string">"("</span>OBJ<span class="string">"J)"</span>OBJ<span class="string">""</span>,   FN_PTR(Unsafe_GetObject)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putObject"</span>,        CC<span class="string">"("</span>OBJ<span class="string">"J"</span>OBJ<span class="string">")V"</span>,  FN_PTR(Unsafe_SetObject)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"getObjectVolatile"</span>,CC<span class="string">"("</span>OBJ<span class="string">"J)"</span>OBJ<span class="string">""</span>,   FN_PTR(Unsafe_GetObjectVolatile)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putObjectVolatile"</span>,CC<span class="string">"("</span>OBJ<span class="string">"J"</span>OBJ<span class="string">")V"</span>,  FN_PTR(Unsafe_SetObjectVolatile)&#125;,</span><br><span class="line"></span><br><span class="line">    DECLARE_GETSETOOP(Boolean, Z),</span><br><span class="line">    DECLARE_GETSETOOP(Byte, B),</span><br><span class="line">    DECLARE_GETSETOOP(Short, S),</span><br><span class="line">    DECLARE_GETSETOOP(Char, C),</span><br><span class="line">    DECLARE_GETSETOOP(Int, I),</span><br><span class="line">    DECLARE_GETSETOOP(Long, J),</span><br><span class="line">    DECLARE_GETSETOOP(Float, F),</span><br><span class="line">    DECLARE_GETSETOOP(Double, D),</span><br><span class="line"></span><br><span class="line">    DECLARE_GETSETNATIVE(Byte, B),</span><br><span class="line">    DECLARE_GETSETNATIVE(Short, S),</span><br><span class="line">    DECLARE_GETSETNATIVE(Char, C),</span><br><span class="line">    DECLARE_GETSETNATIVE(Int, I),</span><br><span class="line">    DECLARE_GETSETNATIVE(Long, J),</span><br><span class="line">    DECLARE_GETSETNATIVE(Float, F),</span><br><span class="line">    DECLARE_GETSETNATIVE(Double, D),</span><br><span class="line"></span><br><span class="line">    &#123;CC<span class="string">"getAddress"</span>,         CC<span class="string">"("</span>ADR<span class="string">")"</span>ADR,             FN_PTR(Unsafe_GetNativeAddress)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putAddress"</span>,         CC<span class="string">"("</span>ADR<span class="string">""</span>ADR<span class="string">")V"</span>,          FN_PTR(Unsafe_SetNativeAddress)&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;CC<span class="string">"allocateMemory"</span>,     CC<span class="string">"(J)"</span>ADR,                 FN_PTR(Unsafe_AllocateMemory)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"reallocateMemory"</span>,   CC<span class="string">"("</span>ADR<span class="string">"J)"</span>ADR,            FN_PTR(Unsafe_ReallocateMemory)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"freeMemory"</span>,         CC<span class="string">"("</span>ADR<span class="string">")V"</span>,               FN_PTR(Unsafe_FreeMemory)&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;CC<span class="string">"objectFieldOffset"</span>,  CC<span class="string">"("</span>FLD<span class="string">")J"</span>,               FN_PTR(Unsafe_ObjectFieldOffset)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"staticFieldOffset"</span>,  CC<span class="string">"("</span>FLD<span class="string">")J"</span>,               FN_PTR(Unsafe_StaticFieldOffset)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"staticFieldBase"</span>,    CC<span class="string">"("</span>FLD<span class="string">")"</span>OBJ,             FN_PTR(Unsafe_StaticFieldBaseFromField)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"ensureClassInitialized"</span>,CC<span class="string">"("</span>CLS<span class="string">")V"</span>,            FN_PTR(Unsafe_EnsureClassInitialized)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"arrayBaseOffset"</span>,    CC<span class="string">"("</span>CLS<span class="string">")I"</span>,               FN_PTR(Unsafe_ArrayBaseOffset)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"arrayIndexScale"</span>,    CC<span class="string">"("</span>CLS<span class="string">")I"</span>,               FN_PTR(Unsafe_ArrayIndexScale)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"addressSize"</span>,        CC<span class="string">"()I"</span>,                    FN_PTR(Unsafe_AddressSize)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"pageSize"</span>,           CC<span class="string">"()I"</span>,                    FN_PTR(Unsafe_PageSize)&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;CC<span class="string">"defineClass"</span>,        CC<span class="string">"("</span>DC_Args<span class="string">")"</span>CLS,         FN_PTR(Unsafe_DefineClass)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"allocateInstance"</span>,   CC<span class="string">"("</span>CLS<span class="string">")"</span>OBJ,             FN_PTR(Unsafe_AllocateInstance)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"monitorEnter"</span>,       CC<span class="string">"("</span>OBJ<span class="string">")V"</span>,               FN_PTR(Unsafe_MonitorEnter)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"monitorExit"</span>,        CC<span class="string">"("</span>OBJ<span class="string">")V"</span>,               FN_PTR(Unsafe_MonitorExit)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"tryMonitorEnter"</span>,    CC<span class="string">"("</span>OBJ<span class="string">")Z"</span>,               FN_PTR(Unsafe_TryMonitorEnter)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"throwException"</span>,     CC<span class="string">"("</span>THR<span class="string">")V"</span>,               FN_PTR(Unsafe_ThrowException)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapObject"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span>OBJ<span class="string">""</span>OBJ<span class="string">")Z"</span>,  FN_PTR(Unsafe_CompareAndSwapObject)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putOrderedObject"</span>,   CC<span class="string">"("</span>OBJ<span class="string">"J"</span>OBJ<span class="string">")V"</span>,         FN_PTR(Unsafe_SetOrderedObject)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putOrderedInt"</span>,      CC<span class="string">"("</span>OBJ<span class="string">"JI)V"</span>,             FN_PTR(Unsafe_SetOrderedInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"putOrderedLong"</span>,     CC<span class="string">"("</span>OBJ<span class="string">"JJ)V"</span>,             FN_PTR(Unsafe_SetOrderedLong)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"park"</span>,               CC<span class="string">"(ZJ)V"</span>,                  FN_PTR(Unsafe_Park)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"unpark"</span>,             CC<span class="string">"("</span>OBJ<span class="string">")V"</span>,               FN_PTR(Unsafe_Unpark)&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt会出现在多处，我们选择methods_18，因为是jdk8。然后搜索methods_18</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This one function is exported, used by NativeLookup.</span></span><br><span class="line"><span class="comment">// The Unsafe_xxx functions above are called only from the interpreter.</span></span><br><span class="line"><span class="comment">// The optimizer looks at names and signatures to recognize</span></span><br><span class="line"><span class="comment">// individual functions.</span></span><br><span class="line"></span><br><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_RegisterUnsafeMethods(JNIEnv *env, jclass unsafecls))</span><br><span class="line">  UnsafeWrapper(<span class="string">"JVM_RegisterUnsafeMethods"</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ThreadToNativeFromVM <span class="title">ttnfv</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe methods</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// We need to register the 1.6 methods first because the 1.8 methods would register fine on 1.7 and 1.6</span></span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.6 methods"</span>,   env, unsafecls, methods_16,  <span class="keyword">sizeof</span>(methods_16)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.8 methods"</span>,   env, unsafecls, methods_18,  <span class="keyword">sizeof</span>(methods_18)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.5 methods"</span>,   env, unsafecls, methods_15,  <span class="keyword">sizeof</span>(methods_15)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.4.1 methods"</span>, env, unsafecls, methods_141, <span class="keyword">sizeof</span>(methods_141)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.4.0 methods"</span>, env, unsafecls, methods_140, <span class="keyword">sizeof</span>(methods_140)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      guarantee(success, <span class="string">"register unsafe natives"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe.getLoadAverage</span></span><br><span class="line">    register_natives(<span class="string">"1.6 loadavg method"</span>, env, unsafecls, loadavg_method, <span class="keyword">sizeof</span>(loadavg_method)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prefetch methods</span></span><br><span class="line">    register_natives(<span class="string">"1.6 prefetch methods"</span>, env, unsafecls, prefetch_methods, <span class="keyword">sizeof</span>(prefetch_methods)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory copy methods</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.7 memory copy methods"</span>, env, unsafecls, memcopy_methods_17, <span class="keyword">sizeof</span>(memcopy_methods_17)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        success = register_natives(<span class="string">"1.5 memory copy methods"</span>, env, unsafecls, memcopy_methods_15, <span class="keyword">sizeof</span>(memcopy_methods_15)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe.defineAnonymousClass</span></span><br><span class="line">    <span class="keyword">if</span> (EnableInvokeDynamic) &#123;</span><br><span class="line">      register_natives(<span class="string">"1.7 define anonymous class method"</span>, env, unsafecls, anonk_methods, <span class="keyword">sizeof</span>(anonk_methods)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe.shouldBeInitialized</span></span><br><span class="line">    <span class="keyword">if</span> (EnableInvokeDynamic) &#123;</span><br><span class="line">      register_natives(<span class="string">"1.7 LambdaForm support"</span>, env, unsafecls, lform_methods, <span class="keyword">sizeof</span>(lform_methods)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fence methods</span></span><br><span class="line">    register_natives(<span class="string">"1.8 fence methods"</span>, env, unsafecls, fence_methods, <span class="keyword">sizeof</span>(fence_methods)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据注释直接查找NativeLookup.cpp，搜索JVM_RegisterUnsafeMethods</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CC (char*)  <span class="comment">/* cast a literal from (const char*) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod lookup_special_native_methods[] = &#123;</span><br><span class="line">  <span class="comment">// Next two functions only exist for compatibility with 1.3.1 and earlier.</span></span><br><span class="line">  &#123; CC<span class="string">"Java_java_io_ObjectOutputStream_getPrimitiveFieldValues"</span>,   <span class="literal">NULL</span>, FN_PTR(JVM_GetPrimitiveFieldValues)     &#125;,  <span class="comment">// intercept ObjectOutputStream getPrimitiveFieldValues for faster serialization</span></span><br><span class="line">  &#123; CC<span class="string">"Java_java_io_ObjectInputStream_setPrimitiveFieldValues"</span>,    <span class="literal">NULL</span>, FN_PTR(JVM_SetPrimitiveFieldValues)     &#125;,  <span class="comment">// intercept ObjectInputStream setPrimitiveFieldValues for faster serialization</span></span><br><span class="line"></span><br><span class="line">  &#123; CC<span class="string">"Java_sun_misc_Unsafe_registerNatives"</span>,                      <span class="literal">NULL</span>, FN_PTR(JVM_RegisterUnsafeMethods)       &#125;,</span><br><span class="line">  &#123; CC<span class="string">"Java_java_lang_invoke_MethodHandleNatives_registerNatives"</span>, <span class="literal">NULL</span>, FN_PTR(JVM_RegisterMethodHandleMethods) &#125;,</span><br><span class="line">  &#123; CC<span class="string">"Java_sun_misc_Perf_registerNatives"</span>,                        <span class="literal">NULL</span>, FN_PTR(JVM_RegisterPerfMethods)         &#125;,</span><br><span class="line">  &#123; CC<span class="string">"Java_sun_hotspot_WhiteBox_registerNatives"</span>,                 <span class="literal">NULL</span>, FN_PTR(JVM_RegisterWhiteBoxMethods)     &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们就找到了Java_sun_misc_Unsafe_registerNatives，其实就是指Java_sun_misc_Unsafe_registerNatives对应JVM_RegisterPerfMethods，而Java_sun_misc_Unsafe_registerNatives根据命名知道在Unsafe.java中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, "getUnsafe");</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>即在Unsafe加载之后就会调用registerNatives，即调用JVM_RegisterUnsafeMethods，即调用了Unsafe.cpp的register_natives</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Helper method to register native methods.</span><br><span class="line"> */</span><br><span class="line">static bool register_natives(const char* message, JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods) &#123;</span><br><span class="line">  int status = env-&gt;RegisterNatives(clazz, methods, nMethods);</span><br><span class="line">  if (status &lt; 0 || env-&gt;ExceptionOccurred()) &#123;</span><br><span class="line">    if (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123;</span><br><span class="line">      tty-&gt;print_cr(&quot;Unsafe:  failed registering %s&quot;, message);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ExceptionClear();</span><br><span class="line">    return false;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123;</span><br><span class="line">      tty-&gt;print_cr(&quot;Unsafe:  successfully registered %s&quot;, message);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即注册了对应的方法。即compareAndSwapInt对应Unsafe_CompareAndSwapInt方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj); <span class="comment">//此处p指Unsafe.java对象</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); <span class="comment">//Unsafe.java中value变量的地址</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e; e是compare value</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>直接看Atomic.cpp的cmpxchg方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> exchange_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>* dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  assert(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) == <span class="keyword">sizeof</span>(jint), <span class="string">"more work to do"</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在runtime/atomic.inline.hpp可以知道有很多不同版本的cmpxchg实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.</span></span><br><span class="line"><span class="comment"> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This code is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment"> * under the terms of the GNU General Public License version 2 only, as</span></span><br><span class="line"><span class="comment"> * published by the Free Software Foundation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This code is distributed in the hope that it will be useful, but WITHOUT</span></span><br><span class="line"><span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License</span></span><br><span class="line"><span class="comment"> * version 2 for more details (a copy is included in the LICENSE file that</span></span><br><span class="line"><span class="comment"> * accompanied this code).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You should have received a copy of the GNU General Public License version</span></span><br><span class="line"><span class="comment"> * 2 along with this work; if not, write to the Free Software Foundation,</span></span><br><span class="line"><span class="comment"> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA</span></span><br><span class="line"><span class="comment"> * or visit www.oracle.com if you need additional information or have any</span></span><br><span class="line"><span class="comment"> * questions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"runtime/atomic.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_sparc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_sparc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_zero</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_zero.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_arm</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_arm.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_linux_ppc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_linux_ppc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solaris</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_solaris_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_solaris_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_solaris_sparc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_solaris_sparc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_windows_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_windows_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_aix_ppc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_aix_ppc.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BSD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_bsd_x86</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_bsd_x86.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_OS_ARCH_bsd_zero</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"atomic_bsd_zero.inline.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP</span></span></span><br></pre></td></tr></table></figure><p>本来想看arm平台的，没找到，最后看atomic_linux_x86.inline.hpp的，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于篇幅已经够长了，因此开了一篇<a href="https://sakurajiang.github.io/2020/06/13/inline_assembly/">新文章</a>，用以解释上面的代码，推荐看下那篇文章，这里直接告诉结果：</p><p> %1表示exchange_value，%3表示dest，这里”a” (compare_value)将compare_value的值赋给eax寄存器，这里cmpxchgl的指令作用是比较compare_value和dest的值，如果相等，将exchange_value赋值给dest，如果不相等，将dest的值赋值给exchange_value。而Unsafe_CompareAndSwapInt方法，返回值是cmpxchgl的返回值和e比较，不相等时，一直跑循环，否则，退出。这样就完成了原子自增操作。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="并发" scheme="http://sakurajiang.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>inline_assembly</title>
    <link href="http://sakurajiang.github.io/2020/06/13/inline_assembly/"/>
    <id>http://sakurajiang.github.io/2020/06/13/inline_assembly/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-07-06T12:48:50.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>当你的项目的主要语言是C/C++的时候，你需要进行极致的优化或者想实现的代码需要高度的硬件定制性时，就需要使用到内连汇编。</p><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>我们通过使用<code>asm</code>关键字，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler <span class="keyword">template</span></span><br><span class="line">    : output operands                   (optional)</span><br><span class="line">    : input operands                    (optional)</span><br><span class="line">    : clobbered registers <span class="built_in">list</span>          (optional)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>assembler template:：汇编语言，比如”movl %%eax, %%ebx” ，这句话的意思是将eax寄存器的值拷贝到ebx寄存器中。</p><p>output operands:：为assembler template中的汇编代码提供输出参数(指定assembler template中汇编代码输出到C/C++的哪个变量)，并且指定这个变量存在哪个寄存器中，比如”=a”(b)，表示将结果写到b这个变量中（当然需要先声明变量b），该变量存储在eax寄存器。=表示该操作数是只写的，之前的数据被抛弃。注意，<strong>如果你在assembler template中对eax寄存器赋值，那么也就修改了b变量的值</strong>。举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"movl $6,%0; movl $9,%%eax;"</span></span><br><span class="line">        :<span class="string">"=a"</span>(a)</span><br><span class="line">        :</span><br><span class="line">        :);</span><br></pre></td></tr></table></figure><p>最后，a的值为9，而不是6。</p><p>input operands：为assembler template中的汇编代码提供输入参数(指定assembler template中汇编代码需要使用到C/C++的哪个变量)，并且指定该变量存储在哪个寄存器中，比如”a”(a)，表示将a变量的值存储在eax寄存器。此时在assembler template中访问eax寄存器，也就是访问a变量</p><p>clobbered registers list：告诉gcc，asm里的汇编代码会使用到这些寄存器，所以gcc不能使用这里面的寄存器。当然在input或者output列出的寄存器不需要在这里重复列出，如果asm里的汇编代码会以不可预知的方式修改内存，那么还需要将”m”加到clobbered registers list。</p><p>看完了语法之后，下面以例子开始说明：</p><p>先举一个简单的例子，即将变量a的值赋值给b:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> b,a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"movl %1, %%eax; movl %%eax, %0;"</span></span><br><span class="line">     :<span class="string">"=r"</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">     :<span class="string">"r"</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">     :         <span class="comment">/* clobbered register */</span></span><br><span class="line">     );</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a := "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b := "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中0%表示参数b，%1表示参数a，如果是output operands中有多个参数，那么%index就会顺延，比如如果output operands是:”=r”(b),”=r”(c) 而input operands是”r(a), r(b)”，那么%0表示b，%1表示c，%2表示a，%3表示b。</p><p>写下一个例子之前，我们先了解一下cmpxchgl指令，根据<a href="http://heather.cs.ucdavis.edu/~matloff/50/PLN/lock.pdf" target="_blank" rel="noopener">文档</a>解释，cmpxchgl有两个参数，分别是source_operand和dest。cmpxchgl会比较eax寄存器和dest中的值，如果相等，就将source_operand的值赋给dest，否则，就把dest的值赋值给eax寄存器。还有一个需要注意的是，如果在assembler template中加了lock，那么dest就必须存储在memory中。下面我们以例子说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCmpxchg</span><span class="params">(<span class="keyword">int</span> compareValue,<span class="keyword">int</span> exchangeValue,<span class="keyword">int</span> dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">     __asm__ __volatile__(<span class="string">"lock;\n"</span></span><br><span class="line">                          <span class="string">"cmpxchg %1, %3;\n"</span></span><br><span class="line">                 :<span class="string">"=a"</span>(result)</span><br><span class="line">                 :<span class="string">"r"</span>(exchangeValue),<span class="string">"a"</span>(compareValue),<span class="string">"m"</span>(dest)</span><br><span class="line">                 :<span class="string">"memory"</span>,<span class="string">"cc"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"result ="</span>&lt;&lt;result&lt;&lt;<span class="string">"compareValue="</span>&lt;&lt;compareValue&lt;&lt;<span class="string">"exchangeValue="</span>&lt;&lt;exchangeValue&lt;&lt;<span class="string">"dest="</span>&lt;&lt;dest&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入参数是4,5,4，则输出4,4,5,5。输入参数是4,5,5，输出5,4,5,5。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="汇编" scheme="http://sakurajiang.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>gradle</title>
    <link href="http://sakurajiang.github.io/2018/10/30/gradle%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%9E%E6%88%98/"/>
    <id>http://sakurajiang.github.io/2018/10/30/gradle介绍和实战/</id>
    <published>2018-10-29T16:00:00.000Z</published>
    <updated>2020-07-06T12:11:10.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是gradle"><a href="#什么是gradle" class="headerlink" title="什么是gradle"></a>什么是gradle</h3><p>简单的说gradle是一套构建工具，所谓构建工具就是根据一堆输入信息，生成一系列产物，复杂的说gradle是一套框架，所有的参数配置其实都严格对应相应的API，我们没有必要可以记住这些API，我们需要掌握的是大体流程，然后借助官方SDK+API来完成自己的需求。</p><h3 id="为什么会有gradle"><a href="#为什么会有gradle" class="headerlink" title="为什么会有gradle"></a>为什么会有gradle</h3><p>在Gradle爆红之前，常用的构建工具是ANT，然后又进化到Maven。ANT和Maven这两个工具其实也还算方便，现在还有很多地方在使用。但是二者都有一些缺点，所以让更懒得人觉得不是那么方便。比如，Maven编译规则是用XML来编写的。XML虽然通俗易懂，但是很难在xml中描述if{某条件成立，编译某文件}/else{编译其他文件}这样有不同条件的任务。于是gradle就应运而生，gradle采用的语言是groovy，groovy能让你写java语言像写脚本一样简单，同时gradle是一种DSL语言，即Domain Specific Language，领域相关语言。什么是DSL，说白了它是某个行业中的行话。在gradle的体现有很多，比如sourceSets代表源文件的集合等。</p><h3 id="如何使用gradle"><a href="#如何使用gradle" class="headerlink" title="如何使用gradle"></a>如何使用gradle</h3><p>1.首先我们需要学习一下groovy，值得一提的是groovy语言在编译的时候已经编译为java类字节码，然后运行在JVM虚拟机中，可以理解为它扩展了Java语言，写法十分的奔放，比如定义变量使用<code>def</code>定义，但是这个关键字也不是必需的，语句结尾可以不使用<code>;</code>，单引号严格对应Java中的双引号，双引号则和脚本语言中的双引号类似，当含有<code>$</code>符号时，则它会<code>$</code>表达式先求值，三引号中的字符串支持换行。暂时先了解这些，详细的可以直接看<code>GDK</code>。<br>2.接下来我们就介绍一下gradle的行话，在gradle中，每一个待编译的工程都是一个<code>Project</code>对象，每个<code>Project</code>在编译的时候包含多个<code>Task</code>，比如一个<code>Android</code>项目的编译可能就包含<strong>Java源码编译Task</strong>、<strong>资源编译Task</strong>、<strong>JNI编译Task</strong>、<strong>lint检查的Task</strong>、<strong>打包生成APK的Task</strong>、<strong>签名Task</strong>等等。一个<code>Project</code>包含的<code>Task</code>的数量是由编译脚本执行的插件决定的，插件就是用来定义<code>Task</code>，并且具体执行这些<code>Task</code>的东西。而gradle作为一个框架，主要负责定义流程和规则，具体的编译工作则是通过编译插件来完成，比如编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android LIbrary插件。该<img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/%E8%87%AA%E5%AE%9A%E4%B9%89Gradle%E6%8F%92%E4%BB%B6/%E6%A8%A1%E5%9D%97%E6%95%B0%E7%9B%AE.png" alt="图片">中有两个<code>Project</code>，根据gradle设计，每一个<code>Project</code>都对应一个<code>build.gradle</code>对象，而<code>build.gradle</code>就是该<code>Project</code>的编译脚本，如果只有这些，那么你编译的就需要进入到每一个<code>Project</code>中，然后执行编译脚本，这样效率很低，于是gradle提供了<strong>Multi-Projects Build</strong>，即多个项目一起编译，实现很简单，就是再项目根目录增加一个<code>build.gradle</code>文件，然后再增加一个<code>settings.gradle</code>，前者可以什么都不写，后者就是通过<code>include</code>标签将所有的<code>Project</code>包含进来，如：<code>include &#39;:app&#39;, &#39;:buildsrc&#39;</code>，同时我们还可以在这里添加一些初始化的函数，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def initSomeValue()&#123;</span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    File fileProperties = new File(rootDir.getAbsolutePath()+&quot;/local.properties&quot;);</span><br><span class="line">    properties.load(fileProperties.newDataInputStream());</span><br><span class="line">    gradle.ext.myApi = properties.getProperty(&quot;sdk.dir&quot;);</span><br><span class="line">    println(&quot;init&quot;+gradle.myApi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数就是将<code>SDK</code>的目录赋值给gradle的额外属性<code>myApi</code>中，下次直接通过<code>gradle.myApi</code>获取该属性。目前我们了解的内容如下：<br><strong>每一个Project都必须设置一个build.gradle文件。<br>对于multi-projects build，需要在根目录下也放一个build.gradle，和一个settings.gradle。<br>一个Project是由若干tasks来组成的，当gradle xxx的时候，实际上是要求gradle执行xxx任务。这个任务就能完成具体的工作。</strong><br>下面说一下gradle的工作流程，简单地说就是先执行<code>settings.gradle</code>，完成初始化过程，然后解析每一个<code>build.gradle</code>，其中的<code>Task</code>会被添加到有向图中，用于解决依赖关系，最后就是执行阶段，执行gradle XXX，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍。接下来介绍几种对象：<br>1.Gradle对象，当执行gradle XXX的时候，gradle会从默认的配置脚本中构造一个Gradle对象，在整个构建过程中只有一个Gradle对象，Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。<br>2.Project对象，每一个<code>build.gradle</code>对象都会生成一个<code>Project</code>对象，在gradle中，<code>Project</code>对象对应的是Build Script，在<code>build.script</code>中，我们一般需要做如下几件事，分别是：应用插件、设置属性等。<br>3.<code>Settings</code>对象，每个<code>settings.gradle</code>都会生成一个<code>Settings</code>对象，注意，对于其他gradle文件，除非定义了class，否则会转换成一个实现了Script接口的对象。这一点和3.5节中Groovy的脚本类相似。<br>讲了这么多，那么一般怎么用呢？<strong>对于Java和Groovy而言，我们一般会把公共的方法放在一个类中，然后在别的类中import该类，但是在Gradle中，一般都是通过在<code>build.gradle</code>中定义插件，然后在插件中定义<code>Task</code>来完成</strong>，定义<code>Task</code>可以通过task函数来定义，一个<code>Task</code>包含多个Action，所以<code>Task</code>有两个函数，分别是doFirst和doLast，即最先执行和最后执行。普及了基础知识，接下来直接看这个项目吧,代码里差不多都有注释。这里需要再补充的就是自定义gradle插件步骤：<br>1.新建一个module（我一般是选择Android Library）</p><p>2.除了main文件夹和build.gradle全部删除，注意main文件夹下的内容也要删除</p><p>3.在main下新建groovy文件夹</p><p>4.在groovy新建package，名字自己随意取，跟包名类似</p><p>5.在package下新建name.groovy文件，name自己取，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.sakurajiang.test</span><br><span class="line"></span><br><span class="line">import org.gradle.api.Plugin</span><br><span class="line">import org.gradle.api.Project</span><br><span class="line"></span><br><span class="line">public class MyPlugin implements Plugin&lt;Project&gt; &#123;</span><br><span class="line">    void apply(Project project) &#123;</span><br><span class="line">        def log = project.logger</span><br><span class="line">        log.error &quot;========================&quot;;</span><br><span class="line">        log.error &quot;精简的MyPlugin，开始修改Class!&quot;;</span><br><span class="line">        log.error &quot;========================&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.在main目录下新建resources文件夹</p><p>7.在resources文件夹下新建META-INF文件夹</p><p>8.在META-INF文件夹下新建gradle-plugins文件夹</p><p>9.在gradle-plugins文件夹下新建name.properties文件，这里的文件名就是引用该插件时用到的名字。其中的内容是implementation-class=com.sakurajiang.test.MyPlugin，后面的值就是步骤5中的文件的包名加类名。</p><p>10.在该module的build.gradle文件中配置如下属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile gradleApi() //gradle sdk</span><br><span class="line">    compile localGroovy() //groovy sdk</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group=&apos;sakurajiang&apos;</span><br><span class="line">version=&apos;1.0.0&apos;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: uri(&apos;../repo&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.选择AS中右边的gradle，选择自定义的插件，选择upload中的uploadArchives</p><p>12.在需要使用该插件的module中的build中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url uri(&apos;../repo&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;sakurajiang:buildsrc:1.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">apply plugin: &apos;Z&apos;</span><br></pre></td></tr></table></figure></p><p>其中’Z’就是步骤9中的name，其中的classpath就是group：modulename：version。</p><p>13.选择Make Project，至此就可以在Build中看到自定义插件中的信息了。自定义插件到此完成。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="gradle" scheme="http://sakurajiang.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>校招总结</title>
    <link href="http://sakurajiang.github.io/2017/10/10/%E6%A0%A1%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://sakurajiang.github.io/2017/10/10/校招总结/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2020-07-06T09:36:07.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>离我校招结束也有一段时间了，之前一直想着写一篇校招总结的，但是一直拖拖沓沓到现在，心里总是有些抗拒，总想着再拖会，写一篇更好的总结，离4.12也已经好几个月了，我也正有点写东西的必要了(严肃脸)。</p><h3 id="还是前言"><a href="#还是前言" class="headerlink" title="还是前言"></a>还是前言</h3><p>作为一个实际懵懵懂懂但却自以为是的人，在大二结束时才幡然醒悟需要开始学相关的技术了，好能够找到好工作，在秋招以前，我都以为找工作是大四快结束的时候才开始找的，所以，在我刚刚踏入校园的那一刻开始，我的大学计划是大一好好玩、大二想一下自己喜欢干什么、大三开始学、大四找工作。这么看着好像是一回事，但是除了第一条做的还不错，别的几条都是有点赶鸭子上架的意思，做的都不太好，或者说，这个计划其实就是有问题的，就比如第二条而言，我设定这个计划的时候就是想着大二在那空想自己喜欢干什么，从不会亲自去实践一下自己是否真的喜欢，永远都是站在岸上，却想着自己能够学会游泳。至于大四找工作那个就更离谱了，因为找工作很早就开始了，这也就是我为什么说我自己实际懵懵懂懂但却自以为是的原因。</p><h3 id="假装进入正题"><a href="#假装进入正题" class="headerlink" title="假装进入正题"></a>假装进入正题</h3><p>所以，先说一下我们的正题，那就是校招总结，打算分为三个阶段来说，顺序就是准备、开始、结束这三个阶段来说。</p><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>准备阶段如果要细说的话就篇幅太大，可能会舍本逐末，所以，大概就是找好方向、早做准备、早点开始。对于一个应届生而言，在找好方向这一块我觉得应该你首先需要确定自己不想干什么，然后自己不讨厌干什么，自己能干什么这几个方面去考虑，去确定一个大体的方向，这里就拿程序猿举例，分为很多方向，比如Android、前端、后台之类的，然后呢，如果你在学习这个方面的过程中，突然想学习一下别的方面的技术，没关系，喜欢就去学，就算你过一两个星期发现自己不喜欢了，但那又怎样？技术本就是相通的，点终究会串成线，线会织成面，当然，在你确定不喜欢之后你需要马上回到主线程中，不要觉得这是浪费时间，站在岸上永远都学不会游泳，只有在不断的尝试中才能逐渐清晰自己喜欢干什么。但是切记不可三心二意。</p><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><h4 id="面试部分"><a href="#面试部分" class="headerlink" title="面试部分"></a>面试部分</h4><p>此部分是我以前部分面试后的总结，不分先后顺序，有一个由于找不到当初记录的资料，所以比较少，没错，说的就是最后爱奇艺面试那个。因为对于秋招没有好好准备，所以面试也不多，此外，别人的面试经验其实只能当个参考，以一个过来人的经验看，最重要的其实是你对自己简历上写的东西一定要熟，要知其然并且知其所以然，还有就是如果想进好一点的公司，常见的算法一定要会。</p><h5 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h5><p>1.AA里面有几张表<br>2.数据库用了什么框架<br>3.多线程里如何保证单例模式的正常<br>4.Material Design的意义<br>5.Retrofit实现原理<br>6.intentservice和service的区别<br>7.单例模式的懒加载在哪里设置同步比较好<br>8.activity在onCreate中多少秒出现ANR，service呢？contentProvider会出现ANR吗？  </p><p>虽然没有过，但是还是有收获的，遇到问题还是要多问几个为什么，还是应该保持哲学家的好奇心，不要对于知识理所当然，同时，逻辑要清晰，对于组件要明白为什么需要它们，了解它们的作用。对于方法需要了解它的作用，返回值，参数的意义。当然，也没有必要完全否定自己。只是需要适当的调整方向，不能再继续去看进阶的东西，但是先应该回头将基础重新理一遍。另外，简历上的东西一定要完全弄懂，注意是完全弄懂，毕竟面试官要了解你能不能胜任这个工作，都会先从简历上着手，如果你连简历上的东西都不是很清楚，自然就不会有谈下去的心思。至于为什么我需要让他了解我，让他觉得我能胜任这个工作，因为你就是来应聘这份工作的啊。</p><h5 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h5><p>数据库更新时我们怎么做？<br>1.数据库什么时候更新？<br>当我们应用升级的时候，用户安装更新，此时用户的数据库其实是没有更新的，只有当我们访问数据库的时候才会更新，访问数据库其实就是指调用自定义<code>SQLiteOpenHelper</code>类中的<code>getReadableDatabase()</code>或者<code>getWritableDatabase()</code>方法。<br>2.应用是如何知道数据库需要更新的？<br>当用户安装了我们最初的程序之后，此时访问数据库的时候会将数据库的版本号置为1.0(假设一开始是1.0)，当我们升级我们的数据库时，需要自己在程序中传入一个新的<code>version</code>参数，是在<code>new</code>自定义<code>SQLiteOpenHelper</code>类的对象时传入，当我们传入的新的<code>version</code>参数比原来的大时，就会调用<code>onUpgrade(db, version, mNewVersion);</code>方法，源代码如下：  </p><pre><code>db.beginTransaction();           try {               if (version == 0) {                   onCreate(db);               } else {                   if (version &gt; mNewVersion) {                       onDowngrade(db, version, mNewVersion);                   } else {                       onUpgrade(db, version, mNewVersion);                   }               }               db.setVersion(mNewVersion);               db.setTransactionSuccessful();           } finally {               db.endTransaction();           }       }</code></pre><p>当用户更新我们的应用时，此时用户的数据库版本号还是1.0，但是新程序中的<code>version</code>参数是2.0，当用户访问数据库的时候，应用程序就知道此时需要更新数据库，然后就会调用<code>onUpgrade(db, version, mNewVersion);</code>方法，最后将版本号换成2.0。<br>3.那么我们在<code>onUpgrade(db, version, mNewVersion);</code>方法中如何更新表呢？<br><code>SQLite</code>提供了<code>ALTER TABLE</code>，能够重命名和增加列名，但是无法删除列名，而且只能在最后增加列名，那么当遇到删除列名的时候需要怎么办呢？我们可以先采用四步：<br>1.将需要更新的表变成一个临时表<br>2.重新创建一个表，表名就是之前的表名。<br>3.将临时表中的数据插入到新的表中<br>4.删除临时表<br>这样就完成了数据表的更新。</p><h5 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h5><p>由于面完爱奇艺之后拿到了offer，然后就出去浪了，当时就简单的记了一下，现在写的时候找不到了，所以只能大致的说一下，先是让你自己写一个排序算法，然后对这个算法优化，然后是Android常见的面试题，其中包括设计模式等，还有就是问你使用过的框架以及它的源码等等，然后问到后面就是别的也不知道问什么，来，写算法吧，然后就开始在黑板上手写算法，都是一些很常见的算法，记得大部分在牛客网上都遇到过。包括电话面试的话，总共有四轮技术面和一轮HR面。</p><h3 id="寻找招聘公司的途径"><a href="#寻找招聘公司的途径" class="headerlink" title="寻找招聘公司的途径"></a>寻找招聘公司的途径</h3><h4 id="互联派"><a href="#互联派" class="headerlink" title="互联派"></a>互联派</h4><p>把这个放第一个不是因为它多好，而是我用它貌似一次面试都没有，搞不懂他们的内推是怎样的意思，也可能是我自己太菜吧，反正后面我都是看一下他们的信息，然后去对应招聘公司的官网或者以下几个网站去投简历。</p><h4 id="v2ex"><a href="#v2ex" class="headerlink" title="v2ex"></a>v2ex</h4><p>这上面的感觉还不错</p><h4 id="水木社区"><a href="#水木社区" class="headerlink" title="水木社区"></a>水木社区</h4><p>也还行</p><h4 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h4><p>一般般</p><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><p>这个是最正经的。</p><h3 id="最后说点什么，这不是鸡汤"><a href="#最后说点什么，这不是鸡汤" class="headerlink" title="最后说点什么，这不是鸡汤"></a>最后说点什么，这不是鸡汤</h3><p>在你找工作的过程中，你可能会遇到很多挫折和问题，特别对于学校不是很好的学生而言，比如笔试过后没有面试、一面之后就没有消息、你以为你能过的结果没过、每次你抱期望去面试结果都是失败、看到旁边的同学都不找了想放弃、努力找了那么久结果还是没找到、你兴致勃勃的去参加宣讲会结果那家公司只是打着招聘的幌子去宣讲自己的公司，作为一个过来人，我想说，如果不甘心，那就只能收拾心情，总结反思继续找，当然，有可能你找到春招结束，也不会找到，找工作有时候也是看运气的，如果甘心，那就不找了，其实最重要的就是在于你甘不甘心。我就是因为不甘心所以从秋招一直找到了春招，一直到4.12才拿到爱奇艺的offer，也是我第一份正式的offer。所以如果你不甘心就只能收拾心情，总结反思继续找了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最后再放一个我的简历链接吧，也不知道是不是最后的版本，但估计差不多，希望能给需要的人一些帮助，毕竟找工作确实辛苦。<a href="https://github.com/sakurajiang/Resume/blob/68a0e1e23ec45996c0de0a8b4c4c1b22a148a160/%E6%B1%9F%E4%B8%81%E9%AD%81%20.pdf" target="_blank" rel="noopener">简历</a></p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="校招总结" scheme="http://sakurajiang.github.io/tags/%E6%A0%A1%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AReview-ANR</title>
    <link href="http://sakurajiang.github.io/2017/04/03/AReview-ANR/"/>
    <id>http://sakurajiang.github.io/2017/04/03/AReview-ANR/</id>
    <published>2017-04-02T16:00:00.000Z</published>
    <updated>2020-07-06T09:21:27.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>发现好久没写博客了，主要是最近忙着春招，忙着看算法和将以前的知识重新回顾，所以很久没更了，其实一直在写，只是写的不系统，所以没更出来，今天抽空特地更一下。<br>ps:春招真难，还没找到工作。。。</p><h2 id="ANR分析"><a href="#ANR分析" class="headerlink" title="ANR分析"></a>ANR分析</h2><h3 id="ANR流程"><a href="#ANR流程" class="headerlink" title="ANR流程"></a>ANR流程</h3><h4 id="什么是ANR"><a href="#什么是ANR" class="headerlink" title="什么是ANR"></a>什么是ANR</h4><p>ANR是指在Android中，当触摸或者按键事件以及特殊事件没有在规定的时间中完成，那么就会出现ANR(也有可能不会出现ANR)，这里的特殊事件就是指<code>Service</code>、<code>BroadCastReceiver</code>、<code>ContentProvider</code>。</p><h4 id="在源码中是如何体现的？"><a href="#在源码中是如何体现的？" class="headerlink" title="在源码中是如何体现的？"></a>在源码中是如何体现的？</h4><p>以<code>Service</code>为例：<br>1.在<code>realStartServiceLocked</code>方法中会调用<code>bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);</code>方法，这个函数的作用就是延时发送消息，当在<code>Service</code>的<code>onCreate</code>方法回调之后，就会调用<code>AMS.serviceDoneExecuting(IBinder token, int type, int startId, int res)</code>来清除之前发送的消息。所以在<code>onCreate()</code>方法中不能超过20S。<br>2.在<code>AS.sendServiceArgsLocked</code>方法中也会<code>bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);</code>，然后当回调<code>onStartCommand();</code>方法后也会调用<code>AMS.serviceDoneExecuting(IBinder token, int type, int startId, int res)</code>方法来清除之前发送的消息。所以在<code>onStartCommand()</code>中也不能超过20S，同时因为在<code>onStartCommand()</code>会调用<code>onStart()</code>,所以在<code>onStart()</code>中也不能超过20S。<br>也就是说采用的手法是消息机制，就是在启动的时候延时发送一个消息，如果成功启动，那么就会移除这个消息，反之就会使用<code>AMS</code>中的<code>MainHandler</code>去发送<code>SERVICE_TIMEOUT_MSG</code>这个消息，在<code>MainHandler</code>中的<code>handleMessage</code>来处理消息，最后会调用到<code>AMS.appNotResponding()</code>。<br>以<code>BroadCastReceiver</code>为例：<br>在<code>processNextBroadcast</code>方法中调用<code>setBroadcastTimeoutLocked(timeoutTime);</code>方法设置超时时间，当没超时时，调用<code>cancelBroadcastTimeoutLocked();</code>超时时，由<code>BroadcastHandler</code>发送<code>BROADCAST_TIMEOUT_MSG</code>，在<code>BroadcastHandler</code>的<code>handleMessage</code>中调用<code>broadcastTimeoutLocked(false);</code>来强制结束广播。并且调用<code>mService.appNotResponding(mApp, null, null, false, mAnnotation);</code>使用的依然是<code>handler</code>消息机制。<br>以<code>ContentProvider</code>为例：<br><code>ContentProvider</code>发生<code>ANR</code>和其他的都不一样，当使用<code>ContentProvider</code>的时候，若是目标进程不存在，则会创建目标进程，在创建目标进程后会调用<code>AMS.attachApplicationLocked</code>，此时就会延时发送一个消息，延时也是10S，当<code>provider</code>成功<code>publish</code>之后，也就是在<code>AMS.publishContentProviders</code>中会移除这个消息，反之最后会调用到<code>AMS.removeProcessLocked</code>。杀掉<code>ContentProvider</code>所在的进程。<br>注意:关于<code>CONTENT_PROVIDER_PUBLISH_TIMEOUT</code>超时时机是指在<code>startProcessLocked</code>之后会调用<code>AMS.attachApplicationLocked</code>为起点，一直到<code>AMS.publishContentProviders</code>的过程。<br>所以对于<code>ContentProvider</code>而言，如果不需要创建新进程，那么就不会出现这个情况，在不需要创建新进程的时候，也可能会出现<code>ANR</code>，并且会调用<code>AMS.appNotResponding()</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>ANR</code>发生的原因是，在Android的源码中规定了事件或者特殊事件需要在规定时间内完成，提升用户的体验，但是没有完成。在这里事件指触摸或者按键，特殊事件指<code>Service</code>、<code>BroadCastReceiver</code>、<code>ContentProvider</code>。 所采取的措施都是通过<code>Handler</code>消息机制。<br>对于<code>Service</code>而言：在<code>Service</code>的<code>onCreate</code>，<code>onStart</code>、<code>onStartCommnand</code>生命周期方法中超时20S。<br>对于<code>BroadCastReceiver</code>而言：在<code>onReceive()</code>超时10S。<br>对于<code>ContentProvider</code>而言：从<code>AMS.attachApplicationLocked</code>到<code>AMS.publishContentProviders</code>的过程中耗时超过10S。<br>对于<code>ContentProvider</code>而言，不会走<code>AMS.appNotResponding()</code>，其他的都走。<code>AMS.appNotResponding()</code>处理中主要是将CPU使用情况和进程的trace文件信息，保存到/data/system/dropbox；</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="AReview" scheme="http://sakurajiang.github.io/tags/AReview/"/>
    
  </entry>
  
  <entry>
    <title>AReview-消息机制</title>
    <link href="http://sakurajiang.github.io/2017/02/12/AReview-%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://sakurajiang.github.io/2017/02/12/AReview-消息机制/</id>
    <published>2017-02-11T16:00:00.000Z</published>
    <updated>2020-07-06T09:22:03.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息机制概述"><a href="#消息机制概述" class="headerlink" title="消息机制概述"></a>消息机制概述</h3><p>  从开发角度而言，<code>Handler</code>是<code>Android</code>消息机制的上层接口，所以，消息机制主要就是<code>Handler</code>的运行机制，<code>Handler</code>的作用就是在一个线程中发送消息，然后在另一个线程中处理，通过在消息中存放数据达到线程间通信。如果你想在哪个线程中接收消息，那你就要在那个线程中生成一个<code>Handler</code>对象（当然实际上是在哪个线程中调用了Looper.loop()方法，那么就会在哪个线程中接收消息）。Handler的运行需要<code>Looper</code>，<code>MessageQueue</code>的支撑。所以接下来就分别分析这三个类。  </p><h5 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a><code>MessageQueue</code></h5><p>这个类翻译过来就是消息队列，但是这其实是一个链表，因为对于这个类而言，它的作用就是存取<code>handler</code>发送的消息，它包含的主要操作就是<strong>插入和读取</strong>，读取的时候也会涉及<strong>删除操作</strong>，意思就是一个消息只能被处理一次，所以使用链表的结构会更好，因为链表在插入和删除上有优势。这个类的对象是在<code>Looper</code>的构造函数中生成的，<strong>也就是说一个<code>Looper</code>对象就对应自己的一个<code>MessageQueue</code>对象</strong>，代码如下:  </p><pre><code> private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><p> 而对于一个线程而言，就只有一个<code>Looper</code>对象，所以<strong>一个线程就只有一个<code>MessageQueue</code>对象</strong>。为什么一个线程就只有一个<code>Looper</code>对象，我们继续往下看。</p><h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a><code>Looper</code></h4><p>这个类的作用就是管理<code>handler</code>发送的消息，也就意味着它需要和<code>MessageQueue</code>一起使用，这可能就是在源码里为什么会将<code>MessageQueue</code>的构造放在<code>Looper</code>的构造函数里。在<code>Looper</code>的构造函数里，会构造一个<code>MessageQueue</code>对象，同时会得到当前的线程，代码如下:</p><pre><code>private Looper(boolean quitAllowed) {    mQueue = new MessageQueue(quitAllowed);    mThread = Thread.currentThread();}</code></pre><p>这也就意味着<code>Looper</code>的操作都是基于当前线程的，那我们是如何实现线程切换的呢？其实说起来很简单，我们只需要得到每个线程中的<code>Looper</code>对象就可以了。那么，如何得到呢？接下来就介绍一个重要的类:ThreadLocal,掌声欢迎。</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h5><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定的线程中可以获取到存储的数据，对于其他线程则无法获取到数据。这样说太抽象了，直接上代码:</p><pre><code>  public class MainActivity extends Activity {  private ThreadLocal&lt;String&gt; stringThreadLocal;@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);    TestThreadLocal();}public void TestThreadLocal(){    stringThreadLocal=new ThreadLocal&lt;&gt;();    stringThreadLocal.set(&quot;main&quot;);    Log.e(&quot;log&quot;, &quot;main=&quot; + stringThreadLocal.get());    new Thread(&quot;thread1&quot;){        @Override        public void run() {            super.run();            stringThreadLocal.set(&quot;thread1&quot;);            Log.e(&quot;log&quot;,&quot;thread1=&quot;+stringThreadLocal.get());        }    }.start();    new Thread(&quot;thread2&quot;){        @Override        public void run() {            super.run();            stringThreadLocal.set(&quot;thread2&quot;);            Log.e(&quot;log&quot;,&quot;thread2=&quot;+stringThreadLocal.get());        }    }.start();}}</code></pre><p>运行结果如下:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/TestThreadLocal-20161219.PNG" alt="TestThreadLocal-20161219"><br>从上面的Log可以看出，在不同的线程中访问同一个<code>ThreadLocal</code>对象，<code>ThreadLocal</code>获取到的值是不一样的。这就是<code>ThreadLocal</code>的奇妙之处。<code>ThreadLocal</code>之所以有这么奇妙的效果，是因为不同线程访问同一个<code>ThreadLocal</code>的get方法，<code>ThreadLocal</code>内部会从各自的线程中取出一个数组，然后再从数组中根据当前的<code>ThreadLocal</code>的索引去查找对应的value值。而不同的线程中的数组是不同的，这就是为什么通过<code>ThreadLocal</code>可以在不同的线程中维护一套数据的副本并且彼此互不干扰。   </p><p>这样的话就很简单了，通过这个<code>ThreadLocal</code>类我们就可以轻松的得到各个线程中的<code>Looper</code>对象了，从源码中我们也可以看出来:</p><pre><code>static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</code></pre><p>这里就贴这一段了，贴多了看着不好看，有兴趣的同学可以下去自己看一下<code>Looper</code>的源码，其实很简单。既然我们可以得到各个线程中的<code>Looper</code>对象，那么也就意味着其实我们就已经实现了线程切换。然后我们再看一下<code>Loope</code>对象中的重要方法：  </p><p><code>prepare()</code>：这个方法的作用是构造一个<code>Looper</code>对象，调用的顺序是先调用<code>prepare(boolean quitAllowed)</code>方法，然后调用<code>sThreadLocal.set(new Looper(quitAllowed));</code>方法，其中<code>quitAllowed</code>的值的作用就是区分主线程和其他线程，区分的作用是设置<strong>主线程不允许退出的</strong>。</p><p><code>loop()</code>：这个方法的作用是循环遍历整个消息队列，将handler发送的消息送给<code>msg.target.dispatchMessage(msg);</code><br>处理，这是一个死循环，退出的唯一方式就是<code>MessageQueue</code>的<code>next()</code>方法返回null，<code>msg.target</code>其实就是你定义的<code>handler</code>对象，这样就实现了将消息又返回给<code>handler</code>自身来处理。而且，实现了线程的切换。</p><p><code>quie()和quitSafely()</code>:这两个方法的作用就是退出<code>loop()</code>循环，两个的区别就是，第一个是立即退出，第二个时等消息队列中的<strong>已有消息</strong>处理完毕再退出。所以，当我们手动创建<code>Looper</code>的时候注意在合适的时候把<code>loop</code>退出。</p><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a><code>Handler</code></h4><p>这个类的作用就是发送消息和处理消息，当你在创建一个<code>Handler</code>对象的时候，在<code>Handler</code>的构造函数中会得到当前的线程的<code>Looper</code>对象，按照之前的分析，得到了<code>Looper</code>对象其实就得到了<code>MessageQueue</code>对象，这里注意是<strong>当前线程</strong>，当我们调用<code>sendMessage(message)</code>方法的时候，会将一个消息发送到调用<code>Looper.loop()</code>方法所在的线程的消息队列中，跟在哪个线程里调用<code>sendMessage(message)</code>方法没有关系，然后创建<code>Handler</code>的线程的<code>Looper</code>对象的<code>Loop()</code>方法就会将消息返回给<code>handler</code>对象的<code>dispatchMessage(msg);</code>来处理。也就是说将<code>sendMessage(message)</code>在别的线程中调用，最后<code>message</code>会在调用<code>Looper.loop()</code>方法的线程中来执行。使用<code>Handler</code>发送消息有两种方式，一个是<code>post(runnable)</code>，还有一个是<code>sendMessage(message)</code>，在调用第一个的时候，会调用<code>getPostMessage(Runnable r)</code>方法，将<code>Runnable</code>对象存储到<code>Message</code>对象中，所以第一个还是调用第二个，下面看一下<code>Handler</code>的<code>dispatchMessage(Message msg)</code>，代码如下:</p><pre><code>   public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }}</code></pre><p>其中的<code>msg.callback</code>就是<code>Runnable</code>对象，而<code>mCallback</code>就是当你创建<code>Handler</code>是通过传递一个<code>Handler.Callback</code>对象的时候的<code>Handler.Callback</code>对象。 </p><pre><code>public Handler(Callback callback) {    this(callback, false);}</code></pre><p>最后就是<code>Handler</code>自身的<code>handleMessage(msg)</code>。这就是<code>Handler</code>的<code>dispatchMessage(Message msg)</code>的执行顺序，也就是先执行<code>Runnable</code>对象，然后是<code>Handler.Callback</code>对象，最后是<code>Handler</code>自身的<code>handleMessage(msg);</code>。</p><h3 id="从使用流程分析"><a href="#从使用流程分析" class="headerlink" title="从使用流程分析"></a>从使用流程分析</h3><p>当我们创建一个<code>Handler</code>的时候，在<code>Handler</code>的构造函数里会调用<code>Looper.myLooper();</code>来得到当前的线程的<code>Looper</code>对象，得到了<code>Looper</code>对象也就得到了当前线程的<code>MessageQueue</code>对象，注意这里是<strong>当前线程</strong>，然后用创建好了的<code>Handler</code>对象来发送消息，一般来说发送消息都会在别的线程，因为这样才有意义，然后当调用<code>Handler</code>的<code>sendMessage(message)</code>后，就会调用<code>MessageQueue</code>的<code>enqueueMessage(msg, uptimeMillis)</code>;方法，这样就将消息发送到了调用<code>Looper.loop()</code>方法所在的线程的消息队列中，然后将消息发送给<code>msg.target.dispatchMessage(msg);</code>来处理，其中的<code>msg.target</code>就是你创建的<code>Handler</code>对象，然后消息就得到了处理。在实际的开发中，我们的发送消息都会在别的线程，并且在这个线程发送消息之前会完成一些耗时任务，比如下载，然后下载完成后发送消息，在<code>handleMessage(Message msg)</code>或者<code>run()</code>去执行操作，因为这两个方法的调用都是在创建<code>Handler</code>的线程中调用的，这样就完成了将下载任务指定到专门的下载线程中，并且能够在原来的线程中操作下载任务的结果。这也就是实现了<strong>将一个任务切换到指定的线程中工作</strong>。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="AReview" scheme="http://sakurajiang.github.io/tags/AReview/"/>
    
  </entry>
  
  <entry>
    <title>AReview-超简单的Binder，AIDL和Messenger的原理及使用流程</title>
    <link href="http://sakurajiang.github.io/2016/12/15/AReview-%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84Binder%EF%BC%8CAIDL%E5%92%8CMessenger%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://sakurajiang.github.io/2016/12/15/AReview-超简单的Binder，AIDL和Messenger的原理及使用流程/</id>
    <published>2016-12-14T16:00:00.000Z</published>
    <updated>2020-07-06T09:23:02.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Binder的原理"><a href="#Binder的原理" class="headerlink" title="Binder的原理"></a>Binder的原理</h3><p> 要想了解<code>AIDL</code>就需要先了解<code>Binder</code>的原理，所以这里先说一下<code>Binder</code>原理，<code>Binder</code>的原理大概是这样：</p><p>服务器端：当我们在服务端创建好了一个Binder对象后，内部就会开启一个线程用于接收binder驱动发送的消息，收到消息后会执行相关的服务器代码。</p><p>Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会创建一个mRemote对象，该对象的类型也是Binder类，客户就可以<strong>借助</strong>这个mRemote对象来访问远程服务，注意这里是借助，真正调用的时候需要将这个转换成对应的对象，比如使用<code>AIDL</code>的时候就要转换成<code>AIDL</code>对象。</p><p>客户端：客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的暴露给客户端的方法(如果有方法的话)。 </p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p><code>AIDL</code>的本质其实就是系统为我们提供了一种快速实现<code>Binder</code>的工具，我们完全可以不用<code>AIDL</code>，自己去写代码实现<code>Binder</code>，但是当你写出来的时候会发现其实和<code>AIDL</code>自动生成的代码一模一样。我们接下来来分析一下原理，因为<code>AIDL</code>的实现其实就是快速实现<code>Binder</code>，所以原理自然离不开<code>Binder</code>。但是在分析原理之前，我们先将系统根据我们定义的<code>AIDL</code>文件自动生成的java文件分析一下。比较重要的就是<code>Stub</code>和它的内部代理类<code>Proxy</code>。我们说一下重要的方法：   </p><p><code>asInterface(android.os.IBinder obj)</code><br>用于将服务器的Binder对象转换成客户端所需的<code>AIDL</code>接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于统一进程，那么返回服务器的<code>Stub</code>对象本身，否则返回的是系统封装后的<code>Stub.proxy</code>对象。</p><p><code>onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)</code><br>这个方法运行在服务端的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由<strong>服务端</strong> 的<code>onTransact</code>方法来处理。这个方法有四个参数，分别是<code>code</code> ，<code>data</code>，<code>reply</code>，<code>flags</code>.code是确定客户端请求的方法是哪个，data是目标方法所需的参数，reply是服务器端执行完后的返回值。如果这个方法返回<code>false</code>，那么客户端的请求会失败。 </p><p><code>Proxy#getBookList</code><br>这里的<code>getBookList</code>方法就是在自定义的<code>AIDL</code>文件中定义的方法，这个方法运行在客户端，当客户端远程调用此方法的时候，内部实现是这样的：首先在代理类中创建该方法所需要的输入型Parcel对象_data，输出型Parcel对象_reply和返回值对象List;然后把该方法的参数信息写入<code>_data</code>中，接着<code>mRemote</code>调用<code>transact</code>方法来发起RPC(远程过程调用)请求， 同时<strong>当前线程挂起</strong>，然后服务端的<code>onTransact</code>方法会被调用，直到RPC返回后，当前线程继续执行，并从<code>_reply</code>中取出RPC过程的返回结果并返回(如果有返回值的话)，之前创建的参数其实就是<code>onTransact()</code>方法需要的参数。   </p><p>说完了重要方法，接下来分析<code>AIDL</code>原理：</p><p>服务端：因为要实现<code>Binder</code>，必须在服务器端创建一个<code>Binder</code>对象，如何创建呢？就是new<code>AIDL</code>接口中的<code>Stub</code>内部类，代码示例如：</p><pre><code>Binder mBinder=new IBookManager.Stub(){接口方法实现}</code></pre><p>其中<code>IBookManager</code>是系统根据我们自己定义的<code>IBookManager.AIDL</code>所生成的类。</p><p>Binder驱动：在<code>AIDL</code>中，Binder驱动其实就是<code>AIDL</code>，在<code>AIDL</code>的<code>Proxy</code>类中会传入一个Binder参数，生成一个<code>mRemote</code>引用。</p><p>客户端：要实现客户端跨进程和服务端通信，必须获得服务端的<code>Binder</code>对象在binder驱动层对应的mRemote引用，如何获得呢？首先绑定远程服务，绑定成功后的<code>ServiceConnection</code>中的<code>IBinder service</code>其实就是<code>mRemote引用</code>，但是因为是使用<code>AIDL</code>方式，所以需要在客户端中调用<code>IBookManager.Stub.asInterface(android.os.IBinder obj)</code>方法将服务器返回的Binder对象转换成<code>AIDL</code>接口，然后就可以通过这个接口去调用服务器的远程方法了。 </p><p>根据原理，我们得出<code>AIDL</code>的使用流程，其实很简单，大致就是在服务端创建一个<code>Service</code>，然后创建一个<code>Binder</code>对象，最后在客户端得到这个<code>Binder</code>对象。</p><p><code>AIDL</code>使用流程：<br>先建立<code>AIDL</code>，如果在你建立的<code>AIDL</code>接口中，有自定义的类，那么，也需要建立这个类的AIDL，并且名字要完全相同。同时在使用的时候，一定要显示的导入这个类。接下来的流程就是跟Binder的一样了。</p><p>服务器端：创建<code>Binder</code>对象，并且实现接口中的方法。</p><p>客户端：绑定service，得到<code>Binder</code>对象在驱动层对应的mRemote引用。  </p><p>####重点<br>1.当你在客户端调用服务器的方法的时候，其实是通过代理去访问，详情可以看上面的重点方法介绍里的<code>Proxy#getBookList</code>，所以你在客户端连续调用两次服务器的同一个方法的时候，比如，这里的getBookList，你会发现，里面的对象都不一样。因为每次在调用方法的时候，在代理类中都会创建该方法所需要的参数对象，所以里面的对象会变化。</p><p>2.<code>AIDL</code>中无法使用普通的接口，只能使用<code>AIDL</code>接口，并且实现<code>AIDL</code>接口的时候不能用<code>implements</code>，因为需要实现的接口其实是<code>自定义接口.Stub</code>，而不是自己定义的那个接口。使用<code>implements</code>无法实现。  </p><p>3.解注册的时候需要使用到<code>RemoteCallbackList</code>，需要注意的是这个类的<code>beginBroadcast()</code>和<code>finishBroadcast()</code>一定要配对使用，否则会出现异常<code>java.lang.IllegalStateException: beginBroadcast() called while already in a broadcast</code>，特别是在使用<code>for</code>循环的时候。</p><p>4.对于<code>AIDL</code>中的<code>in</code>，<code>out</code>，<code>inout</code>这里就直接附上一篇别人写的<a href="http://blog.csdn.net/luoyanglizi/article/details/51958091" target="_blank" rel="noopener">博客</a>，这篇博客讲的很详细，而且我也赞同他的观点，纸上得来终觉浅，绝知此事要躬行。  </p><p>5.当使用客户端调用服务器的方法的时候，被调用的方法运行在服务器的Binder线程池中，同时客户端会被挂起，如果此时服务端方法执行耗时的话，就会导致客户端线程长时间阻塞，如果客户端线程是UI线程的话，就会导致客户端ANR，注意的是<code>onServiceConnected(ComponentName name, IBinder service)</code>和<code>onServiceDisconnected(ComponentName name)</code>都运行在UI线程，所以不能在这里调用服务端耗时的方法。同理，对于服务端调用客户端的方法的情况，比如服务端调用客户端的<code>listener</code>中的方法的时候也是一样。即服务端挂起，方法运行在客户端的Binder线程池中。  </p><p>6.当服务端因为某种异常原因停止，我们需要重新启动服务端，这里有两种方式，因为<code>AIDL</code>的底层是<code>Binder</code>，所以可以使用<code>Binder</code>的<code>linkToDeath</code>和<code>unlinkToDeath</code>方法。还有一种方式是在<code>onServiceDisconnected(ComponentName name)</code>重新绑定。这两个区别就是第二种方式可以访问UI，第一种不行，因为像之前说的，<code>onServiceDisconnected(ComponentName name)</code>是运行在UI线程里的。而第一种方式使用的时候需要设置一个<code>IBinder.DeathRecipient</code>接口用于接收服务端<code>binder</code>因为特殊原因消失的通知，当收到通知的时候就会回调<code>binderDied()</code>方法，我们在这里<code>unlinkToDeath</code>并且重新绑定service。而这个<code>binderDied()</code>方法是运行在客户端的<code>Binder</code>线程池中的。</p><h3 id="Messenger的原理及使用"><a href="#Messenger的原理及使用" class="headerlink" title="Messenger的原理及使用"></a>Messenger的原理及使用</h3><p>Messenger大致的原理是这样的，因为Messenger的底层还是<code>AIDL</code>，所以，原理和<code>AIDL</code>差不多。</p><p>服务器：首先需要在服务器创建Binder对象，如何创建呢？通过<code>Messenger</code>来创建，所以我们需要先构造<code>Messenger</code>对象,对于<code>Messenger</code>的构造方法有两种，如下:</p><pre><code>public Messenger(IBinder target) {    mTarget = IMessenger.Stub.asInterface(target);} public Messenger(Handler target) {    mTarget = target.getIMessenger();}</code></pre><p>所以我们需要先构造一个Handler，这个Handler的作用其实就是处理消息。然后我们再通过这个<code>Handler</code>来构造<code>Messenger</code>对象，这个Messenger对象其实就是将客户端发送来的消息传递给Handler来处理，然后我们需要得到Binder对象，通过在<code>Service</code>的<code>onBind</code>方法中<code>return Messenger.getBinder()</code>，这样就得到了<code>Binder</code>对象。  </p><p>Binder驱动：跟<code>AIDL</code>一样，还是<code>Service</code>。</p><p>客户端：也是需要得到服务端的<code>Binder</code>对象在binder驱动层对应的mRemote引用，获得的方式是将<code>ServiceConnection</code>中的<code>IBinder service</code>当做参数传入Messenger的构造函数中，如:</p><pre><code>Messenger mService=new Messenger(service)；</code></pre><p>然后就可以用<code>mService.send(msg)</code>给服务器发消息。实现跨进程通信。<br>因为这里是借助<code>Messenger</code>，所以无法调用服务器端的方法，只能通过message来传递消息。而当服务器需要回应客户端的时候，就需要客户端提供一个<code>Messenger</code>，然后服务器得到这个<code>Messenger</code>，因为在就像客户端向服务端发送请求的时候，也是服务器提供一个<code>Messenger</code>，然后客户端得到这个<code>Messenger</code>。那么如何实现呢？因为客户端和服务器已经建立了连接，所以只需要在客户端发送消息的时候，通过消息的<code>replyTo</code>参数向服务器传入一个<code>Messenger</code>，然后服务器在接收到客户端的消息的时候得到通过<code>message</code>的<code>replyTo</code>参数得到这个<code>Messenger</code>，然后利用这个向客户端发送消息就可以了。主要代码如下:<br>在客户端发送消息给服务器的时候:  </p><pre><code>message.replyTo=clientMessenger;</code></pre><p>服务器接收消息的时候</p><pre><code>Messenger clientMessenger=msg.replyTo;</code></pre><p>这样就在服务器端得到了客户端的<code>Messenger</code>，然后在服务器端通过<code>clientMessenger.send(message);</code>就向客户端发送了消息。</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>1.对于使用<code>Messenger</code>而言，底层其实是<code>AIDL</code>，但是没有<code>AIDL</code>灵活，因为这是借助<code>Messenger</code>来发送消息从而进行消息的传递，不能直接调用服务端的方法，而使用<code>AIDL</code>是直接可以调用服务端的方法。<br>2.对于服务端的<code>Messenger</code>的作用是将客户端传递的消息传递给<code>Handler</code>来处理，而客户端的是发送消息给服务端。<br>3.<code>Messenger</code>是以串行的方式处理客户端发来的消息，当消息多的时候就就不合适了。而<code>AIDL</code>是可以并发处理客户端传来的消息。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="AReview" scheme="http://sakurajiang.github.io/tags/AReview/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-简洁的事件分发</title>
    <link href="http://sakurajiang.github.io/2016/11/16/RestAPP-%E7%AE%80%E6%B4%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://sakurajiang.github.io/2016/11/16/RestAPP-简洁的事件分发/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2020-07-06T09:35:18.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h3><p>事件分发是一个重点也是难点，所以，本篇幅有点长，如果耐心看完本篇，相信读者会有收获的。同时，读者也可以自己写例子测试，毕竟，<strong>纸上得来终觉浅，绝知此事要躬行</strong>。但是，对于水平高的读者，其实<strong>最好的方式是看源代码，因为一切原因都可以从源头找到答案</strong>。</p><h3 id="关于事件分发"><a href="#关于事件分发" class="headerlink" title="关于事件分发"></a>关于事件分发</h3><p>   关于事件分发，其实主要就是理解三个函数，这三个函数分别是<code>dispatchTouchEvent(MotionEvent ev)</code>，<code>onInterceptTouchEvent(MotionEvent ev)</code>以及<code>onTouchEvent(MotionEvent ev)</code>，这里直接上一张图：</p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/伪代码-20161116.png" alt="伪代码-20161116"></p><p>   这张图将分发事件中的重要的三个函数之间的关系表达的比较清晰，这里再简单的解释一下上面的伪代码:一个点击事件产生后，会从外到内传递，传递到根ViewGroup后，会调用根ViewGroup的dispatchTouchEvent方法，然后如果自己的onInterceptTouchEvent方法返回true，表示拦截事件，那么这个事件就会自己处理，也就是调用自己的onTouchEvent方法，如果返回false，就表示自己不拦截这个事件，事件就会传递给子元素，也就是调用子元素的dispatchTouchEvent方法，如此传递下去，直到事件被处理。</p><p>知道了关系以后，我们还需要了解这三个函数，了解一个函数，<strong>其实无非就是理解它的作用，传入的参数以及返回值。</strong><br>先说<code>dispatchTouchEvent(MotionEvent ev)</code>:<br>这个函数的作用是分发事件，不管是ViewGroup还是View都有这个方法，它的返回值受本身的<code>onInterceptTouchEvent(MotionEvent ev)</code>和<code>child.dispatchTouchEvent(MotionEvent ev)</code>共同影响（从上面那张图就可以看出来），返回的各个值的意义如下:<br><code>return true</code> ：表示该View内部消化掉了所有事件。  </p><p><code>return false</code> ：事件在本层不再继续进行分发，这个<code>false</code>也就是本身的<code>dispatchTouchEvent(MotionEvent ev)</code>返回值，而这个返回值会回溯给上层控件的<code>dispatchTouchEvent(MotionEvent ev)</code>，表示自己没有接受这个事件，不管上层控件是<code>view</code>还是<code>viewGroup</code>，都是交由上层控件的<code>onTouchEvent(MotionEvent ev)</code>方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。  　</p><p>如果事件分发返回系统默认的 <code>super.dispatchTouchEvent(ev)</code>，事件将分发给本层的事件拦截<code>onInterceptTouchEvent(MotionEvent ev)</code>方法进行处理，而不是super的onInterceptTouchEvent。因为<code>return super.dispatchTouchEvent(ev)</code>会去运行父viewGroup的<code>dispatchTouchEvent(ev)</code>，然后运行onInterceptTouchEvent，那么这个onInterceptTouchEvent是谁的呢？根据方法是基于对象的，所以就会运行child的<code>onInterceptTouchEvent(MotionEvent ev)</code>也就是本层的事件拦截器，而不是super的onInterceptTouchEvent。详情可以参考规则中的第十条。</p><p>然后是<code>onInterceptTouchEvent(MotionEvent ev)</code>:<br>这个函数的作用是拦截事件，只有<code>ViewGroup</code>有这个方法，返回的各个值的意义如下:<br><code>return true</code> ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；<br><code>return false</code> ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。　<br>如果返回<code>super.onInterceptTouchEvent(ev)</code>，默认false，即表示不拦截该事件，这样事件才能以分发下去。<br>最后是<code>onTouchEvent(MotionEvent ev)</code>:<br>这个函数的作用是处理触摸事件，<code>ViewGroup</code>和<code>View</code>都有这个方法，返回值的意义如下:<br>如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结；</p><p>如果return fasle，则表示不响应事件，如果是ACTION_DOWN事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么事件就会交给Activity处理。且在同一个事件系列中，当前View无法再次接收到该事件序列，如果不是ACTION_DOWN事件，那么不会返回给父view的onTouchEvent处理，而是给Activity处理，并且该view可以继续接收该事件序列；　　</p><p>如果return super.onTouchEvent(event);，默认是true，即表示处理事件。那这个和return true有什么区别呢？从代码就可以看出来，return super.onTouchEvent(event)会执行super.onTouchEvent(event)这个方法。比如，当你继承EditText后，重写onTouchEvent(MotionEvent event)方法，如果你将return super.onTouchEvent(event);换成return true，就会发现当你按返回取消输入框，再次点击自定义EditText时就会无法弹出输入框，解决办法可以是将return true修改成return super.onTouchEvent(event)，或者是在之前调用一次super.onTouchEvent(event)方法，<strong>弹出输入框是在action为ACTION_UP的时候弹出的。</strong>  </p><h3 id="重要的知识点-大家拿本子记一下，高考必考啊"><a href="#重要的知识点-大家拿本子记一下，高考必考啊" class="headerlink" title="重要的知识点(大家拿本子记一下，高考必考啊)"></a>重要的知识点(大家拿本子记一下，高考必考啊)</h3><p>1.一个viewGroup一旦决定拦截事件(这里分两种情况，一个是拦截了ACTION_DOWN事件，还有一个是没有子View满足分发事件的条件或者子view在ACTION_DOWN时返回了false)，那么后面的事件序列都会交给它处理，并且不会再调用<code>onInterceptTouchEvent(ev)</code>方法， 当ACTION_DOWN事件成功传入子view的时候， 那么父ViewGroup在别的事件分发的时候，比如ACTION_MOVE，每次都会调用onInterceptTouchEvent来判断是否拦截当前事件。 <strong>也就是说，父ViewGroup的onInterceptTouchEvent不会再次调用的时机只是自己来处理这个事件，也就是自己的onTouchEvent被调用，只有这个时候才不会再次调用onInterceptTouchEvent，当事件传入子view来处理事件的时候，父ViewGroup都会每次都调用onInterceptTouchEvent来决定是否拦截当前事件。</strong>   </p><p>2.dispatchTouchEvent无论返回true还是false，事件都不再进行分发，<strong>只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望</strong>，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。  </p><p>3.正常情况下，一个事件序列只能被一个view拦截且消耗，因为，一旦决定拦截事件，那么这个事件只能被这个view消耗,并且它的onInterceptTouchEvent(ev)方法也不会<strong>再次调用</strong>(这里的<strong>拦截</strong>和规则一中的拦截是一样的。这里的<strong>再次调用</strong>是指当确定拦截事件后，除了在ACTION_DOWN时调用onInterceptTouchEvent(ev)，后面都不调用，其实跟规则一中说的一样)，如果你想这个事件序列被多个view拦截消耗，那么你可以在拦截事件的那个view中的onTouchEvent()方法中调用你想让其拦截事件的那个view的onTouchEvent()方法来实现。  </p><p>4.view一旦用onTouchEvent()开始处理事件，如果没有处理ATION_DOWN事件，那么同一个事件序列中的事件也不会交给他处理，会回溯给他的父控件，<strong>如果你处理了ACTION_DOWN但是没有处理ACTION_MOVE或者ACTION_UP，那么这个事件还是被你消耗，不会调用父控件的onTouchEvent方法，最后会是Activity处理，后面的事件还是继续交给你处理</strong>。其实，这就类似现实，如果别人第一次叫你做事，你没做好，那么后面就都不会放心叫你做了，如果你第一次做好了，后面没做好，别人还是会给你做的，所以，第一次很重要。</p><p>5.view的onTouchEvent默认都是消费事件的(返回true)，除非是不可点击的，也就是longClickable和clickable都为false，只有这个属性会影响view的onTouchEvent的返回值，别的属性不会，比如，Enabled属性，<strong>就算是Enabled属性为false，也就是disable状态，view的onTouchEvent默认返回的还是true。</strong>  </p><p>6.事件传递是由外向内的，即事件总是传递给父元素，再由父元素分发给子控件，通过requestDisallowInterceptTouchEvent();方法可以在子元素中干预父元素的事件分发过程，<strong>但是不能干预ACTION_DOWN事件</strong>，因为当时ACTION_DOWN事件的时候，父元素会重置FLAG_DISALLOW_INTERCEPT标志位。  </p><p>7.使用内部拦截法的时候，为了弄清楚顺序，我就直接调试，结果，运行到父元素的dispatchTouchEvent后，不会去调用父元素的onInterceptTouchEvent方法，直接就到了子元素的dispatchTouchEvent，依然会运行到子view的onTouchEvent，等到ACTION_UP的时候才会又跑到父元素中的dispatchTouchEvent和onInterceptTouchEvent去判断是否拦截ACTION_UP事件。我倒腾了一天，才发现是需要移动，也就是让move多次调用才行，因为事件是由外向内的，当第一次ACTION_MOVE事件到的时候，先运行父ViewGroup的dispatchTouchEvent方法，此时FLAG_DISALLOW_INTERCEPT依然是设置成true，所以，不会运行父ViewGroup的onInterceptTouchEvent方法，直接就会运行子view的dispatchTouchEvent方法，然后FLAG_DISALLOW_INTERCEPT被设置成false，于是当第二次的ACTION_MOVE到来的的时候，才会去运行父viewGroup的onInterceptTouchEvent方法，然后子view收到ACTION_CANCEL事件，<strong>等到第三个ACTION_MOVE的时候父viewGroup才开始拦截事件。</strong>但是因为我之前是调试，所以都只有一次move事件，结果就不一样了。也是醉了。并且使用内部拦截法的时候，ACTION_UP事件也会被父view拦截，不会传递到子view中，也就意味着子view的onClick事件不会响应，这一点要记住。</p><p>8.内部拦截法和外部拦截法的区别:内部拦截法需要到该事件的第三个的时候才有用，也就是该事件的第一个依然被子view得到，外部拦截法则是到第二个就有用了，子view不会得到该事件的任何一个，比如，拦截ACTION_MOVE的时候，<strong>使用内部拦截法在拦截第三个ACTION_MOVE的时候才拦截了</strong>，因为第一个ACTION_MOVE会被子view得到，<strong>而使用外部拦截法则是第二个ACTION_MOVE的时候就拦截了</strong>，因为子view不会得到ACTION_MOVE中的任何一个。详情可以见9，10。所以，使用外部拦截法要好点。  </p><p>9.当viewGroup没有拦截ACTION_DOWN而拦截了ACTION_MOVE或者ACTION_UP的时候，那么，第一个被拦截的动作不会在viewGroup中的onTouchEvent中触发，也不会在子view的onTouchEvent中触发，而是子view会受到ACTION_CANCEL事件。该事件序列后面的事件都会被拦截，并且下一个同类型的事件传来时，不会再调用viewGroup的onInterceptTouchEvent方法，直接就调用viewGroup的onTouchEvent方法，这里解释一下，什么是第一个被拦截的动作，比如，多个move的时候，第一个move就不会被父view或者子view执行，感觉是这个事件变成了ACTION_CANCEL事件传递到了子view。也就是说，一旦在这种情况下，ACTION_UP事件永远不会被子view接收。<strong>也就意味着，不管是使用外部拦截法还是内部拦截法，只要拦截了，那么子view就收不到ACTION_UP事件。</strong>还有就是ViewGroup就不要拦截ACTION_UP了，因为这样大家都得不到ACTION_UP事件，何必呢？  </p><p>10.为了讲述方便，当从一个ViewGroup分发事件到子ViewGroup时，在子ViewGroup的dispatchTouchEvent方法中调用父类的dispatchTouchEvent，发现不会继续调用父类的onInterceprTouchEvent，而是直接调用子ViewGroup的onInterceptTouchEvent，为什么在这里调用父类的dispatchTouchEvent不会跟着调用父类的onInterceptTouchEvent？我调试和看源码发现当运行到findChildWithAccessibilityFocus()方法时，view会变成接受到事件的view，然后就不知道了。水平还是看不懂源代码。其实这是因为我对java的理解有错误，基于方法都是基于对象的，所以在子viewGroup中调用父类的dispatchTouchEvent，也就是super.dispatchTouchEvent()时，这时会运行到父viewGroup的dispatchTouchEvent里，会调用onInterceptTouchEvent方法，<strong>这时的onInterceptTouchEvent其实就已经是子viewGroup的onInterceptTouchEvent方法，而不是父ViewGroup的dispatchTouchEvent方法，因为方法是基于对象的。</strong> </p><p>11.onClick发生的前提就是可点击，并且收到了<strong>ACTION_DOWN和ACTION_UP事件</strong>。这里解释一下，这里的收到了用词不是那么准确，<strong>应该是能接收到事件，并且return super.onTouchEvent()了，记住是return super.onTouchEvent()，如果是return true都不行</strong>，因为return true没有执行view的onTouchEvent方法，而点击事件是在ACTION_UP中设置的。即在ACTION_UP的时候源码中调用了<code>performClick()</code>方法。这里贴一部分源代码 </p><p>  TextView的源代码:</p><pre><code>final boolean superResult = super.onTouchEvent(event);</code></pre><p>  View的源代码:</p><pre><code>case MotionEvent.ACTION_UP:              boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;              if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {                  // take focus if we don&apos;t have it already and we should in                  // touch mode.                  boolean focusTaken = false;                  if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {                      focusTaken = requestFocus();                  }                  if (prepressed) {                      // The button is being released before we actually                      // showed it as pressed.  Make it show the pressed                      // state now (before scheduling the click) to ensure                      // the user sees it.                      setPressed(true, x, y);                 }                  if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {                      // This is a tap, so remove the longpress check                      removeLongPressCallback();                      // Only perform take click actions if we were in the pressed state                      if (!focusTaken) {                          // Use a Runnable and post this rather than calling                          // performClick directly. This lets other visual state                          // of the view update before click actions start.                          if (mPerformClick == null) {                              mPerformClick = new PerformClick();                          }                          if (!post(mPerformClick)) {                              performClick();                          }                      }                  }</code></pre>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-fragment生命周期</title>
    <link href="http://sakurajiang.github.io/2016/11/10/RestAPP-fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://sakurajiang.github.io/2016/11/10/RestAPP-fragment生命周期/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2020-07-06T09:31:45.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先说一下"><a href="#先说一下" class="headerlink" title="先说一下"></a>先说一下</h3><p>   之前我觉得v4包下的fragment和app下的fragment生命周期应该是一样的，结果不一样。</p><h3 id="app包下的fragment生命周期"><a href="#app包下的fragment生命周期" class="headerlink" title="app包下的fragment生命周期"></a>app包下的fragment生命周期</h3><h4 id="开关屏幕时fragment的生命周期"><a href="#开关屏幕时fragment的生命周期" class="headerlink" title="开关屏幕时fragment的生命周期"></a>开关屏幕时fragment的生命周期</h4><p>   直接在最开始使用add方法添加到activity后，fragemnt的生命周期<br><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragmentfirstAdd-20161110.png" alt="appfragmentfirstAdd-20161110"></p><p>  关闭屏幕后的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragment1%20closecereen-20161110.png" alt="appfragment1 closecereen-20161110"></p><p>  打开屏幕后的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragment1openscreen-20161110.png" alt="appfragment1openscreen-20161110"></p><p> 销毁activity后的生命周期:</p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/appfragmentthenactivitydestroy-20161110.png" alt="appfragmentthenactivitydestroy-20161110"></p><h4 id="调用各个方法后fragment的生命周期"><a href="#调用各个方法后fragment的生命周期" class="headerlink" title="调用各个方法后fragment的生命周期"></a>调用各个方法后fragment的生命周期</h4><p>当fragment1加载后，点击按钮后用add方法加载fragment2后生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragment2Add-20161110.png" alt="appfragment2Add-20161110"></p><p>  调用remove方法后fragment生命周期：</p><p>  <img src="http://oaz1z7cqt.bkt.clouddn.com/appfragmentremove-20161110.png" alt="appfragmentremove-20161110"></p><p>调用attach后fragment的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragment1Attach-20161110.png" alt="appfragment1Attach-20161110"></p><p>调用detach后fragment的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appfragment1detach-20161110.png" alt="appfragment1detach-20161110"></p><p>调用replace加载fragment2后fragment2以及fragment1的生命周期</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/appafterfragment1Addthenreplace-20161110.png" alt="appafterfragment1Addthenreplace-20161110"></p><p>  销毁activity后的生命周期:</p><h3 id="v4包下的fragment生命周期"><a href="#v4包下的fragment生命周期" class="headerlink" title="v4包下的fragment生命周期"></a>v4包下的fragment生命周期</h3><h4 id="开关屏幕时的fragment生命周期"><a href="#开关屏幕时的fragment生命周期" class="headerlink" title="开关屏幕时的fragment生命周期"></a>开关屏幕时的fragment生命周期</h4><p>   直接最开始使用add方法添加到activity后，fragemnt的生命周期<br>       <img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragemntfirstAdd-20161110.png" alt="v4fragemntfirstAdd-20161110"></p><p>  关闭屏幕后的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment1closescreen-20161110.png" alt="v4fragment1closescreen-20161110"></p><p>  打开屏幕后的生命周期:</p><p>  <img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment1openscreen-20161110.png" alt="v4fragment1openscreen-20161110"></p><p>  销毁activity后的生命周期:</p><p>  <img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragmentthenactivitydestroy-20161110.png" alt="v4fragmentthenactivitydestroy-20161110"></p><h4 id="调用各个方法后fragment的生命周期-1"><a href="#调用各个方法后fragment的生命周期-1" class="headerlink" title="调用各个方法后fragment的生命周期"></a>调用各个方法后fragment的生命周期</h4><p>当fragment1加载后，点击按钮后用add方法加载fragment2后生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment2%20Add-20161110.png" alt="v4fragment2 Add-20161110"></p><p>   调用remove方法后fragment生命周期</p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment1Remove-20161110.png" alt="v4fragment1Remove-20161110"></p><p>调用attach后fragment的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment1Attach-20161110.png" alt="v4fragment1Attach-20161110"></p><p>调用detach后fragment的生命周期:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/v4fragment1%20Detach-20161110.png" alt="v4fragment1 Detach-20161110"></p><p>调用replace加载fragment2后fragment2以及fragment1的生命周期</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/v4afterfragment1%20Addthenreplace-20161110.png" alt="v4afterfragment1 Addthenreplace-20161110"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.显示fragment有add，attach，show。消失fragment有remove，detach，hide。<strong>第一次fragment要动态添加到activity中，必须使用add方法，增加到回退栈只能通过addToBackStack()方法。</strong><br> 2.调用add方法运行的生命周期是从onAttach到onResume，(app包下的fragment是从onCreate到onResume)，remove方法运行周期是onPause到onDetach，并且，都是先销毁再添加，即调用add方法的时候还调用了销毁的方法，那么都是先销毁再添加，但是由于v4下的fragment在add方法的时候会执行onAttach到onResume，<strong>就像我在上一篇博客(viewPager下fragment生命周期)中讲的一样，fragment的onAttach，onCreate都会在别的fragment的除了onAttach，onCreate之外的生命周期之前</strong>，所以，调用replace方法后的生命周期，v4下的fragment是这样，app下的fragment是那样。并且，在remove的时候调用 addToBackStack()方法，那么调用remove生命周期只会是onPause到onDestroyView。<br>3.调用attach方法运行的生命周期是onCreateView到onResume  ，detach方法运行生命周期是onPause到onDestroyView ，<strong>同时这两个谁先使用谁先调用，也就是那边的生命周期先走。</strong>这个方法的作用就是将fragment试图粘到UI试图中，而不是将fragment粘在activity上。<br>4.<strong>调用show()和hide()方法不会运行声明周期。</strong><br>5.<strong>要想消失后正确的显示，必须调用与让其消失对应的方法，</strong>即如果你通过detach方法让fragment消失，那么就要用attach方法，别的都不行。对别的也是一样。<br>6.因为fragment是依赖activity的，所以，<strong>activity先于fragment准备好，后于fragment消失</strong>，<br>但是，v4下的fragment的onStart在activity的onstart之前，这一点，可以翻阅源码查看:<br>v4下fragment的onStart源码:</p><pre><code>/** * Called when the Fragment is visible to the user.  This is generally * tied to {@link Activity#onStart() Activity.onStart} of the containing * Activity&apos;s lifecycle. */@CallSuperpublic void onStart() {    mCalled = true;    if (!mLoadersStarted) {        mLoadersStarted = true;        if (!mCheckedForLoaderManager) {            mCheckedForLoaderManager = true;            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);        }        if (mLoaderManager != null) {            mLoaderManager.doStart();        }    }}</code></pre><p>app下fragment的onStart源码</p><pre><code>public void onStart() {    throw new RuntimeException(&quot;Stub!&quot;);}</code></pre>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-viewPager下fragment的生命周期</title>
    <link href="http://sakurajiang.github.io/2016/11/10/RestAPP-viewPager%E4%B8%8Bfragment%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://sakurajiang.github.io/2016/11/10/RestAPP-viewPager下fragment的生命周期/</id>
    <published>2016-11-09T16:00:00.000Z</published>
    <updated>2020-07-06T09:32:15.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么写这个"><a href="#为什么写这个" class="headerlink" title="为什么写这个"></a>为什么写这个</h2><p>  在网上也有很多这个例子，但是感觉讲的都不很清楚，于是想自己跑一遍来看看整个过程，话不多说，下面就直接开始，我们知道ViewPager对fragment的管理其实是通过Adapter来管理的，下面我就分情况一一介绍，首先是Adapter继承FragmentPagerAdapter时的情况。</p><h3 id="先吐槽一下"><a href="#先吐槽一下" class="headerlink" title="先吐槽一下"></a>先吐槽一下</h3><p>我之前其实已经快写好了博客，但是，后面突然发现我设置Log的位置不对，设置在了super之前，这个时候方法还没执行完，只是开始执行，这时就会产生一些偏差，就是一点不同，就是在启动程序的时候的setUserVisibleHint()方法的执行时间上不同，如下:</p><p>Log语句放在super之前</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/showFirstFragment&amp;&amp;limite1-2016116.png" alt="showFirstFragment&amp;&amp;limite1-2016116">  </p><p>Log语句放在super之后  </p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/showFirstFragment&amp;&amp;limite1-2016118.png" alt="showFirstFragment&amp;&amp;limite1-2016118">  </p><p>别的时候都是一样的。</p><p><strong>以下的测试都是将Log语句放在super后面的时候的生命周期</strong></p><h3 id="当Adapter继承FragmentPagerAdapter"><a href="#当Adapter继承FragmentPagerAdapter" class="headerlink" title="当Adapter继承FragmentPagerAdapter"></a>当Adapter继承FragmentPagerAdapter</h3><p>  先上Adapter的代码    </p><pre><code>  public class MyAdapter extends FragmentPagerAdapter{    public MyAdapter(FragmentManager fm) {        super(fm);    }    @Override    public int getCount() {        return list.size();    }    @Override    public Fragment getItem(int position) {        return list.get(position);    }}  </code></pre><p>在我们使用的时候Adapter一般都是这么写的，测试的时候，我在viewpager中加了四个fragment，主要代码如下  </p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());viewPager.setOffscreenPageLimit(1);viewPager.setAdapter(myAdapter);viewPager.setCurrentItem(0);fragmentManager=getSupportFragmentManager();  </code></pre><p>我们直接看结果：<br><strong>当程序启动的时候，生命周期如下：</strong>    </p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/showFirstFragment&amp;&amp;limite1-2016118.png" alt="showFirstFragment&amp;&amp;limite1-2016118"></p><p><strong>当从第一个fragment滑到第二个fragment的时候</strong>      </p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/first-%20two-20161110.png" alt="first- two-20161110"></p><p><strong>当从第二个滑到第三个的时候</strong></p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/two-three-2016116.png" alt="two-three-2016116"></p><p><strong>当从第三个滑到第四个的时候</strong></p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/three-four-2016116.png" alt="three-four-2016116"></p><p><strong>当从第四个滑到第三个的时候</strong></p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/four-three-2016116.png" alt="four-three-2016116"></p><p><strong>当从第三个滑到第二个的时候</strong> </p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/three-two-2016116.png" alt="three-two-2016116"></p><p><strong>当从第二个滑到第一个的时候</strong></p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/two-first-2016116.png" alt="two-first-2016116"></p><p>由上图，我们可以得出，当程序执行的时候，<strong>viewpager加载fragment的顺序是，先onAttach当前的fragment，再向左遍历左边的fragment，遍历右完后，再向遍历，但这只是onAttach和onCreate的执行顺序，然后当OnCreateView和onActivityCreated的时候则是先遍历加载左边的，再遍历加载右边的，最后才是当前页。</strong>然后第一次的onStart、onResume的时候则是又按照onAttach和onCreate的顺序执行。为什么要说第一次的onStart、onResume，因为当屏幕关闭的时候，执行顺序还是按照OnCreateView和onActivityCreated的顺序，这里选的时间是从第一个fragment滑到第二个fragment之后，关闭屏幕，生命周期如下: </p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/first-two&amp;&amp;onPause-2016116.png" alt="first-two&amp;&amp;onPause-2016116"></p><p>看到这里，估计很多人就很乱了，就想问fragment的加载顺序到底是什么呢？这时，我通过如下代码得到fragment的list表，代码如下:</p><pre><code>getfragmentList=getSupportFragmentManager().getFragments();   Log.e(&quot;log&quot;, &quot;getfragmentlist&quot;  + getfragmentList);   if(getfragmentList!=null) {       for (int i = 0; i &lt;getfragmentList.size();i++)           Log.e(&quot;log&quot;, &quot;getfragmentlist&quot; +i  + getfragmentList.get(i));   }</code></pre><p>这时，运行程序，加载完所有的fragment后的list顺序，如下：  </p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/first%20showfragmentlist-20161110.png" alt="first showfragmentlist-20161110"></p><p>由于屏幕原因，list中的后面看不到，但是通过for循环中的输出，还是可以看出fragment加载顺序其实是<br><strong>fragment2 fragment1 fragment3 fragment4</strong>，也就是onCreateView、onActivityCreated时的顺序，也就是说在onCreateView的时候建立了fragment的顺序，除了第一次，后面的生命周期都是按照这个顺序走的(除了滑动的时候)，就像上面的关闭屏幕时候的生命周期一样，细心的朋友可能注意到了图片后面的<strong>1 0 2 3</strong>，那这个是什么呢？这是各个fragment对应的下标，这个是你在list中添加fragment的顺序，如代码:  </p><pre><code>public void addFragment(){    list.add(myfragment1);    list.add(myfragment2);    list.add(myfragment3);    list.add(myfragment4);}</code></pre><p>也就是fragemnt2对应1，fragemnt1对应0，fragemnt3对应2，fragemnt4对应3，这个顺序控制着fragment在页面中的顺序，也就是fragment1，fragment2，fragment3，fragment4。这里验证一下，修改代码，如下:</p><pre><code>public void addFragment(){    list.add(myfragment2);    list.add(myfragment1);    list.add(myfragment3);    list.add(myfragment4);}</code></pre><p>运行程序，加载完所有的fragment后的list的顺序，如下:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/showFragmentList&amp;&amp;first&amp;&amp;curr0,limit1,%20not%20order-20161110.png" alt="showFragmentList&amp;&amp;first&amp;&amp;curr0,limit1, not order-20161110"></p><p>这里就是fragment1对应1，fragment2对应0，fragment3对应2，fragment4对应3，页面中的fragment顺序是fragment2，fragment1，fragment3，fragment4。  </p><p>还是拿之前的在list中添加fragment的顺序来进行下面的测试，也就是fragemnt2对应1，fragemnt1对应0，fragemnt3对应2，fragemnt4对应3，即fragment在页面中的顺序，也就是fragment1，fragment2，fragment3，fragment4来继续说，因为我们设置了<strong>  viewPager.setCurrentItem(0);</strong>，所以我们先onAttach ，onCreate fragemnt1，又设置了 viewPager.setOffscreenPageLimit(1);，所以再<br>onAttach ，onCreate fragemnt2，那么为什么先onCreateView onActivityCreated fragment2呢？这是因为viewpager的加载机制，会自动的将左右两边加载出来，所以，一下子就会加载两个，为了确保所有的view都创建，所以，将最开始要显示的view放在最后，即把fragment2的onCreateView，onActivityCreated放在fragment1的后面，那么，为什么fragment1的onStart，onResume先执行呢？这是为了用户体验，即将当前需要显示的先显示，因为这个时候是fragment1先显示。这里有一个奇怪的地方，就是<strong>第二个滑到第三个和第三个滑到第二个的图片</strong>，第二个滑到第三个的时候，fragment1是先执行onPause，onStop，onDestroy方法，再执行fragment4的onCreateView，onActivityCreated，onStart，onResume方法，而第三个滑到第二个的时候，则是先执行fragment1的onCreateView，onActivityCreated再执行fragemnt4的onPause，onStop，onDestroy方法，最后再执行onStart，onResume方法。为什么呢？这里先放一下，先验证上面的猜想，将代码修改一下   </p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());   viewPager.setOffscreenPageLimit(2);   viewPager.setAdapter(myAdapter);   viewPager.setCurrentItem(1);   fragmentManager=getSupportFragmentManager();</code></pre><p>结果如下：<br><img src="http://oaz1z7cqt.bkt.clouddn.com/showFirstFragment&amp;&amp;curr1limit2-2016116.png" alt="showFirstFragment&amp;&amp;curr1limit2-2016116"><br>所以，这个顺序也验证了我们之前的想法，但是那个奇怪的地方还没解决，我们再修改代码：</p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());  viewPager.setOffscreenPageLimit(1);  viewPager.setAdapter(myAdapter);  viewPager.setCurrentItem(1);  fragmentManager=getSupportFragmentManager();</code></pre><p>程序运行结果如下：  </p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/firstShowFragmentcurr1limit1-2016116.png" alt="firstShowFragmentcurr1limit1-2016116"></p><p>因为我们显示的就是第二个页面，所以从第二个页面滑到第三个，效果如下：</p><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/two-three&amp;&amp;curr1limit1-2016116.png" alt="two-three&amp;&amp;curr1limit1-2016116"></p><p>从第三个滑到第二个，效果如下：<br><img src="http://oaz1z7cqt.bkt.clouddn.com/three-two&amp;&amp;curr1limit1-2016116.png" alt="three-two&amp;&amp;curr1limit1-2016116"><br>我们再加载完所有的fragment，再从第二个滑到第三个试试，就是不执行onAttach和onCreate，这样看的舒服一点，结果如下：<br>  <img src="http://oaz1z7cqt.bkt.clouddn.com/two-three&amp;&amp;curr1limit1loadallfragment-2016117.png" alt="two-three&amp;&amp;curr1limit1loadallfragment-2016117"></p><p>可以看到，执行顺序其实是类似的。也就是，当fragemnt3滑到fragemnt2的时候，fragemnt1的onCreateView和onActivityCreated会在fragemnt4的onPause，onStop，onDestroyView，先执行，然后再执行fragment1的onStart，onResume，为什么呢？我觉得，<strong>为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管，当onAttach，onCreate之后，会先确定一个顺序，这里称为顺序2，也就是中左右，但是当onCreateView执行后，就确定了顺序3，这个顺序3就是<code>getSupportFragmentManager().getFragments();</code>得到的list的顺序，后面的生命周期(除了第一次启动以及左右滑动时的生命周期)都是按照这个顺序执行的，也就是左右中，为什么说除了第一次启动以及左右滑动时的生命周期，这里先说第一次启动，因为，在第一次启动后的onStart和onResume都是按照onAttach的顺序，而不是按照fragment的顺序，左右滑动的生命周期是按照你在viewPager中给添加fragment的顺序，这一点后面解释，确定了fragment顺序后，排在链表前面的fragment的方法肯定在排在后面的fragment方法之前，这一点很重要，举个例子，就比如上面的关闭屏幕那张生命周期图片，因为链表的顺序，所以生命周期会是这样。这里再解释上面的滑动顺序，这里贴上我添加fragment的代码</strong>  </p><pre><code>list.add(myfragment1);list.add(myfragment2);list.add(myfragment3);list.add(myfragment4);</code></pre><p><strong>可以看出顺序是fragment1，2，3，4。这个顺序就是顺序1，顺序1是在滑动的情况会用到。为什么我会将之前的顺序命名为顺序2，因为这个顺序是最开始你在程序中通过add(fragment)确定的顺序，在滑动的时候，谁在前面谁先生成视图或者先销毁，也就是谁在前面谁先执行，这里需要明确一点就是，任何fragment的第一部分生命周期肯定运行在别的fragment的除第一部分生命周期的生命周期前面，这一点很重要，同时还有一点，当既有fragment视图生成又有fragment视图销毁的时候，其实就是滑动的时候，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行，</strong>这里解释后面一点，修改代码:</p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());    viewPager.setOffscreenPageLimit(1);    viewPager.setAdapter(myAdapter);    viewPager.setCurrentItem(3);</code></pre><p>当第一次从3滑到2的时候生命周期如图:</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/thrid-second&amp;&amp;%20curr3,limit1-20161110.png" alt="thrid-second&amp;&amp; curr3,limit1-20161110"></p><p>因为顺序1是fragment1，2，3，4。所以应该是fragment1先执行第一部分，再执行第二部分生成视图，再fragment4执行销毁视图，再fragment1执行第三部分。但是结果却是这个，说明<strong>当既有fragment视图生成又有fragment视图销毁的时候，其实就是滑动的时候，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行。</strong></p><p> <strong>看第二个滑到第三个，第三个滑到第二个这个情况，先看第一次第二个滑到第三个的情况，因为，任何fragment的第一部分生命周期肯定运行在别的fragment的除第一部分生命周期的生命周期前面，同时哦，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行，又因为在顺序1中，fragment1在fragment4的前面，所以，fragment1先销毁，fragment4再生成和显示，所以，先执行fragment1的onAttach，onCreate，再执行fragment1的onPause，onStop，onDestroyView，再执行fragment4的onCreateView，onActivityCreated。而在第三个滑到第二个时，因为，不需要onAttach和onCreate，又因为在顺序1中，fragment1在fragment4的前面，所以，会先执行fragment1的onCreateView，onActivityCreated，再执行fragment4的onPause，onStop，onDestroyView。然后到显示的时候，再执行fragment1的onStart，onResume。为什么不会直接运行fragment1的onCreateView，onActivityCreated，onStart，onResume呢？因为viewPager.setOffscreenPageLimit(1);方法的限制，所以只有先将销毁视图的fragment的视图销毁，才能显示，所以接下来执行fragment4的onPause，onStop，onDestroyView，最后执行fragment1的onStart，onResume。然后，再一次从第二个滑到第三个的情况，因为，不需要onAttach和onCreate，又因为在顺序1中，fragment1在fragment4的前面，所以，fragment1先销毁，fragment4再生成和显示，所以，先执行fragment1的onPause，onStop，onDestroyView，再执行fragment4的onCreateView，onActivityCreated，onStart，onResume。这里可能有人会说，为什么不是按照顺序2来判断，因为在顺序2中，fragment1也是在fragment4之前呀</strong>，这里还是原来的代码:</p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());  viewPager.setOffscreenPageLimit(1);  viewPager.setAdapter(myAdapter);  viewPager.setCurrentItem(3);</code></pre><p>这时，顺序1是fragment1，2，3，4.而顺序2变成fragment4，3，2，1。这两个顺序中fragment1和fragment4顺序不一样，看从2滑到3的生命周期，如图：<br>   <img src="http://oaz1z7cqt.bkt.clouddn.com/second-thrid&amp;&amp;first，curr3，limit1-2016118.png" alt="second-thrid&amp;&amp;first，curr3，limit1-2016118"></p><p><strong>因为fragment1先销毁fragment4再生成显示，所以是按照顺序1，不是顺序2。为了验证我的猜想，然后我去翻源代码，找了好久，但是没有找到，原谅我是个彩笔，如果有大神找到，请告诉我。不胜感激。 同时，这里还有一点，那就是setUserVisibleHint()方法执行的时间，这个方法不是属于生命周期的范围，我觉得这个方法调用的时间是如果是都要生成视图，也就是第一次显示的时候，那么就和onAttach的顺序是一样的，如果显示后移动的情况，那么看移动到当前位置时是否需要生成新的fragment视图，如果需要先生成，即先执行生成页的setUserVisibleHint()方法，然后再执行先前页的这个方法，在执行当前页的这个方法就像当从第二页滑到第三页的时候setUserVisibleHint()方法执行的顺序一样，即先执行fragment4的setUserVisibleHint()方法，再执行fragment2的setUserVisibleHint()方法，最后再是fragment3的setUserVisibleHint()方法。</strong><br>总的来说，为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管，，**顺序1是由viewpager中的添加fragment时设置的，顺序2是根据顺序1和viewPager.setCurrentItem();，以及viewPager.setOffscreenPageLimit(1);共同决定的，顺序2就是在顺序1中先找出viewPager.setCurrentItem()的fragment，然后向左遍历fragment，然后向右遍历fragment。这就是onAttach，onCreate的顺序，举个例子，顺序1是1，2，3，4。viewPager.setCurrentItem(0)，viewPager.setOffscreenPageLimit(1);，那么顺序2就是fragment2，1，3，4。如果viewPager.setCurrentItem(2)，viewPager.setOffscreenPageLimit(1);不变，顺序2就是2，3，4，1。如果是viewPager.setCurrentItem(2)，viewPager.setOffscreenPageLimit(2);，顺序2就是fragment2，1，4，3。顺序3也是顺序1和viewPager.setCurrentItem();，以及viewPager.setOffscreenPageLimit(1);共同决定的，只是先遍历viewPager.setCurrentItem();，再遍历viewPager.setCurrentItem();右边的，最后再 遍历viewPager.setCurrentItem();，顺序3使用最广泛，除了顺序1和顺序2，别的都是顺序3。<br>更简单的说，为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管记住几个规则:  </p><p><strong>1.有三个顺序，分别是顺序1，顺序2，顺序3。顺序1就是添加fragment的顺序，顺序2就是中左右，顺序3就是左右中。</strong>  </p><p><strong>2.第一次启动的时候，生命周期的第一，三部分按照顺序2，第二部分按照顺序3</strong>  </p><p><strong>3.滑动的时候按照顺序1，并且谁在前面谁先生成视图或者先销毁，也就是谁在前面谁先执行，但是，生命周期的第一部分和第二部分不会在一起执行。也就是说当生成视图的fragment在销毁视图的fragment之前，但是同时，生成视图的fragment的第一部分要执行，这时，执行顺序就是，生成视图的fragment的第一部分，销毁视图的fragment第四部分，生成视图的fragment的第二部分，第三部分。如果，这时，生成视图的fragment的第一部分不用执行，那么就会先执行生成视图的fragment的第二部分，当要执行第三部分的之后，由于viewPager.setOffscreenPageLimit(1);方法的限制，所以只有先将销毁视图的fragment的视图销毁，才能显示，所以第三部分没有直接跟着第二部分执行，而是最后执行。</strong>  </p><p><strong>4.剩下的时候都是按照顺序3，比如关闭屏幕，重新显示之类的。</strong>  </p><p><strong>5.因为setUserVisibleHint()这个方法，不算生命周期，所以这个执行的时间就是谁先显示谁先调用，并且，当isVisibleToUser为false的时候执行在第一部分之前，isVisibleToUser为true的时候执行在第一部分之后</strong>    </p><p>说的很啰嗦，其实看图片的结果就知道了，为了验证上面的结果，我去翻源码，找了好久，但是没找到，原谅我水平不够，如果有大神找到的话，请告诉我，不胜感激。**  </p><h3 id="当Adapter继承FragmentStatePagerAdapter"><a href="#当Adapter继承FragmentStatePagerAdapter" class="headerlink" title="当Adapter继承FragmentStatePagerAdapter"></a>当Adapter继承FragmentStatePagerAdapter</h3><p>先上Adapter代码</p><pre><code> public class MyAdapter extends FragmentStatePagerAdapter{    public MyAdapter(FragmentManager fm) {        super(fm);    }    @Override    public int getCount() {        return list.size();    }    @Override    public Fragment getItem(int position) {        return list.get(position);    }}</code></pre><p>程序主要代码如下：</p><pre><code>myAdapter=new MyAdapter(getSupportFragmentManager());    viewPager.setOffscreenPageLimit(1);    viewPager.setAdapter(myAdapter);    viewPager.setCurrentItem(0);    fragmentManager=getSupportFragmentManager();  </code></pre><p>程序运行结果：</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/showSecondFragment&amp;&amp;%20curr0%20limit1-2016118.png" alt="showSecondFragment&amp;&amp; curr0 limit1-2016118"></p><p>第一个滑到第二个</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/first-second&amp;&amp;second,curr0,limit1-2016117.png" alt="first-second&amp;&amp;second,curr0,limit1-2016117"></p><p>第二个滑到第三个</p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/second-thrid&amp;&amp;%20second,curr0,limit1-20161110.png" alt="second-thrid&amp;&amp; second,curr0,limit1-20161110"></p><p>第三个滑到第四个  </p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/thrid-fouth&amp;&amp;second,curr0,limit1-2016117.png" alt="thrid-fouth&amp;&amp;second,curr0,limit1-2016117"></p><p>第四个滑到第三个</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/fouth-thrid&amp;&amp;second,curr0,limit1-2016117.png" alt="fouth-thrid&amp;&amp;second,curr0,limit1-2016117"></p><p>第三个滑到第二个</p><p> <img src="http://oaz1z7cqt.bkt.clouddn.com/thrid-second&amp;&amp;second,curr0,limit1-2016117.png" alt="thrid-second&amp;&amp;second,curr0,limit1-2016117"></p><p>第二个滑到第一个</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/second-first&amp;&amp;second,curr0,limit1-2016117.png" alt="second-first&amp;&amp;second,curr0,limit1-2016117"></p><p>第一个滑到第二个后按Pause</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/first-second&amp;&amp;second,curr0,limit1,pause-2016117.png" alt="first-second&amp;&amp;second,curr0,limit1,pause-2016117"></p><p>第一个滑到第二个后的fragemntList</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/first-secondShowFragmentList&amp;&amp;second,curr0,limit1,-2016117.png" alt="first-secondShowFragmentList&amp;&amp;second,curr0,limit1,-2016117"></p><p>第二个滑到第三个后的fragemntList</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/two-threeShowFragmentList&amp;&amp;%20%20second,curr0,limit1-20161110.png" alt="two-threeShowFragmentList&amp;&amp;  second,curr0,limit1-20161110"></p><p>第三个滑到第二个后的fragmentList</p><p><img src="http://oaz1z7cqt.bkt.clouddn.com/thrid-secondShowFragmentList&amp;&amp;%20Second,curr0,limit1-20161110.png" alt="thrid-secondShowFragmentList&amp;&amp; Second,curr0,limit1-20161110"></p><p>从上图可以看出，跟FragmentPagerAdapter相比，<strong>FragmentStatePagerAdapter每次销毁的时候是直接remove，所以会在销毁之后重新显示的话，就会执行fragment的所有周期函数来显示。</strong>  </p><p>  FragmentPagerAdapter的destroyItem()方法  </p><pre><code> @Overridepublic void destroyItem(ViewGroup container, int position, Object object) {    if (mCurTransaction == null) {        mCurTransaction = mFragmentManager.beginTransaction();    }    if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object            + &quot; v=&quot; + ((Fragment)object).getView());    mCurTransaction.detach((Fragment)object);}  </code></pre><p>   FragmentStatePagerAdapter的destroyItem()方法</p><pre><code>@Overridepublic void destroyItem(ViewGroup container, int position, Object object) {    Fragment fragment = (Fragment) object;    if (mCurTransaction == null) {        mCurTransaction = mFragmentManager.beginTransaction();    }    if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object            + &quot; v=&quot; + ((Fragment)object).getView());    while (mSavedState.size() &lt;= position) {        mSavedState.add(null);    }    mSavedState.set(position, fragment.isAdded()            ? mFragmentManager.saveFragmentInstanceState(fragment) : null);    mFragments.set(position, null);    mCurTransaction.remove(fragment);}</code></pre><p><strong>注意最后两张图片中的list，分别有一个是空的，这也就说明，这里的fragment为空，但是依然占着位置，下次生成这个的时候，直接插入到这个位置，所以顺序2还是不会改变。同时，也没有后面的1 0 2 3，同时，上面划分的Fragment生命周期四部分也不一样，最后一部分应该再加上onDestroy，onDetach。生命周期的差异就体现在当有销毁又有生成fragment的视图的时候，这个时候跟FragmentPagerAdapter不一样，都是生成视图的fragment的第一部分先执行，再销毁视图的fragment去销毁视图，再生成视图的fragment显示。其实这就是上面的规则3。</strong>  </p><h3 id="当使用懒加载的时候呢？"><a href="#当使用懒加载的时候呢？" class="headerlink" title="当使用懒加载的时候呢？"></a>当使用懒加载的时候呢？</h3><p><strong>很明显生命周期会是一样的，因为设置懒加载的操作，并没有影响生命周期，所以生命周期是一样的，只是懒加载保证了显示哪页加载哪页的数据，有兴趣的朋友可以自己测试一下，毕竟纸上得来终觉浅，绝知此事要躬行。</strong></p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-传递参数的单例模式</title>
    <link href="http://sakurajiang.github.io/2016/09/27/RestAPP-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://sakurajiang.github.io/2016/09/27/RestAPP-传递参数的单例模式/</id>
    <published>2016-09-26T16:00:00.000Z</published>
    <updated>2020-07-06T09:33:11.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么懒汉式还存在"><a href="#为什么懒汉式还存在" class="headerlink" title="为什么懒汉式还存在"></a>为什么懒汉式还存在</h3><p>单例模式我们在项目中会经常使用到，有常见的懒汉式、饿汉式,很多人搞不懂饿汉式既然既是线程安全的又是不需要线程同步，为什么还会存在懒汉式呢？存在即是合理，就论需要在构造函数中传递参数而言(当然这里的参数是不变的，如果参数是可变的，那么每次创建的对象都不一样，那么之前创建的对象都没用，违背了单例模式的设计初衷)，懒汉式做的就比饿汉式好。首先，我们以懒汉式为例，代码如下:<br>   父类：</p><pre><code>public class Father {public Father(String s,int i){    System.out.println(&quot;s=&quot;+s);    System.out.println(&quot;i=&quot;+i);}}</code></pre><p>   主函数:</p><pre><code> public  class Main {public static void main(String[] args) {    // TODO Auto-generated method stub        testSon();        testSonB();       testSonC();}public  static void testSon(){    Son son=Son.getSonInstance(&quot;a&quot;, 1);}public static void testSonB(){    SonB sonb=SonB.getInstance(&quot;z&quot;, 2);}public static void testSonC(){    SonC sonc=SonC.getInstance(&quot;q&quot;, 3);}}</code></pre><p>  使用懒汉式的子类:    </p><pre><code>public class Son extends Father{private static Son son;private Son(String s, int i) {    super(s, i);    // TODO Auto-generated constructor stub}public static Son getSonInstance(String s,int i){    if(son==null){        synchronized (Son.class) {            son=new Son(s,i);        }    }        return son;} }</code></pre><p>  使用静态内部类方式的子类：</p><pre><code>public class SonB extends Father{private static String s;private static int i;private SonB() {    super(s, i);    // TODO Auto-generated constructor stub}private static class LoadSonB {    private static final SonB SONB_INTANCE=new SonB();}public static SonB getInstance(String s1,int i1){    s=s1;    i=i1;    return LoadSonB.SONB_INTANCE;}}</code></pre><p>   使用饿汉式方式的子类:</p><pre><code>public class SonC extends Father{private static String s;private static int i;public SonC() {    super(s, i);    // TODO Auto-generated constructor stub}private static SonC sonc=new SonC();public static SonC getInstance(String s1,int i1){    s=s1;    i=i1;    return sonc;}}</code></pre><p>  输出结果:<br>      s=a<br>     i=1<br>       s=z<br>     i=2<br>     s=null<br>      i=0<br>从上面的结果可以看出，懒汉式和静态内部类的方式都可以在构造函数中像父构造函数传递值，而饿汉式不行，为什么？因为静态内部类在类加载的时候不会加载，静态内部类和非静态内部类一样，都是在被调用时才会被加载，而静态变量、静态方法、静态块都是在类加载的时候就已经”准备好了”,也就是可以被使用或者已经被执行，所以使用静态内部类方式的时候可以，因为，类加载的时候静态内部类还没加载，所以构造函数还没运行，当静态内部类被调用时，参数已经被赋值了，所以可以。而使用饿汉式，由于sonc属于static变量，而且在声明的时候new了，那时参数还没有赋值时，构造函数已经被调用了，所以不行。如果不能理解这里，可以看<a href="http://www.cnblogs.com/zhguang/p/3154584.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhguang/p/3154584.html</a>。</p><p>那么如果使用饿汉式怎么办呢？<br>答案是办不到，因为饿汉式需要在类加载的时候就生成对象，那个时候无法传递参数。当然，如果传递参数不是发生在构造函数中，那么就可以使用饿汉式，代码如下:</p><pre><code> public class SonD {private static  String s;private static int i;public SonD() {    // TODO Auto-generated constructor stub    String s2=s;    System.out.println(&quot;s2&quot;+s2);}private static SonD sond=new SonD();public static SonD getInstance(String s1,int i1){    s=s1;    i=i1;    System.out.println(&quot;s1=&quot;+s);    System.out.println(&quot;i1=&quot;+i);    System.out.println(&quot;get&quot;);    return sond;}}</code></pre><p>  主函数:    </p><pre><code>  public  class Main {public static void main(String[] args) {    // TODO Auto-generated method stub    testSonD();} public static void testSonD(){    SonD sond=SonD.getInstance(&quot;m&quot;, 4);}}</code></pre><p>  运行结果:<br>    s2null<br>    s1=m<br>    i1=4<br>    get  </p><p>为什么这里s2=null呢？因为s是static，而且在声明的时候直接new了，所以值是null，因此，我们使用饿汉式的时候传递值是不能在构造函数中进行的，而要在别的地方，比如类SonD中的getInstance()方法中就行，这样就实现了使用饿汉式传递参数，不过注意这里的传递参数不是发生在构造函数中的，如果是构造函数需要传入参数，就要使用懒汉式，而且，使用饿汉式传递参数，不能在构造函数中传递(类SonD的输出结果证实这一点)，现在是不是有些理解懒汉式为什么存在呢？其实，综上所述，使用单例模式的时候，最好使用内部类的方式来实现。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货</title>
    <link href="http://sakurajiang.github.io/2016/09/22/RestAPP-%E4%B8%80%E6%AC%BEMVVM%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84Gank.io%E5%AE%A2%E6%88%B7%E7%AB%AF%E2%80%94%E2%80%94%E5%B0%8F%E6%86%A9%E5%B9%B2%E8%B4%A7/"/>
    <id>http://sakurajiang.github.io/2016/09/22/RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货/</id>
    <published>2016-09-21T16:00:00.000Z</published>
    <updated>2020-07-06T09:32:56.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先给客官来几张项目部分截屏"><a href="#先给客官来几张项目部分截屏" class="headerlink" title="先给客官来几张项目部分截屏"></a>先给客官来几张项目部分截屏</h3><h4 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-22-16-18-10-310_com.example.jdk.restapp.png" alt="主页面">   </p><h4 id="搜索页面"><a href="#搜索页面" class="headerlink" title="搜索页面"></a>搜索页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-22-16-44-10-168_com.example.jdk.restapp.png" alt="搜索页面">   </p><h4 id="搜索结果页面"><a href="#搜索结果页面" class="headerlink" title="搜索结果页面"></a>搜索结果页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-22-16-43-27-729_com.example.jdk.restapp.png" alt="搜索结果页面">   </p><h4 id="大图页面"><a href="#大图页面" class="headerlink" title="大图页面"></a>大图页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-22-16-19-26-208_com.example.jdk.restapp.png" alt="大图页面">  </p><h3 id="为什么写这个客户端？"><a href="#为什么写这个客户端？" class="headerlink" title="为什么写这个客户端？"></a>为什么写这个客户端？</h3><p>   我学习android也有一年多了，都说项目才是检验自己学习成果的最好方式，正好最近学习Material Design, RxJava &amp; Retrofit框架和MVVM设计架构也有一段时间了，正好，网络上有gank.io这个免费接口，虽然已经有不少人写过这个客户端，但是没有一个是用MVVM设计架构的，于是我便写了这个项目。这个项目是我的第一个上线项目，可以<strong>查看图片，视频，技术文章等，支持收藏，搜索等</strong>，界面是仿网易云音乐，用户可以选择观看模式和摇一摇模式，界面简洁大方，操作简单易懂。到现在，这是第一个也是唯一一个使用MVVM设计架构的Gank.io客户端，想想还是挺有成就感的。</p><h3 id="这个项目用了什么？"><a href="#这个项目用了什么？" class="headerlink" title="这个项目用了什么？"></a>这个项目用了什么？</h3><p>   项目使用了Material Design, RxJava &amp; Retrofit框架和MVVM设计模式，图标是使用svg和icon.用的都是最新的东西。图片的加载是用picasso,显示是使用RecyclerView，控件用的几乎都是Material Design，并且遵从Material Design规格要求，使得整个界面看起来很有Material Design风格，页面架构采用的是少activity多fragment，减少资源的消耗和更快的响应页面间切换和交互，使得用户体验更好。</p><h3 id="为什么用这些？"><a href="#为什么用这些？" class="headerlink" title="为什么用这些？"></a>为什么用这些？</h3><p>   关于这个问题，我先回答我特别喜欢RxJava和MVVM，先说RxJava，这个其实主要是为了解决异步问题，特别是对handler厌烦的人而言，RxJava的出现实在是太及时了，RxJava不算一种框架，它不能拿来就使用，但是它特别好，因为它所实现的大概就是，你输入一个东西，然后输出你想要的东西，这么说可能很宽泛，举个例子，比如在这个项目中，你的输入是通过Retrofit得到的数据，而这个数据是一个类，但是你只想要其中的url，怎么办？RxJava就可以，你只需要使用map操作符就可以(当然在这个项目中我没有这么写，因为我不只是想得到url)，而使用Retrofit就是因为它对RxJava进行了很好的支持，当然，它本身也很方便。然后就是MVVM了，这个框架也出现一阵子了，对于使用这个框架，就不得不介绍<code>Data Binding Library</code>这个库了，这个库和mvvm一起使用，简直爽的不行，<code>Data Binding Library</code>这个库能让你在xml中进行数据绑定，在没有使用这个库之前，每次我们写xml都只是为了加载一个布局，除了这个功能，xml几乎没有别的作用，这样就让代码变得复杂、繁琐。那么如何使用这个库呢？我的建议是去<a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="noopener">官网</a>，当然至于如何翻墙，我就不说了，毕竟僧多肉少(#阴险)，如果不会翻墙或者不想看英文的同学，这里我推荐去看<a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="noopener">简书</a>。 而对于为什么<code>Material Design</code>，只能说，谁用谁知道，毕竟是官方的东西。</p><h3 id="你能从这个项目中学到什么？"><a href="#你能从这个项目中学到什么？" class="headerlink" title="你能从这个项目中学到什么？"></a>你能从这个项目中学到什么？</h3><p>   1.<strong>RxJava和Retrofit结合进行网络请求</strong>，以及如何将请求<strong>和ProgressDialog结合，</strong>也就是展示网络请求的过程。   </p><p>   2.如何更好的在项目中使用<strong>Data Binding Library这个库来实现MVVM</strong>设计架构。  </p><p>   3.如何实现<strong>少Activity多Fragment页面架构</strong>，以及如何在一个Fragment中更好的嵌套另一个Fragment。 </p><p>   4.在<code>Viewpager</code>下更好的使用<code>Fragment</code>，以及多重ViewPager嵌套下，各个Fragment的处理方式，几乎<strong>涵盖了Fragment的各种使用方式以及和activity交互方式</strong>，比如，优雅的控制让Fragment自己决定处理返回事件还是让<code>activit</code>y来处理。 </p><p>   5.<strong>一些简单的自定义View</strong>，比如自定义Edittext实现带有清除效果的搜索框。</p><p>   6.<strong>Material Design库中绝大部分控件的使用</strong>，遵从Material Design规格要求，使得整个界面看起来很有Material Design风格。   </p><p>   7.如何让<strong>RecyclerView和Data Binding Library</strong>更好的结合。 </p><p>   8.如何更好的封装程序以及继承，让业务层和逻辑层更好的分离。</p><p>   9.这个项目用的都是最新最火的框架和设计模式，所以你以后肯定会用到，而且在很长的时间里都不会有”过期”这一说(当然，知识是没有过期这一说法的，原谅我语文不好)。</p><p>   10.我现在大四，也就意味着我有很多自由的时间，如果你在看我项目的时候遇到任何问题都可以和我联系，我会尽快给你回复，而且由于我技术比较菜(#谦虚)，所以没有专家盲点(指对一个事务知道的越多，就越发不记得”不知道这个事”的情形)，也就能更好的回答你们的问题(第一次将自己技术菜说的这么清新脱俗#害羞)。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址:"></a>地址:</h3><p>   Github：<a href="https://github.com/sakurajiang/RestAPP" target="_blank" rel="noopener">https://github.com/sakurajiang/RestAPP</a>   </p><p>   应用宝 :<a href="http://sj.qq.com/myapp/detail.htm?apkName=com.example.jdk.restapp" target="_blank" rel="noopener">http://sj.qq.com/myapp/detail.htm?apkName=com.example.jdk.restapp</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>   欢迎各位客官多多光临我的Github，喜欢这个项目的同学可以star一下，不胜感激，你的star是对我的肯定和鼓励(#调皮)。<br>   目前我只放在了应用宝上，喜欢的可以下载支持下，不方便在应用宝下载的，在Github上还有直接下载地址。<br>   如果你看到了这里，说明你已经看完这篇博客了，谢谢各位花时间看这篇博客，最后再来几张截屏，<strong>Good luck</strong>！    </p><h4 id="摇一摇页面"><a href="#摇一摇页面" class="headerlink" title="摇一摇页面"></a>摇一摇页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-19-16-52-33-905_com.jdk.gank.restapp%20-%20%E5%89%AF%E6%9C%AC.png" alt="摇一摇页面">  </p><h4 id="抽屉页面"><a href="#抽屉页面" class="headerlink" title="抽屉页面"></a>抽屉页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-19-16-46-20-464_com.jdk.gank.restapp%20-%20%E5%89%AF%E6%9C%AC.png" alt="抽屉页面">  </p><h4 id="关于作者页面"><a href="#关于作者页面" class="headerlink" title="关于作者页面"></a>关于作者页面</h4><p>   <img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/Screenshot_2016-09-22-16-27-38-611_com.example.jdk.restapp.png" alt="关于作者页面"></p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-如何制作app图标以及logo</title>
    <link href="http://sakurajiang.github.io/2016/09/19/RestAPP-%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9Capp%E5%9B%BE%E6%A0%87%E4%BB%A5%E5%8F%8Alogo/"/>
    <id>http://sakurajiang.github.io/2016/09/19/RestAPP-如何制作app图标以及logo/</id>
    <published>2016-09-18T16:00:00.000Z</published>
    <updated>2020-07-06T09:33:53.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步：制作一个图标"><a href="#第一步：制作一个图标" class="headerlink" title="第一步：制作一个图标"></a>第一步：制作一个图标</h3><p>  怎么制作呢？这里给大家推荐一个网站<a href="http://www.logoko.com.cn/" target="_blank" rel="noopener">http://www.logoko.com.cn/</a>，在这里你可以简单的制作一个图标，操作简单，一看就会。这里以我生成的一个图片为例:<br><img src="http://oaz1z7cqt.bkt.clouddn.com/制作logoA-2016919.png" alt="制作logoA-2016919"></p><p> 这里生成的图片在最下面会有广告，我们需要自己再截图一次，毕竟是免费的，可以理解。</p><h3 id="第二步：将图标变成圆角"><a href="#第二步：将图标变成圆角" class="headerlink" title="第二步：将图标变成圆角"></a>第二步：将图标变成圆角</h3><p>  为什么要变成圆角？因为现在主流的app都是圆角图标，这里依然给大家推荐一个网站<a href="http://www.roundpic.com/" target="_blank" rel="noopener">http://www.roundpic.com/</a>，在这里只需要将图片上传到这个网站，就可以制作出圆角图片，操作简单，一看就会。<br>这里依然以我生成的图片为例:<br> <img src="http://oaz1z7cqt.bkt.clouddn.com/制作logoB-2016919.png" alt="制作logoB-2016919"></p><h3 id="第三步：生成各个分辨率的图标"><a href="#第三步：生成各个分辨率的图标" class="headerlink" title="第三步：生成各个分辨率的图标"></a>第三步：生成各个分辨率的图标</h3><p>  这里依然是一个网站<a href="http://icon.wuruihong.com/" target="_blank" rel="noopener">http://icon.wuruihong.com/</a>，将图片上传到这个网站就可以了，这里已android为例，如果不自定义尺寸，就会生成七个不同分辨率的图片，这七个就是android需要的，同时还支持预览。这里最后会是一个压缩包。</p><h3 id="显示在手机上最后的样子"><a href="#显示在手机上最后的样子" class="headerlink" title="显示在手机上最后的样子:"></a>显示在手机上最后的样子:</h3><p><img src="http://oaz1z7cqt.bkt.clouddn.com/制作logoC-2016919.png" alt="制作logoC-2016919"></p><p>是不是感觉特别简单，这三个网站都不用注册哟，赶快尝试一下吧！</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框</title>
    <link href="http://sakurajiang.github.io/2016/09/17/RestAPP-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89EditText%E6%9D%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%B8%A6%E6%9C%89%E6%B8%85%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A1%86/"/>
    <id>http://sakurajiang.github.io/2016/09/17/RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框/</id>
    <published>2016-09-16T16:00:00.000Z</published>
    <updated>2020-07-06T09:34:08.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果:"></a>运行效果:</h3><p>   <img src="http://oaz1z7cqt.bkt.clouddn.com/自定义EditText-2016917.png" alt="自定义EditText-2016917"><br>   <img src="http://oaz1z7cqt.bkt.clouddn.com/自定义EditText1-2016917.png" alt="自定义EditText1-2016917"><br>   <img src="http://oaz1z7cqt.bkt.clouddn.com/自定义EditText2-2016917.png" alt="自定义EditText2-2016917"></p><h3 id="先上代码，等会讲解"><a href="#先上代码，等会讲解" class="headerlink" title="先上代码，等会讲解:"></a>先上代码，等会讲解:</h3><p>  自定义的EditTexT类如下:</p><pre><code>public class CustomClearAndSearechEdittext extends EditText implements View.OnFocusChangeListener,TextWatcher{private Drawable mClearDrawable;/** * 控件是否有焦点 */private boolean hasFoucs;public OnClickSearchListener mOnClickSearchListener;public interface OnClickSearchListener{    public void onClickSearch();}public void setOnClickSearchListener(OnClickSearchListener onClickSearchListener){    this.mOnClickSearchListener=onClickSearchListener;}public CustomClearAndSearechEdittext(Context context) {    this(context, null);}public CustomClearAndSearechEdittext(Context context, AttributeSet attrs) {    super(context, attrs);    init(context);}public CustomClearAndSearechEdittext(Context context, AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);    init(context);}private void init(final Context context) {    //获取EditText的DrawableRight,假如没有设置我们就使用默认的图片    final Drawable drawable = ContextCompat.getDrawable(context, R.drawable.abc_ic_clear_mtrl_alpha);    setTextColor(getCurrentHintTextColor());    mClearDrawable=drawable;    mClearDrawable.setBounds(0, 0, mClearDrawable.getIntrinsicWidth()+10, mClearDrawable.getIntrinsicHeight()+10);    //默认设置隐藏图标    setClearIconVisible(false);    //设置焦点改变的监听    setOnFocusChangeListener(this);    //设置输入框里面内容发生改变的监听    addTextChangedListener(this);}/** * 当手指抬起的位置在clean的图标的区域 * 我们将此视为进行清除操作 * getWidth():得到控件的宽度 * event.getX():抬起时的坐标(该坐标是相对于控件本身而言的)，可以理解成距离左边框的距离 * getTotalPaddingRight():clean的图标左边缘至控件右边缘的距离 * getPaddingRight():clean的图标右边缘至控件右边缘的距离 * 于是: * getWidth() - getTotalPaddingRight()表示: * 控件左边到clean的图标左边缘的区域 * getWidth() - getPaddingRight()表示: * 控件左边到clean的图标右边缘的区域 * 所以这两者之间的区域刚好是clean的图标的区域 */@Overridepublic boolean onTouchEvent(MotionEvent event) {    if (event.getAction() == MotionEvent.ACTION_UP) {        if (getCompoundDrawables()[2] != null) {            boolean searchable=event.getX()&gt;((getWidth()-getPaddingRight()+80));            boolean touchable = event.getX() &gt; (getWidth() - getTotalPaddingRight())                    &amp;&amp; (event.getX() &lt; ((getWidth() - getPaddingRight())));            if (touchable) {                this.setText(&quot;&quot;);            }            if(searchable&amp;&amp;mOnClickSearchListener!=null){                Toast.makeText(getContext(),&quot;search&quot;,Toast.LENGTH_SHORT).show();                mOnClickSearchListener.onClickSearch();            }        }    }    return super.onTouchEvent(event);}/** * 当ClearEditText焦点发生变化的时候，判断里面字符串长度设置清除图标的显示与隐藏 */@Overridepublic void onFocusChange(View v, boolean hasFocus) {    this.hasFoucs = hasFocus;    if (hasFocus) {        setClearIconVisible(getText().length() &gt; 0);    } else {        setClearIconVisible(false);    }}/** * 设置清除图标的显示与隐藏，调用setCompoundDrawables为EditText绘制上去 * @param visible */protected void setClearIconVisible(boolean visible) {    Drawable right = visible ? mClearDrawable : null;    setCompoundDrawables(getCompoundDrawables()[0],            getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]);}/** * 当输入框里面内容发生变化的时候回调的方法 */@Overridepublic void onTextChanged(CharSequence s, int start, int count,                          int after) {    if(hasFoucs){        setClearIconVisible(s.length() &gt; 0);    }}@Overridepublic void beforeTextChanged(CharSequence s, int start, int count,                              int after) {}@Overridepublic void afterTextChanged(Editable s) {}}</code></pre><p> XML文件如下:</p><pre><code>  &lt;android.support.v7.widget.Toolbar    android:id=&quot;@+id/tool_bar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;?actionBarSize&quot;    android:background=&quot;@color/themeColor&quot;    app:contentInsetStart=&quot;0.0dp&quot;    app:layout_scrollFlags=&quot;enterAlways|scroll&quot;    app:theme=&quot;@style/ToolbarStyle&quot;&gt;        &lt;LinearLayout            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;&gt;            &lt;android.support.design.widget.TextInputLayout                android:id=&quot;@+id/search_til&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;match_parent&quot; &gt;                &lt;com.jdk.gank.restapp.CustomizedWidget.CustomClearAndSearechEdittext                    android:id=&quot;@+id/search_et&quot;                    android:hint=&quot;输入搜索内容&quot;                    android:inputType=&quot;text&quot;                    android:singleLine=&quot;true&quot;                    android:imeOptions=&quot;actionSearch&quot;                    android:paddingRight=&quot;70dp&quot;                    android:layout_width=&quot;match_parent&quot;                    android:layout_height=&quot;match_parent&quot; /&gt;            &lt;/android.support.design.widget.TextInputLayout&gt;            &lt;ImageView                android:id=&quot;@+id/search_iv&quot;                android:layout_width=&quot;30dp&quot;                android:layout_height=&quot;match_parent&quot;                android:src=&quot;@mipmap/search&quot;                android:gravity=&quot;center_vertical&quot;                android:textSize=&quot;25dp&quot;/&gt;        &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.Toolbar&gt;</code></pre><p>在fragment中使用:</p><pre><code> public class WatchAndShakeFragment extends Fragment implements CustomClearAndSearechEdittext.OnClickSearchListener{@Bind(R.id.search_tv)ImageView search_iv;@Bind(R.id.search_til)TextInputLayout textInputLayout;@Bind(R.id.search_et)EditText editText;public static WatchAndShakeFragment newInstance(){    if( watchAndShakeFragment ==null){        watchAndShakeFragment =new WatchAndShakeFragment();    }    return watchAndShakeFragment;}public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {    if(v!=null){        ButterKnife.bind(this,v);        return v;    }     v=inflater.inflate(R.layout.fragment_watch_shake,container,false);    ButterKnife.bind(this, v);    ((AppCompatActivity)getActivity()).setSupportActionBar(toolbar);    actionBar= ((AppCompatActivity)getActivity()).getSupportActionBar();  editText.setFocusable(true);            editText.setFocusableInTouchMode(true);            ((CustomClearAndSearechEdittext)editText).setOnClickSearchListener(this);            toolbar.setNavigationIcon(R.drawable.ic_back_28dp);              toolbar.setNavigationOnClickListener(new View.OnClickListener() {                  @Override                  public void onClick(View v) {                      actionBar.setDisplayHomeAsUpEnabled(false);                      toolbar.setNavigationIcon(null);                      editText.setFocusable(false);                      editText.setFocusableInTouchMode(false);                  }              });    return v;}}}</code></pre><h3 id="下面是讲解"><a href="#下面是讲解" class="headerlink" title="下面是讲解:"></a>下面是讲解:</h3><p> 其实主要讲的就是CustomClearAndSearechEdittext类，在这个类中完成所有的功能，继承一个EditText，然后在EditText中设置图片，首先我们得到图片，然后我们调用<code>mClearDrawable.setBounds(0, 0, mClearDrawable.getIntrinsicWidth()+10, mClearDrawable.getIntrinsicHeight()+10);</code>这个方法来提供画图片的画布，这个意思就是说，这个图片后面是画在这个地方的，值得注意是我们可以在这里设置图片的大小，但是不能设置图片的位置，比如，我这里就是在图片原来的基础上增加了10，之前我也一直想着在这里设置位置，但是行不通，然后我想着通过onDraw()重新将图片画上去，但是太麻烦，那么我们如何设置图片的位置呢？很简单，就是在xml里，因为我们的清除图片是在右侧，所以，我们设置<code>android:paddingRight=&quot;70dp&quot;</code>来控制图片的位置，因为这个图片我们是通过</p><pre><code> protected void setClearIconVisible(boolean visible) {    Drawable right = visible ? mClearDrawable : null;    setCompoundDrawables(getCompoundDrawables()[0],            getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]);}</code></pre><p>  来显示的，主要就是 <code>setCompoundDrawables(getCompoundDrawables()[0],                getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]);</code><br>也就是说，我们是将右边的图片画上去了，别的地方都没有图片，也就是说，这个图片其实是EditText中的，所以我们可以通过<code>android:paddingRight=&quot;70dp&quot;</code>来控制图片的位置，这里清除图片设置好了，接下来，就是设置事件了，我们重写<code>onTouchEvent(MotionEvent event)</code>方法来设置事件，<br>在上面的代码的注释中已经写的很详细了，我就不写了，接下来就是设置搜索的事件了，由于搜索的按钮是在EditText中(由我们的布局知道)，所以我们也需要通过重写<code>onTouchEvent(MotionEvent event)</code>方法来设置事件，也就是当我们按下的坐标大于搜索框到屏幕左边的距离时，就会触发onTouch事件，然后我设置了回调来处理这个事件。整个过程也解析完了，其实挺简单。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-RestAPP开发总结</title>
    <link href="http://sakurajiang.github.io/2016/08/23/RestAPP-RestAPP%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>http://sakurajiang.github.io/2016/08/23/RestAPP-RestAPP开发总结/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2020-07-06T09:32:00.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么做这个APP"><a href="#为什么做这个APP" class="headerlink" title="为什么做这个APP"></a>为什么做这个APP</h3><p>终于做完这个APP了，大概花了我20天，这个APP的功能的确很简单，我也不知道为什么会花这么久，之所以想着做这个APP，是因为我想将这三个<code>RxJava</code>、<code>Retrofit</code>和<code>MVVM</code>模式放在一起使用。  </p><h3 id="为什么使用这三者"><a href="#为什么使用这三者" class="headerlink" title="为什么使用这三者"></a>为什么使用这三者</h3><p>关于这个问题，我先回答我特别喜欢RxJava和MVVM，先说RxJava，这个其实主要是为了解决异步问题，特别是对handler厌烦的人而言，RxJava的出现实在是太及时了，RxJava不算一种框架，它不能拿来就使用，但是它特别好，因为它所实现的大概就是，你输入一个东西，然后输出你想要的东西，这么说可能很宽泛，举个例子，比如在这个项目中，你的输入是通过Retrofit得到的数据，而这个数据是一个类，但是你只想要其中的url，怎么办？RxJava就可以，你只需要使用map操作符就可以(当然在这个项目中我没有这么写，因为我不只是想得到url)，而使用Retrofit就是因为它对RxJava进行了很好的支持，当然，它本身也很方便。然后就是MVVM了，这个框架也出现一阵子了，对于使用这个框架，就不得不介绍<code>Data Binding Library</code>这个库了，这个库和mvvm一起使用，简直爽的不行，<code>Data Binding Library</code>这个库能让你在xml中进行数据绑定，在没有使用这个库之前，每次我们写xml都只是为了加载一个布局，除了这个功能，xml几乎没有别的作用，这样就让代码变得复杂、繁琐。那么如何使用这个库呢？我的建议是去<a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="noopener">官网</a>，当然至于如何翻墙，我就不说了，毕竟僧多肉少(#阴险)，如果不会翻墙或者不想看英文的同学，这里我推荐去看<a href="http://www.jianshu.com/p/b1df61a4df77" target="_blank" rel="noopener">简书</a>。  </p><h3 id="从这个APP能学到什么"><a href="#从这个APP能学到什么" class="headerlink" title="从这个APP能学到什么"></a>从这个APP能学到什么</h3><p>关于这个，我只能说我也是刚接触这三者没多久，由于专家效应，所以我觉得我写可能更适合初学者去看看，看一下刚接触这个应该怎么写，然后自己再试着改进，而不是直接去看别人写好的，毕竟，纸上得来终觉浅，觉知此事要躬行，这样就能学到更多的东西。其实大家主要就是要看<code>RecyclerViewDataBindingAdapter</code>这个Adapter和那几个<code>Fragment</code>，以及对应的<code>xml</code>文件，特别是<code>RecyclerViewDataBindingAdapter</code>。</p><h3 id="做完这款APP的反思"><a href="#做完这款APP的反思" class="headerlink" title="做完这款APP的反思"></a>做完这款APP的反思</h3><p>关于这个问题，首先从布局上来考虑，由于我一开始不知道自己想做曾什么样子，只知道大概什么样子，然后想着边做边改，但是写着写着，我就后悔了，因为到最后发现有很多界面的布局类似，而我没有将这些布局整合成一个，而是写了好几个，而改的话又要重新制定，因为对于mvvm模式，使用<code>include</code>标签会比较困难，因为是将数据绑定直接绑定在xml中，而要使用<code>include</code>标签就会比较困难了。所以在做一个APP之前应该先想好这个APP具体该做成什么样子，而不能边做边看，想着能将一些好看的view加进去。然后就是对于使用mvvm的反思，由于这个APP有显示网络图片的功能，而一开始我看mvvm没有看那么仔细，结果导致我不知道如何使用<code>Data Binding Library</code>达到通过一个url给image设置图片，然后我就新建了一个Adapter，然后写完之后，我又看着很不爽，我就想着能把这两个整合到一起，于是我又回去重新看一遍<code>Data Binding Library</code>，结果发现自定义一个<code>setter</code>可以达到这个效果，于是我就将两者整合到一起，顺便将这个<code>Adapter</code>封装成自己的一个小框架，以后使用<code>RecyclerView</code>和<code>Data Binding Library</code>可以直接拿这个<code>Adapter</code>了(窃喜)，所以，我们应该在做一个项目前，将项目所需要的主要的技术都认真看一遍，而不能想着边做项目边学，因为如果这样，由于你的项目不单单是使用一个技术，所以在使用的时候，可能会因为整个项目太大，而不适合去在这个项目中练习如何使用这个框架，如果你重新建一个项目专门去练习使用这个框架(假设你那时还有另开一个专门练习这个框架的项目的心情，因为那时你往往只会想着去解决这个问题，而不会另开一个项目，而由于你是在一个项目中使用这个框架，而你对这个框架又不熟悉，那么你碰到的问题，可能就不只是单单这个框架的问题，还有可能跟框架结合这个项目有关系，那时候你可能在网上找不到答案)，由于你还做着这个项目，你就不会有那份认真的去练习这个框架，那样需要的时间可能就会很久，而且，你对这些框架不熟悉，当你整合到一起的时候，可能会出现各种bug，而那个时候你往往没有那份认真调试的心情，因为你对这些都不熟悉，然后就会比较虚，不知道如何下手。最后一个反思就是，一定要学会科学的、理性的进行调试，遇到问题<a href="http://www.google.cn/" target="_blank" rel="noopener">google</a>以及<a href="http://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-webview和其他控件混合使用</title>
    <link href="http://sakurajiang.github.io/2016/08/23/RestAPP-webview%E5%92%8C%E5%85%B6%E4%BB%96%E6%8E%A7%E4%BB%B6%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://sakurajiang.github.io/2016/08/23/RestAPP-webview和其他控件混合使用/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2020-07-06T09:32:30.656Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用webview的时候，我们会经常的和其他控件一起使用，那么如何让webview适应布局呢？<br>直接上代码:</p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;LinearLayout    android:id=&quot;@+id/webview_linearlayout&quot;    android:orientation=&quot;vertical&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_weight=&quot;11&quot;    android:layout_height=&quot;0dp&quot;&gt;    &lt;WebView        android:id=&quot;@+id/show_webview_wv&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;&lt;/WebView&gt;&lt;/LinearLayout&gt;&lt;RelativeLayout    android:layout_weight=&quot;1&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;0dp&quot;&gt;    &lt;TextView        android:id=&quot;@+id/count_tv&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;ImageButton        android:id=&quot;@+id/interest_ib&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_toRightOf=&quot;@id/count_tv&quot;/&gt;&lt;/RelativeLayout&gt;&lt;/LinearLayout&gt;</code></pre><p>这就是布局文件，至于剩下的我就不需要再写了，主要就是布局，这里再提一下一个大坑，如果你将webview的高度<code>android:layout_height=&quot;wrap_content&quot;</code>换成 <code>android:layout_height=&quot;match_parent&quot;</code>你会发现下面的控件在最开始的时候有抖动的现象，这就很影响体验了，我之前也是出了这个毛病，果断不能忍，于是去看代码，查看是哪里重新刷新了布局，结果一直调试，花了好久，结果就是然并卵，最后我就尝试着将高度变成<code>wrap_content</code>，然后出乎意料就好了，那么到底为什么呢？答案是跟这两个没关系(我也是后来为了整明白这个才发现的)，之所以出现跳动，是因为我之前设置了显示<code>webview</code>的<code>activity</code>是全屏，而启动它的<code>activity</code>不是全屏，跳动是因为由一个非全屏的<code>activity</code>调到一个全屏的<code>activity</code>，而尴尬的是我还没发现好的解决办法，但是，以后如果碰到<code>webview</code>和<code>activity</code>全屏的问题，如果出现抖动，一定要注意。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-使用SQLite遇到的一个问题</title>
    <link href="http://sakurajiang.github.io/2016/08/23/RestAPP-%E4%BD%BF%E7%94%A8SQLite%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://sakurajiang.github.io/2016/08/23/RestAPP-使用SQLite遇到的一个问题/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2020-07-06T09:33:38.962Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道SQLite是不允许插入空行的，但是很多时候我们对于插入的数据是不知道的，其中可能就会有没有值，然后就造成空行，那么我们如何判断呢？很多人说只要我们将得到的数据重新整理一遍就好了，一旦为空就给他赋值，我也是这么想的，结果悲剧了，下面直接出代码:</p><pre><code>public URLTableData setUrlTableData(URLTableData urlTableData){    if(urlTableData.getUrl().length()&lt;=0){        urlTableData.setUrl(&quot;该链接不存在&quot;);    }    if(urlTableData.getWho().equals(null)){        urlTableData.setWho(&quot;佚名&quot;);    }    if(urlTableData.getDesc().equals(null)){        urlTableData.setDesc(&quot;不存在&quot;);    }    if(urlTableData.getCreatedAt().toString().length()&lt;=0){        urlTableData.setCreatedAt(null);    }    return urlTableData;}public ContentValues CreatParms(URLTableData urlTableData) {   setUrlTableData(urlTableData);    ContentValues _ContentValues = new ContentValues();    _ContentValues.put(&quot;URLValue&quot;,urlTableData.getUrl());    _ContentValues.put(&quot;URLCreateAt&quot;,ChangeTimeFormat.changeToYearMonthDay(urlTableData.getCreatedAt()));    _ContentValues.put(&quot;URLWho&quot;,urlTableData.getWho());    _ContentValues.put(&quot;URLDesc&quot;,urlTableData.getDesc());    return _ContentValues;}public Boolean insertToURLTable(URLTableData urlTableData) {    ContentValues _ContentValues = CreatParms(urlTableData);    Long p_NewID = getMySqLiteDatabase().insert(getTable(), null, _ContentValues);    urlTableData.set_id(p_NewID.intValue());    return p_NewID &gt; 0;}</code></pre><p>这里的三个函数我解释一下大概什么意思，第一个是给得到的数据重新赋值，第二个是设置ContentValues，第三个是执行插入。但是每次数据插入都不成功，然后我进行调试，发现每次都是运行到</p><pre><code>if(urlTableData.getWho().equals(null)){        urlTableData.setWho(&quot;佚名&quot;);    }</code></pre><p>这条语句就出现异常(我捕获了异常)，其中我的<code>urlTableData.getWho()</code>得到的<code>who</code>是空的，然后再调用<code>equal()</code>方法就出现了异常，那么我们应该怎么判断呢？既然知道了原因，那么其实就很简单,只要将上面的第一个函数<code>setUrlTableData(URLTableData urlTableData)</code>改成下面这样:</p><pre><code>public URLTableData setUrlTableData(URLTableData urlTableData){    if(urlTableData.getUrl()==null){        urlTableData.setUrl(&quot;该链接不存在&quot;);    }    if(urlTableData.getWho()==null){        urlTableData.setWho(&quot;佚名&quot;);    }    if(urlTableData.getDesc()==null){        urlTableData.setDesc(&quot;不存在&quot;);    }    if(urlTableData.getCreatedAt().toString()==null){        urlTableData.setCreatedAt(null);    }    return urlTableData;}</code></pre><p>这样就好了嘛，当然如果是单个数据插入，而不是整个对象插入，就可以通过设置<code>insert(参数)</code>方法来设置，这里就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>RestAPP-使用recyclerView遇到的一些问题</title>
    <link href="http://sakurajiang.github.io/2016/08/23/RestAPP-%E4%BD%BF%E7%94%A8recyclerView%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://sakurajiang.github.io/2016/08/23/RestAPP-使用recyclerView遇到的问题/</id>
    <published>2016-08-22T16:00:00.000Z</published>
    <updated>2020-07-06T09:33:27.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在使用RecyclerView时，突然发现数据无法显示出去"><a href="#在使用RecyclerView时，突然发现数据无法显示出去" class="headerlink" title="在使用RecyclerView时，突然发现数据无法显示出去"></a>在使用RecyclerView时，突然发现数据无法显示出去</h3><p>在使用RecyclerView时，突然发现数据无法显示出去，遇到这种情况可以看看传入的数据是否为空，如果为空，是不会显示任何东西的。因为传入的数据为空，不会调用onCreateViewHolder(参数)方法，自然也不会调用onBindViewHolder(参数)方法，所以你上面就不会有任何的显示，即使你在item的布局中就给了每个控件初始的值，就像下面这样:  </p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;android:background=&quot;#ff0000&quot;&gt;&lt;ImageView    android:id=&quot;@+id/meizi_imageView&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:src=&quot;@mipmap/ic_launcher&quot;    /&gt;&lt;TextView    android:id=&quot;@+id/video_TextView&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:text=&quot;hhh&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>即使这样依然不会显示出来，因为都没有调用onCreateViewHolder(参数)方法来显示item，什么时候调用onCreateViewHolder(参数)方法呢？看下面这句话<code>Called when RecyclerView needs a new RecyclerView.ViewHolder of the given type to represent an item.</code>，也就是说当RecyclerView需要一个新的给定类型的ViewHolder来描绘一个item时才会调用。那么我们想即使传入的数据为空时，也要将自己的item显示出来，那么我们应该怎么办呢？代码如下:   </p><pre><code>    /**      * Created by JDK on 2016/8/4. */public class AdapterRecyclerViewMeizi extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;{private Context mContext;private MyViewHolder myViewHolder;private List&lt;Meizi&gt; meiziList;public AdapterRecyclerViewMeizi(Context context,List&lt;Meizi&gt; meiziList) {    this.mContext=context;    this.meiziList=meiziList;}public LayoutInflater getInflater(){    return LayoutInflater.from(mContext);}@Overridepublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {    if(viewType==-1){        View v=getInflater().inflate(R.layout.meizi_item,parent,false);        return new MyEmptyViewHolder(v);    }    View v=getInflater().inflate(R.layout.meizi_item,parent,false);    myViewHolder=new MyViewHolder(v);    return myViewHolder;}@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {    if(holder instanceof MyViewHolder) {        Log.i(&quot;Logcat&quot;, &quot;onBindViewHolder&quot; + meiziList.get(position).url);        Picasso.with(mContext).load(meiziList.get(position).url).into(((MyViewHolder)holder).meiziImage);    }}@Overridepublic int getItemCount() {    return meiziList.size()&gt;0?meiziList.size():1;}@Overridepublic int getItemViewType(int position) {    if(meiziList.size()&lt;=0){        return -1;    }    return super.getItemViewType(position);}class MyViewHolder extends RecyclerView.ViewHolder {    ImageView meiziImage;    TextView videoText;    public MyViewHolder(View itemView) {        super(itemView);        Log.i(&quot;Logcat&quot;, &quot;MyViewHolder&quot;);        meiziImage= (ImageView) itemView.findViewById(R.id.meizi_imageView);        videoText= (TextView) itemView.findViewById(R.id.video_TextView);    }}class MyEmptyViewHolder extends RecyclerView.ViewHolder{    public MyEmptyViewHolder(View itemView) {        super(itemView);    }} }</code></pre><p>这里解释一下getItemViewType(参数)这个方法，先看原话:<code>Return the view type of the item at position for the purposes of view recycling.</code>，也就是说这个方法返回的是position位置的item的View的类型，这样做的目的是view回收，这个方法默认返回的是0，我们在这里给他复写，当传入的数据为空时，就返回-1，然后再在 onCreateViewHolder(参数)判断，当然我们也可以根据传入的数据为空这个条件来判断，也就是meiziList.size=0来判断；同时注意一下这里的<code>getItemCount(参数)</code>方法，这个方法返回的是item的总数目。如果我们按正常的方式写，也就是<code>return meiziList.size();</code>，那么还是不会显示，所以感觉onCreateViewHolder(参数)是根据<br>getItemCount(参数)方法返回的值来判断的。<br>根据上面的这些代码，我们可以这样来设置自己的RecyclerView，也就是说当传入的数据为零时，我们显示的内容就是:没有传入任何数据，创建布局文件meizi_none_item，代码如下:  </p><pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;TextView    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    android:textColor=&quot;#ff0000&quot;    android:textSize=&quot;30sp&quot;    android:text=&quot;@string/meizi_none_item&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><p>然后将上面的  </p><pre><code>if(viewType==-1){    View v=getInflater().inflate(R.layout.meizi_item,parent,false);    return new MyEmptyViewHolder(v);}</code></pre><p>修改成  </p><pre><code>if(viewType==-1){    View v=getInflater().inflate(R.layout.meizi_none_item,parent,false);    return new MyEmptyViewHolder(v);}</code></pre><p>这样结果如图:<br><img src="https://raw.githubusercontent.com/sakurajiang/Picture/master/RestAPP/A.PNG" alt="Github"></p><h3 id="在mvvm中使用RecyclerView进行数据绑定"><a href="#在mvvm中使用RecyclerView进行数据绑定" class="headerlink" title="在mvvm中使用RecyclerView进行数据绑定"></a>在mvvm中使用RecyclerView进行数据绑定</h3><p>在这里需要提一下，再在对item的布局文件进行数据绑定时，一定要记住对于variable的name命名一定不能有_，要比较正常的生命变量，如果你的声明如下:  </p><pre><code>  &lt;data&gt;    &lt;variable        name=&quot;android_meizi&quot;        type=&quot;com.example.jdk.restapp.ModelData.entity.Meizi&quot;/&gt;&lt;/data&gt;</code></pre><p>这里对name的命名就是<code>android_meizi</code>，这个时候就会报下面的错误:<br><img src="http://oaz1z7cqt.bkt.clouddn.com/B-201687.PNG" alt="B-201687"></p><p>我是按照<a href="http://blog.csdn.net/amosbake/article/details/48543799" target="_blank" rel="noopener">this</a>来实现mvvm中使用RecyclerView，因为这个问题，我整了好久，最后实在没办法，我就尝试着改名字，最后是这样的:  </p><pre><code>&lt;data&gt;    &lt;variable        name=&quot;androidMeizi&quot;        type=&quot;com.example.jdk.restapp.ModelData.entity.Meizi&quot;/&gt;&lt;/data&gt;</code></pre><p>不说了，我哭会去。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="干货" scheme="http://sakurajiang.github.io/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="RestApp" scheme="http://sakurajiang.github.io/tags/RestApp/"/>
    
  </entry>
  
  <entry>
    <title>做AA项目时的一些封装心得以及一些技巧</title>
    <link href="http://sakurajiang.github.io/2016/08/04/AA-%E5%81%9AAA%E9%A1%B9%E7%9B%AE%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%81%E8%A3%85%E5%BF%83%E5%BE%97%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>http://sakurajiang.github.io/2016/08/04/AA-做AA项目时的一些封装心得及一些技巧/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2020-07-06T09:13:06.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如果你想整个应用程序只有一个你创建的某个类的对象时，可以采用如下的技巧"><a href="#如果你想整个应用程序只有一个你创建的某个类的对象时，可以采用如下的技巧" class="headerlink" title="如果你想整个应用程序只有一个你创建的某个类的对象时，可以采用如下的技巧"></a>如果你想整个应用程序只有一个你创建的某个类的对象时，可以采用如下的技巧</h3><p>在你创建的类中，将构造函数的属性设置为私有，然后再定义一个静态方法给外部使用，也就是单例模式，具体代码如下:  </p><pre><code>public class SQliteDataBaseConfig {  private static final String AA_DATABASE_NAME=&quot;my_aa_database_name&quot;;  private static final int AA_DATABASE_VERSION=1;  private static SQliteDataBaseConfig sQliteDataBaseConfig_instance;  private SQliteDataBaseConfig(){  }  public static SQliteDataBaseConfig getsQliteDataBaseConfig_instance(){      if (sQliteDataBaseConfig_instance==null){          sQliteDataBaseConfig_instance=new SQliteDataBaseConfig();      }      return sQliteDataBaseConfig_instance;  }   }   </code></pre><p>这里需要说一下:由于这个类的构造函数是私有的，也就意味着这个类不能被继承。<br>当然这里提的这种形式的单例模式是属于懒汉形式的，但是这样是线程不安全的，那么什么是线程不安全呢？学过操作系统的都知道，一个进程可以包含多个线程，假设你的代码所在的进程有多个线程，那么这多个线程都可以访问这段代码，当它们同时访问这段代码，如果每次运行的结果和单线程运行的结果相同，并且其他的变量的值也和预期的是一样的，那么就是线程安全的。想深入了解单例模式的人推荐看一下这篇博客<a href="http://blog.csdn.net/jason0539/article/details/23297037/" target="_blank" rel="noopener">单例模式</a>，写的真的很好。   </p><h3 id="若你想在某一个类的父类构造函数中，用一个类的对象作为参数，那么这个类的对象要声明为static"><a href="#若你想在某一个类的父类构造函数中，用一个类的对象作为参数，那么这个类的对象要声明为static" class="headerlink" title="若你想在某一个类的父类构造函数中，用一个类的对象作为参数，那么这个类的对象要声明为static"></a>若你想在某一个类的父类构造函数中，用一个类的对象作为参数，那么这个类的对象要声明为static</h3><pre><code> public class MySqliteOpenHelper extends SQLiteOpenHelper{  private  static  SQliteDataBaseConfig sQliteDataBaseConfig;  private MySqliteOpenHelper(Context context){      super(context,sQliteDataBaseConfig.getAADatabaseName(),null,sQliteDataBaseConfig.getAADatabaseVersion());  }  }  </code></pre><p>这也很好理解，因为当这个类构造时，作为参数的类对象可能还没实例化，所以需要将其声明为static。</p>]]></content>
    
    <summary type="html">
    
      这是一篇比较干货的文章
    
    </summary>
    
    
      <category term="Android" scheme="http://sakurajiang.github.io/tags/Android/"/>
    
      <category term="AA" scheme="http://sakurajiang.github.io/tags/AA/"/>
    
  </entry>
  
</feed>
