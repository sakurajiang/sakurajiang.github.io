{"meta":{"title":"sakurajiang的个人博客","subtitle":"心有猛虎&&细嗅蔷薇","description":"心有猛虎&&细嗅蔷薇","author":"sakurajiang","url":"http://sakurajiang.github.io"},"pages":[{"title":"","date":"2020-07-06T08:57:03.658Z","updated":"2016-11-04T09:56:08.000Z","comments":true,"path":"404.html","permalink":"http://sakurajiang.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2020-07-06T12:01:06.723Z","updated":"2018-09-06T03:36:03.000Z","comments":true,"path":"gradle介绍和实战.html","permalink":"http://sakurajiang.github.io/gradle介绍和实战.html","excerpt":"","text":"什么是gradle简单的说gradle是一套构建工具，所谓构建工具就是根据一堆输入信息，生成一系列产物，复杂的说gradle是一套框架，所有的参数配置其实都严格对应相应的API，我们没有必要可以记住这些API，我们需要掌握的是大体流程，然后借助官方SDK+API来完成自己的需求。 为什么会有gradle在Gradle爆红之前，常用的构建工具是ANT，然后又进化到Maven。ANT和Maven这两个工具其实也还算方便，现在还有很多地方在使用。但是二者都有一些缺点，所以让更懒得人觉得不是那么方便。比如，Maven编译规则是用XML来编写的。XML虽然通俗易懂，但是很难在xml中描述if{某条件成立，编译某文件}/else{编译其他文件}这样有不同条件的任务。于是gradle就应运而生，gradle采用的语言是groovy，groovy能让你写java语言像写脚本一样简单，同时gradle是一种DSL语言，即Domain Specific Language，领域相关语言。什么是DSL，说白了它是某个行业中的行话。在gradle的体现有很多，比如sourceSets代表源文件的集合等。 如何使用gradle1.首先我们需要学习一下groovy，值得一提的是groovy语言在编译的时候已经编译为java类字节码，然后运行在JVM虚拟机中，可以理解为它扩展了Java语言，写法十分的奔放，比如定义变量使用def定义，但是这个关键字也不是必需的，语句结尾可以不使用;，单引号严格对应Java中的双引号，双引号则和脚本语言中的双引号类似，当含有$符号时，则它会$表达式先求值，三引号中的字符串支持换行。暂时先了解这些，详细的可以直接看GDK。2.接下来我们就介绍一下gradle的行话，在gradle中，每一个待编译的工程都是一个Project对象，每个Project在编译的时候包含多个Task，比如一个Android项目的编译可能就包含Java源码编译Task、资源编译Task、JNI编译Task、lint检查的Task、打包生成APK的Task、签名Task等等。一个Project包含的Task的数量是由编译脚本执行的插件决定的，插件就是用来定义Task，并且具体执行这些Task的东西。而gradle作为一个框架，主要负责定义流程和规则，具体的编译工作则是通过编译插件来完成，比如编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android LIbrary插件。该中有两个Project，根据gradle设计，每一个Project都对应一个build.gradle对象，而build.gradle就是该Project的编译脚本，如果只有这些，那么你编译的就需要进入到每一个Project中，然后执行编译脚本，这样效率很低，于是gradle提供了Multi-Projects Build，即多个项目一起编译，实现很简单，就是再项目根目录增加一个build.gradle文件，然后再增加一个settings.gradle，前者可以什么都不写，后者就是通过include标签将所有的Project包含进来，如：include &#39;:app&#39;, &#39;:buildsrc&#39;，同时我们还可以在这里添加一些初始化的函数，比如：1234567 def initSomeValue()&#123; Properties properties = new Properties(); File fileProperties = new File(rootDir.getAbsolutePath()+&quot;/local.properties&quot;); properties.load(fileProperties.newDataInputStream()); gradle.ext.myApi = properties.getProperty(&quot;sdk.dir&quot;); println(&quot;init&quot;+gradle.myApi);&#125; 该函数就是将SDK的目录赋值给gradle的额外属性myApi中，下次直接通过gradle.myApi获取该属性。目前我们了解的内容如下：每一个Project都必须设置一个build.gradle文件。对于multi-projects build，需要在根目录下也放一个build.gradle，和一个settings.gradle。一个Project是由若干tasks来组成的，当gradle xxx的时候，实际上是要求gradle执行xxx任务。这个任务就能完成具体的工作。下面说一下gradle的工作流程，简单地说就是先执行settings.gradle，完成初始化过程，然后解析每一个build.gradle，其中的Task会被添加到有向图中，用于解决依赖关系，最后就是执行阶段，执行gradle XXX，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍。接下来介绍几种对象：1.Gradle对象，当执行gradle XXX的时候，gradle会从默认的配置脚本中构造一个Gradle对象，在整个构建过程中只有一个Gradle对象，Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。2.Project对象，每一个build.gradle对象都会生成一个Project对象，在gradle中，Project对象对应的是Build Script，在build.script中，我们一般需要做如下几件事，分别是：应用插件、设置属性等。3.Settings对象，每个settings.gradle都会生成一个Settings对象，注意，对于其他gradle文件，除非定义了class，否则会转换成一个实现了Script接口的对象。这一点和3.5节中Groovy的脚本类相似。讲了这么多，那么一般怎么用呢？对于Java和Groovy而言，我们一般会把公共的方法放在一个类中，然后在别的类中import该类，但是在Gradle中，一般都是通过在build.gradle中定义插件，然后在插件中定义Task来完成，定义Task可以通过task函数来定义，一个Task包含多个Action，所以Task有两个函数，分别是doFirst和doLast，即最先执行和最后执行。普及了基础知识，接下来直接看这个项目吧,代码里差不多都有注释。这里需要再补充的就是自定义gradle插件步骤：1.新建一个module（我一般是选择Android Library） 2.除了main文件夹和build.gradle全部删除，注意main文件夹下的内容也要删除 3.在main下新建groovy文件夹 4.在groovy新建package，名字自己随意取，跟包名类似 5.在package下新建name.groovy文件，name自己取，如下： 12345678910111213package com.sakurajiang.testimport org.gradle.api.Pluginimport org.gradle.api.Projectpublic class MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; def log = project.logger log.error &quot;========================&quot;; log.error &quot;精简的MyPlugin，开始修改Class!&quot;; log.error &quot;========================&quot;; &#125;&#125; 6.在main目录下新建resources文件夹 7.在resources文件夹下新建META-INF文件夹 8.在META-INF文件夹下新建gradle-plugins文件夹 9.在gradle-plugins文件夹下新建name.properties文件，这里的文件名就是引用该插件时用到的名字。其中的内容是implementation-class=com.sakurajiang.test.MyPlugin，后面的值就是步骤5中的文件的包名加类名。 10.在该module的build.gradle文件中配置如下属性 1234567891011121314151617181920apply plugin: &apos;groovy&apos;apply plugin: &apos;maven&apos;dependencies &#123; compile gradleApi() //gradle sdk compile localGroovy() //groovy sdk&#125;repositories &#123; jcenter()&#125;group=&apos;sakurajiang&apos;version=&apos;1.0.0&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&apos;../repo&apos;)) &#125; &#125;&#125; 11.选择AS中右边的gradle，选择自定义的插件，选择upload中的uploadArchives 12.在需要使用该插件的module中的build中添加如下代码：1234567891011buildscript &#123; repositories &#123; maven &#123; url uri(&apos;../repo&apos;) &#125; &#125; dependencies &#123; classpath &apos;sakurajiang:buildsrc:1.0.0&apos; &#125;&#125;apply plugin: &apos;Z&apos; 其中’Z’就是步骤9中的name，其中的classpath就是group：modulename：version。 13.选择Make Project，至此就可以在Build中看到自定义插件中的信息了。自定义插件到此完成。"},{"title":"","date":"2020-07-06T08:57:03.668Z","updated":"2016-08-03T12:32:59.000Z","comments":false,"path":"tags/index.html","permalink":"http://sakurajiang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"客户端使用breakpad收集crash","slug":"client_collect_crash_by_breakpad","date":"2020-06-22T16:00:00.000Z","updated":"2020-07-26T10:20:58.292Z","comments":true,"path":"2020/06/23/client_collect_crash_by_breakpad/","link":"","permalink":"http://sakurajiang.github.io/2020/06/23/client_collect_crash_by_breakpad/","excerpt":"","text":"what主要讲解使用如何在客户端侧使用breakpad收集crash数据，当然还有定制breakpad。填之前collect_crash的坑 how发生crash的时候，linux的流程在linux中，当native发生crash的时候，我们可以通过注册signal来捕获对应的signal，函数原型如下： 12int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 下面说一下参数的意义： signum：表示signal的类别，比如,SIGSEGV、SIGABRT等等，但是不包含SIGKILL 和 SIGSTOP，我们一般捕获的是以下6个：SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS, SIGTRAP sigaction *act：首先介绍一下sigaction是一个结构体，其中比较关键的就是sa_sigaction和sa_flags，\\sa_sigaction作为回调，而如果需要回调起作用，则需要设置sa_flags，通常的做法都是 123struct sigaction action&#123;&#125;;action.sa_sigaction = SignalHandler;action.sa_flags = SA_SIGINFO | SA_ONSTACK; Sigaction *oldact：由于每个信息只允许存在一个处理的函数，因此当我们设置我们的处理函数时会覆盖原来的处理函数，因此需要将原来的处理函数保存下来，然后当我们的函数执行完之后，再处理执行原先的处理函数。 如此设置之后，当有signal出现的时候就会回调到SignalHandler中，而这个的函数原型如下： 1void SignalHandler(int sig, siginfo_t *info, void *ucontext) 下面分别介绍一下参数： sig：表示的是哪个signal，参考上面的signum *info：是一个结构体指针，先介绍一下siginfo_t这个结构体 12__SIGINFO struct &#123; int si_signo; int si_errno; int si_code; union __sifields _sifields; \\&#125; 其中si_signo与sig一致，si_errno的值一般是0，si_code指示为什么这个signal会发送，__sifields一般不关心。 然后我们在SignalHandler中处理*oldact就完成了整个流程。 breakpad流程首先放一张表示流程的自然语言： 12345678910111213141516171819// SignalHandler (uses a global stack of ExceptionHandler objects to find// | one to handle the signal. If the first rejects it, try// | the second etc...)// V// HandleSignal ----------------------------| (clones a new process which// | | shares an address space with// (wait for cloned | the crashed process. This// process) | allows us to ptrace the crashed// | | process)// V V// (set signal handler to ThreadEntry (static function to bounce// SIG_DFL and rethrow, | back into the object)// killing the crashed |// process) V// DoDump (writes minidump)// |// V// sys_exit// 上述的流程就是breakpad处理signal的流程，我们主要看一下DoDump()方法，主要做了如下事情： 读取/proc/$pid/auxv⽂件 读取/proc/$pid/task⽬录，读取进程所有的线程信息 读取/proc/$pid/maps⽂件，获取当前进程加载的所有模块的信息，包含模块名、起始地址、模块size 写minidump文件 如何定制化minidump首先我们需要知道minidump文件的格式，格式的定义是在minidump_format.h中，但是有些结构并没有在代码中直接使用相应的对象，比如MDRawThreadList，按照之前解析class文件的经验，都是直接生成对应结构的对象，但是，由于是C语言可以直接操作地址，因此，可以不通过构建对象的方式来构建这个结构体，那么如何实现呢？不要急，我们先看一下写minidump文件的大致流程： 写header，一般都是这样处理的，不多说 写MDRawDirectory，默认是13个，结构如下： 1234567891011typedef uint32_t MDRVA; /* RVA */typedef struct &#123; uint32_t data_size; //MDRawDirectory的大小 MDRVA rva; //MDRawDirectory中第一个元素的偏移量或者说起始位置&#125; MDLocationDescriptor; /* MINIDUMP_LOCATION_DESCRIPTOR */typedef struct &#123; uint32_t stream_type; MDLocationDescriptor location;&#125; MDRawDirectory; 写MDRawThreadList，这里就是上面说的问题了，你会发现整个breakpad中，并没有构建MDRawThreadList对象，而是通过偏移量来操作，首先是获取thread的数目，然后rva = originPosition+numsOfThread*sizeof(MDRawThread)，这样就知道第一个MDRawThread的位置。 所以，修改的方式简单来说就是定义一个struct，然后将其插入到minidump文件的最后，然后按照规则解析出来。 如何在native crash的时候收集java堆栈在breakpad的MinidumpCallback中是无法收集java 堆栈的，经过我的测试，只要涉及到String类型的数据，就会直接退出，比如你在收集Java堆栈的方法中，定义一个String类型的数据，当运行到这行代码时，就会直接退出，后面的代码不会运行，解决的方式是开启一个新线程收集，这样就需要涉及到线程的同步问题，换句话说，就是崩溃线程A依赖于收集java堆栈的线程B，线程B也依赖于线程A，于是我们就会想到使用互斥锁+条件变量的方式解决。具体的做法如下： 首先我们定义一个java方法，该方法用于收集java的堆栈。public static void generateCrashProto(int crashId, final String path) 在JNI_OnLoad的时候将该方法的jmethodID以及所属类的jclass保存为全局引用 在JNI_OnLoad中使用pthread_create创建一个线程，定义回调void* DumpJavaThreadInfo(void *argv) 定于 如下几个变量： 123456static int tidCrash; //crash线程idstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;static pthread_mutex_t mutex_finish = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t cond_finish = PTHREAD_COND_INITIALIZER;pthread_t ntid; //新建线程id 在DumpJavaThreadInfo中判断tidCrash是否为0，不为0则一直等待，即等待MinidumpCallback回调 12345678pthread_mutex_lock(&amp;mutex); //当条件不满足时等待 while (tidCrash == 0) &#123; pthread_cond_wait(&amp;cond, &amp;mutex); &#125;...pthread_mutex_unlock(&amp;mutex);SetDumpJavaFinish(); //通知crash线程，java堆栈收集完毕 在MinidumpCallback回调中对tidCrash赋值，并且发生信号给上一步阻塞的线程 123456789101112131415161718192021222324252627tidCrash = gettid();minidumpPath = const_cast&lt;char *&gt;(descriptor.path());if (ntid != NULL)&#123; pthread_mutex_lock(&amp;mutex); pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); WaitDumpJava(); //等待获取java堆栈函数完成&#125;void WaitDumpJava()&#123; struct timeval now; gettimeofday(&amp;now, NULL); struct timespec outtime; outtime.tv_sec = now.tv_sec + c_waitSecond; outtime.tv_nsec = 0; pthread_mutex_lock(&amp;mutex_finish); pthread_cond_timedwait(&amp;cond_finish, &amp;mutex_finish, &amp;outtime); pthread_mutex_unlock(&amp;mutex_finish);&#125;//在DumpJavaThreadInfo被调用static void SetDumpJavaFinish()&#123; pthread_mutex_lock(&amp;mutex_finish); pthread_cond_signal(&amp;cond_finish); pthread_mutex_unlock(&amp;mutex_finish);&#125;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://sakurajiang.github.io/tags/linux/"},{"name":"native_crash","slug":"native-crash","permalink":"http://sakurajiang.github.io/tags/native-crash/"},{"name":"breakpad","slug":"breakpad","permalink":"http://sakurajiang.github.io/tags/breakpad/"}],"keywords":[]},{"title":"mmap_understand","slug":"mmap_mapping_file","date":"2020-06-19T16:00:00.000Z","updated":"2020-07-25T10:07:56.332Z","comments":true,"path":"2020/06/20/mmap_mapping_file/","link":"","permalink":"http://sakurajiang.github.io/2020/06/20/mmap_mapping_file/","excerpt":"","text":"前言网络上有很多描述mmap的文章，但是看完之后还是会让人感觉迷惑，原因是只是单纯的介绍了mmap的使用，其中提的最多的就是减少拷贝次数，并没有解释为什么要这样做。在计算机中，所有东西的出现必然有其原因，了解整个的前因对于对mmap的理解会很有好处，下面我们就从前因开始。 操作系统如何访问文件要说这个就得先说下虚拟内存 虚拟内存现代的操作系统，都会支持虚拟内存，它将物理内存对应用层开发透明，应用程序都是使用虚拟地址，其在编译的时候就确定，当然在链接的时候可能还会重定位修改。虚拟内存让进程以为自己独占系统所有的内存，当然是以一种欺骗的方式，因为现在的操作系统都支持多进程，比如我现在就在写这篇文章的同时，在听着杰伦的Mojito。且为了效率，虚拟地址的单位大小是页，一般是4096字节。也就是4kb。从前面的描述可以看出，虚拟内存和进程其实是密切相关的，一般来说两个不同的进程，同样的虚拟地址映射的是不同的物理内存(如果是同样的，岂不是乱套了)，所以在操作系统内部必然要存在物理地址和虚拟地址的转换，这个就是MMU，即memory manage unit。转换的时候需要使用到Page Tables，Page Tables包含Page Directory(PGD)、Page mid-level Directory(PMD)、Page Table(PT)。三者都是链表的结构，主要介绍一下PT，里面的每个元素被称为Page Table Entry，其中包含的值就是物理地址。 说了这么多，还是没开始说操作系统如何访问文件，别急，前置知识还是要了解的，还需要再介绍的前置知识就是用户空间和内核空间。 内核空间和用户空间我们假设虚拟地址的大小是4G，那么用户空间和内核空间分别占有3G和1G的空间，且内核空间的地址是高地址，即0xC0000000 到 0xFFFFFFFF，两者权限不同，内核可以访问计算机所有的资源，比如磁盘、所有的CPU指令、所有的虚拟空间。而用户空间只能访问受限的资源，一个常见的用户空间结构包含：stack、heap、text、data、bss、内存映射区域等。引入内核空间主要是基于系统的安全考量。因为如果所有的进程都可以访问系统资源，那么恶意进程对计算机的破坏就太恐怖了，比如一个恶意进程将计算机所有的文件删除。 操作系统如何访问文件说了这么多，终于到重头戏了，有了这些前置知识，假如你是一个操作系统的设计者，你会如何设计一个文件操作子系统。不妨停下想一想。 我们知道磁盘的读写速度和内存的读写速度不在一个量级上，加上前面说的用户空间和内核空间，因此频繁的访问磁盘肯定会降低程序的速度，因为会涉及到用户态和内核态的切换，正如解决计算机问题的经典方式，加一个中间层，那么自然就会想到在内核中使用一个buffer存储用户态传来的数据，当到一个容量的时候，再将数据写会磁盘。而且这样还有好处，比如，当进程A访问文件B，而进程B也访问文件B，在进程访问文件A后，文件的内容已经在内核的buffer中了，此时，进程B访问的时候就不需要再从磁盘将数据读入内核了。加快了进程B访问文件的速度。事实上，现代操作系统就是这样做的，负责磁盘和内核交互的模块是DMA，即direct memory access，而负责内核和用户空间的数据交互是CPU，分开的好处在于减轻CPU的工作，在从磁盘读文件的时候可以做其他事，此时的buffer有一个专门的名字叫做page cache。但是细想一下，如果只提供这样一种方式，是不是不友好，因为在文件的访问过程中可能会涉及到多次的用户态和内核态切换。那么有什么方式呢？也可以停下想一想。 上述的过程中，直接将内核空间的page cache和用户空间的映射，如何实现映射呢？只要内核空间的page cache中对应那块文件的内存的PT和用户空间需要映射的内存相同就行，这样两者所访问的物理内存就相同，当然最后映射返回的地址肯定要属于用户空间，因为只有这样用户空间才能访问。这样就可以减少一次内核态到用户态的一次拷贝。即现代操作系统的mmap，返回的值便是映射区域的地址(可以将地址打印出来，用于验证前面说的返回的地址是属于用户空间)，关于mmap的介绍可以直接看官方文档这里停下思考下，为什么我说的是内核态到用户态的一次拷贝，而不是双向的，即为什么只是read减少了一次拷贝，而write没有呢。 我们想下，在实际的代码中，当我们需要往某块地址中写数据的时候，比如我们有数据char *data = “hello world”，那么当我们拿到mmap返回的地址后，我们假设是mmapAddress，我们往mmapAddress写数据的数据，肯定需要将数据从data中拷贝到mmapAddress，只不过相比直接使用fwrite方法而言，少了内核态和用户态的切换。而读数据的时候就会减少拷贝，即我们可以直接访问mmapAddress地址。下面直接给代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;int main(int argc, char *argv[]) &#123; char * map; int fd, offset = 0; struct stat fileInfo; size_t fileSizeOld, fileSizeNew, textSize; const char *text = \"hello world\"; const char *filePath = \"/Users/jdk/TestMMAP/testmmap.txt\"; //your mapping file path printf(\"We will write text '%s' to '%s'.\\n\", text, filePath); // Open a file for writing. // Creating the file if it doesn't exist. if ((fd = open(filePath, O_RDWR | O_CREAT, (mode_t)0664 )) == -1) &#123; perror(\"open\"); exit(1); &#125; if (stat(filePath, &amp;fileInfo) == -1) &#123; perror(\"stat\"); exit(1); &#125; // If the file is not empty, show its content if (fileInfo.st_size != 0) &#123; map = mmap(0, fileInfo.st_size, PROT_READ, MAP_SHARED, fd, 0); if (map == MAP_FAILED) &#123; close(fd); perror(\"mmap\"); exit(1); &#125; printf(\"The content in '%s' before writing:\\n\", filePath); while (offset &lt; fileInfo.st_size) &#123; printf(\"%c\", map[offset]); offset++; &#125; printf(\"\\n\"); if (munmap(map, fileInfo.st_size) == -1) &#123; close(fd); perror(\"Error un-mmapping the file\"); exit(1); &#125; &#125; // Stretch the file size to write the array of char fileSizeOld = fileInfo.st_size; textSize = strlen(text); fileSizeNew = fileInfo.st_size + textSize; if (ftruncate(fd, fileSizeNew) == -1) &#123; close(fd); perror(\"Error resizing the file\"); exit(1); &#125; // mmap to write map = mmap(0, fileSizeNew, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (map == MAP_FAILED) &#123; close(fd); perror(\"mmap\"); exit(1);\\ &#125; printf(\"mmap address= %p\",map); //memcpy(map,text,textSize); for (size_t i = 0; i &lt; textSize; i++) &#123; /* printf(\"Writing character %c at %zu\\n\", text[i], i); */ map[i+fileSizeOld] = text[i]; //copy &#125; // Write it now to disk if (msync(map, fileSizeNew, MS_SYNC) == -1) &#123; perror(\"Could not sync the file to disk\"); &#125; for(int i =0;i&lt;textSize;i++)&#123; printf(\"value =%c \\n\",map[i]); //no need to copy &#125; // Free the mmapped memory if (munmap(map, fileSizeNew) == -1) &#123; close(fd); perror(\"Error un-mmapping the file\"); exit(1); &#125; // Un-mmaping doesn't close the file, so we still need to do that close(fd); return 0;&#125;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://sakurajiang.github.io/tags/linux/"},{"name":"mmap","slug":"mmap","permalink":"http://sakurajiang.github.io/tags/mmap/"}],"keywords":[]},{"title":"CAS","slug":"CAS","date":"2020-06-18T16:00:00.000Z","updated":"2020-07-06T12:48:46.766Z","comments":true,"path":"2020/06/19/CAS/","link":"","permalink":"http://sakurajiang.github.io/2020/06/19/CAS/","excerpt":"","text":"whatCAS全称是compare and swap，将内存中的值和一个给定的值对比，如果相等该内存的值修改为给定的新值。注意这一步是属于原子操作。 how通过简单的例子看一下本质，版本是jdk8： 12345678public class Test &#123; public AtomicInteger mAtomicInteger; public void testAdd() &#123; mAtomicInteger.getAndIncrement(); &#125;&#125; 直接看AtomicInteger.java代码 12345678/** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; 看下unsafe变量： 123456789101112// setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); //Unsafe是sun.misc.Unsafe类 private static final long valueOffset; //表示AtomicInteger类value的地址 static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 跳转到Unsafe.java的getAndAddInt方法 123456789101112131415161718/** * Atomically adds the given value to the current value of a field * or array element within the given object &lt;code&gt;o&lt;/code&gt; * at the given &lt;code&gt;offset&lt;/code&gt;. * * @param o object/array to update the field/element in * @param offset field/element offset * @param delta the value to add * @return the previous value * @since 1.8 */ public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v; &#125; 跳转到getIntVolatile方法 1234567891011121314/** Volatile version of &#123;@link #getInt(Object, long)&#125; */ public native int getIntVolatile(Object o, long offset);/** @see #getByte(long) */ public native int getInt(long address);/** * Fetches a value from a given memory address. If the address is zero, or * does not point into a block obtained from &#123;@link #allocateMemory&#125;, the * results are undefined. * * @see #allocateMemory */ public native byte getByte(long address); 很明显getIntVolatile的作用是获取给定地址的值。接下来看compareAndSwapInt方法 12345678/** * Atomically update Java variable to &lt;tt&gt;x&lt;/tt&gt; if it is currently * holding &lt;tt&gt;expected&lt;/tt&gt;. * @return &lt;tt&gt;true&lt;/tt&gt; if successful */ public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x); 我们直接到UnSafe.cpp类查找compareAndSwapInt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// These are the methods for 1.8.0static JNINativeMethod methods_18[] = &#123; &#123;CC\"getObject\", CC\"(\"OBJ\"J)\"OBJ\"\", FN_PTR(Unsafe_GetObject)&#125;, &#123;CC\"putObject\", CC\"(\"OBJ\"J\"OBJ\")V\", FN_PTR(Unsafe_SetObject)&#125;, &#123;CC\"getObjectVolatile\",CC\"(\"OBJ\"J)\"OBJ\"\", FN_PTR(Unsafe_GetObjectVolatile)&#125;, &#123;CC\"putObjectVolatile\",CC\"(\"OBJ\"J\"OBJ\")V\", FN_PTR(Unsafe_SetObjectVolatile)&#125;, DECLARE_GETSETOOP(Boolean, Z), DECLARE_GETSETOOP(Byte, B), DECLARE_GETSETOOP(Short, S), DECLARE_GETSETOOP(Char, C), DECLARE_GETSETOOP(Int, I), DECLARE_GETSETOOP(Long, J), DECLARE_GETSETOOP(Float, F), DECLARE_GETSETOOP(Double, D), DECLARE_GETSETNATIVE(Byte, B), DECLARE_GETSETNATIVE(Short, S), DECLARE_GETSETNATIVE(Char, C), DECLARE_GETSETNATIVE(Int, I), DECLARE_GETSETNATIVE(Long, J), DECLARE_GETSETNATIVE(Float, F), DECLARE_GETSETNATIVE(Double, D), &#123;CC\"getAddress\", CC\"(\"ADR\")\"ADR, FN_PTR(Unsafe_GetNativeAddress)&#125;, &#123;CC\"putAddress\", CC\"(\"ADR\"\"ADR\")V\", FN_PTR(Unsafe_SetNativeAddress)&#125;, &#123;CC\"allocateMemory\", CC\"(J)\"ADR, FN_PTR(Unsafe_AllocateMemory)&#125;, &#123;CC\"reallocateMemory\", CC\"(\"ADR\"J)\"ADR, FN_PTR(Unsafe_ReallocateMemory)&#125;, &#123;CC\"freeMemory\", CC\"(\"ADR\")V\", FN_PTR(Unsafe_FreeMemory)&#125;, &#123;CC\"objectFieldOffset\", CC\"(\"FLD\")J\", FN_PTR(Unsafe_ObjectFieldOffset)&#125;, &#123;CC\"staticFieldOffset\", CC\"(\"FLD\")J\", FN_PTR(Unsafe_StaticFieldOffset)&#125;, &#123;CC\"staticFieldBase\", CC\"(\"FLD\")\"OBJ, FN_PTR(Unsafe_StaticFieldBaseFromField)&#125;, &#123;CC\"ensureClassInitialized\",CC\"(\"CLS\")V\", FN_PTR(Unsafe_EnsureClassInitialized)&#125;, &#123;CC\"arrayBaseOffset\", CC\"(\"CLS\")I\", FN_PTR(Unsafe_ArrayBaseOffset)&#125;, &#123;CC\"arrayIndexScale\", CC\"(\"CLS\")I\", FN_PTR(Unsafe_ArrayIndexScale)&#125;, &#123;CC\"addressSize\", CC\"()I\", FN_PTR(Unsafe_AddressSize)&#125;, &#123;CC\"pageSize\", CC\"()I\", FN_PTR(Unsafe_PageSize)&#125;, &#123;CC\"defineClass\", CC\"(\"DC_Args\")\"CLS, FN_PTR(Unsafe_DefineClass)&#125;, &#123;CC\"allocateInstance\", CC\"(\"CLS\")\"OBJ, FN_PTR(Unsafe_AllocateInstance)&#125;, &#123;CC\"monitorEnter\", CC\"(\"OBJ\")V\", FN_PTR(Unsafe_MonitorEnter)&#125;, &#123;CC\"monitorExit\", CC\"(\"OBJ\")V\", FN_PTR(Unsafe_MonitorExit)&#125;, &#123;CC\"tryMonitorEnter\", CC\"(\"OBJ\")Z\", FN_PTR(Unsafe_TryMonitorEnter)&#125;, &#123;CC\"throwException\", CC\"(\"THR\")V\", FN_PTR(Unsafe_ThrowException)&#125;, &#123;CC\"compareAndSwapObject\", CC\"(\"OBJ\"J\"OBJ\"\"OBJ\")Z\", FN_PTR(Unsafe_CompareAndSwapObject)&#125;, &#123;CC\"compareAndSwapInt\", CC\"(\"OBJ\"J\"\"I\"\"I\"\")Z\", FN_PTR(Unsafe_CompareAndSwapInt)&#125;, &#123;CC\"compareAndSwapLong\", CC\"(\"OBJ\"J\"\"J\"\"J\"\")Z\", FN_PTR(Unsafe_CompareAndSwapLong)&#125;, &#123;CC\"putOrderedObject\", CC\"(\"OBJ\"J\"OBJ\")V\", FN_PTR(Unsafe_SetOrderedObject)&#125;, &#123;CC\"putOrderedInt\", CC\"(\"OBJ\"JI)V\", FN_PTR(Unsafe_SetOrderedInt)&#125;, &#123;CC\"putOrderedLong\", CC\"(\"OBJ\"JJ)V\", FN_PTR(Unsafe_SetOrderedLong)&#125;, &#123;CC\"park\", CC\"(ZJ)V\", FN_PTR(Unsafe_Park)&#125;, &#123;CC\"unpark\", CC\"(\"OBJ\")V\", FN_PTR(Unsafe_Unpark)&#125;&#125;; compareAndSwapInt会出现在多处，我们选择methods_18，因为是jdk8。然后搜索methods_18 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// This one function is exported, used by NativeLookup.// The Unsafe_xxx functions above are called only from the interpreter.// The optimizer looks at names and signatures to recognize// individual functions.JVM_ENTRY(void, JVM_RegisterUnsafeMethods(JNIEnv *env, jclass unsafecls)) UnsafeWrapper(\"JVM_RegisterUnsafeMethods\"); &#123; ThreadToNativeFromVM ttnfv(thread); // Unsafe methods &#123; bool success = false; // We need to register the 1.6 methods first because the 1.8 methods would register fine on 1.7 and 1.6 if (!success) &#123; success = register_natives(\"1.6 methods\", env, unsafecls, methods_16, sizeof(methods_16)/sizeof(JNINativeMethod)); &#125; if (!success) &#123; success = register_natives(\"1.8 methods\", env, unsafecls, methods_18, sizeof(methods_18)/sizeof(JNINativeMethod)); &#125; if (!success) &#123; success = register_natives(\"1.5 methods\", env, unsafecls, methods_15, sizeof(methods_15)/sizeof(JNINativeMethod)); &#125; if (!success) &#123; success = register_natives(\"1.4.1 methods\", env, unsafecls, methods_141, sizeof(methods_141)/sizeof(JNINativeMethod)); &#125; if (!success) &#123; success = register_natives(\"1.4.0 methods\", env, unsafecls, methods_140, sizeof(methods_140)/sizeof(JNINativeMethod)); &#125; guarantee(success, \"register unsafe natives\"); &#125; // Unsafe.getLoadAverage register_natives(\"1.6 loadavg method\", env, unsafecls, loadavg_method, sizeof(loadavg_method)/sizeof(JNINativeMethod)); // Prefetch methods register_natives(\"1.6 prefetch methods\", env, unsafecls, prefetch_methods, sizeof(prefetch_methods)/sizeof(JNINativeMethod)); // Memory copy methods &#123; bool success = false; if (!success) &#123; success = register_natives(\"1.7 memory copy methods\", env, unsafecls, memcopy_methods_17, sizeof(memcopy_methods_17)/sizeof(JNINativeMethod)); &#125; if (!success) &#123; success = register_natives(\"1.5 memory copy methods\", env, unsafecls, memcopy_methods_15, sizeof(memcopy_methods_15)/sizeof(JNINativeMethod)); &#125; &#125; // Unsafe.defineAnonymousClass if (EnableInvokeDynamic) &#123; register_natives(\"1.7 define anonymous class method\", env, unsafecls, anonk_methods, sizeof(anonk_methods)/sizeof(JNINativeMethod)); &#125; // Unsafe.shouldBeInitialized if (EnableInvokeDynamic) &#123; register_natives(\"1.7 LambdaForm support\", env, unsafecls, lform_methods, sizeof(lform_methods)/sizeof(JNINativeMethod)); &#125; // Fence methods register_natives(\"1.8 fence methods\", env, unsafecls, fence_methods, sizeof(fence_methods)/sizeof(JNINativeMethod)); &#125; 根据注释直接查找NativeLookup.cpp，搜索JVM_RegisterUnsafeMethods 12345678910111213#define CC (char*) /* cast a literal from (const char*) */#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)static JNINativeMethod lookup_special_native_methods[] = &#123; // Next two functions only exist for compatibility with 1.3.1 and earlier. &#123; CC\"Java_java_io_ObjectOutputStream_getPrimitiveFieldValues\", NULL, FN_PTR(JVM_GetPrimitiveFieldValues) &#125;, // intercept ObjectOutputStream getPrimitiveFieldValues for faster serialization &#123; CC\"Java_java_io_ObjectInputStream_setPrimitiveFieldValues\", NULL, FN_PTR(JVM_SetPrimitiveFieldValues) &#125;, // intercept ObjectInputStream setPrimitiveFieldValues for faster serialization &#123; CC\"Java_sun_misc_Unsafe_registerNatives\", NULL, FN_PTR(JVM_RegisterUnsafeMethods) &#125;, &#123; CC\"Java_java_lang_invoke_MethodHandleNatives_registerNatives\", NULL, FN_PTR(JVM_RegisterMethodHandleMethods) &#125;, &#123; CC\"Java_sun_misc_Perf_registerNatives\", NULL, FN_PTR(JVM_RegisterPerfMethods) &#125;, &#123; CC\"Java_sun_hotspot_WhiteBox_registerNatives\", NULL, FN_PTR(JVM_RegisterWhiteBoxMethods) &#125;,&#125;; 这样我们就找到了Java_sun_misc_Unsafe_registerNatives，其实就是指Java_sun_misc_Unsafe_registerNatives对应JVM_RegisterPerfMethods，而Java_sun_misc_Unsafe_registerNatives根据命名知道在Unsafe.java中。 12345private static native void registerNatives(); static &#123; registerNatives(); sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, \"getUnsafe\"); &#125; 即在Unsafe加载之后就会调用registerNatives，即调用JVM_RegisterUnsafeMethods，即调用了Unsafe.cpp的register_natives 123456789101112131415161718/** * Helper method to register native methods. */static bool register_natives(const char* message, JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods) &#123; int status = env-&gt;RegisterNatives(clazz, methods, nMethods); if (status &lt; 0 || env-&gt;ExceptionOccurred()) &#123; if (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123; tty-&gt;print_cr(&quot;Unsafe: failed registering %s&quot;, message); &#125; env-&gt;ExceptionClear(); return false; &#125; else &#123; if (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123; tty-&gt;print_cr(&quot;Unsafe: successfully registered %s&quot;, message); &#125; return true; &#125;&#125; 即注册了对应的方法。即compareAndSwapInt对应Unsafe_CompareAndSwapInt方法 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(\"Unsafe_CompareAndSwapInt\"); oop p = JNIHandles::resolve(obj); //此处p指Unsafe.java对象 jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); //Unsafe.java中value变量的地址 return (jint)(Atomic::cmpxchg(x, addr, e)) == e; e是compare valueUNSAFE_END 直接看Atomic.cpp的cmpxchg方法 123456unsigned Atomic::cmpxchg(unsigned int exchange_value, volatile unsigned int* dest, unsigned int compare_value) &#123; assert(sizeof(unsigned int) == sizeof(jint), \"more work to do\"); return (unsigned int)Atomic::cmpxchg((jint)exchange_value, (volatile jint*)dest, (jint)compare_value);&#125; 在runtime/atomic.inline.hpp可以知道有很多不同版本的cmpxchg实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. * * This code is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 only, as * published by the Free Software Foundation. * * This code is distributed in the hope that it will be useful, but WITHOUT * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License * version 2 for more details (a copy is included in the LICENSE file that * accompanied this code). * * You should have received a copy of the GNU General Public License version * 2 along with this work; if not, write to the Free Software Foundation, * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. * * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA * or visit www.oracle.com if you need additional information or have any * questions. * */#ifndef SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP#define SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP#include \"runtime/atomic.hpp\"// Linux#ifdef TARGET_OS_ARCH_linux_x86# include \"atomic_linux_x86.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_linux_sparc# include \"atomic_linux_sparc.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_linux_zero# include \"atomic_linux_zero.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_linux_arm# include \"atomic_linux_arm.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_linux_ppc# include \"atomic_linux_ppc.inline.hpp\"#endif// Solaris#ifdef TARGET_OS_ARCH_solaris_x86# include \"atomic_solaris_x86.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_solaris_sparc# include \"atomic_solaris_sparc.inline.hpp\"#endif// Windows#ifdef TARGET_OS_ARCH_windows_x86# include \"atomic_windows_x86.inline.hpp\"#endif// AIX#ifdef TARGET_OS_ARCH_aix_ppc# include \"atomic_aix_ppc.inline.hpp\"#endif// BSD#ifdef TARGET_OS_ARCH_bsd_x86# include \"atomic_bsd_x86.inline.hpp\"#endif#ifdef TARGET_OS_ARCH_bsd_zero# include \"atomic_bsd_zero.inline.hpp\"#endif#endif // SHARE_VM_RUNTIME_ATOMIC_INLINE_HPP 本来想看arm平台的，没找到，最后看atomic_linux_x86.inline.hpp的， 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) \"cmpxchgl %1,(%3)\" : \"=a\" (exchange_value) : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest), \"r\" (mp) : \"cc\", \"memory\"); return exchange_value;&#125; 由于篇幅已经够长了，因此开了一篇新文章，用以解释上面的代码，推荐看下那篇文章，这里直接告诉结果： %1表示exchange_value，%3表示dest，这里”a” (compare_value)将compare_value的值赋给eax寄存器，这里cmpxchgl的指令作用是比较compare_value和dest的值，如果相等，将exchange_value赋值给dest，如果不相等，将dest的值赋值给exchange_value。而Unsafe_CompareAndSwapInt方法，返回值是cmpxchgl的返回值和e比较，不相等时，一直跑循环，否则，退出。这样就完成了原子自增操作。","categories":[],"tags":[{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"并发","slug":"并发","permalink":"http://sakurajiang.github.io/tags/并发/"}],"keywords":[]},{"title":"inline_assembly","slug":"inline_assembly","date":"2020-06-12T16:00:00.000Z","updated":"2020-07-06T12:48:50.031Z","comments":true,"path":"2020/06/13/inline_assembly/","link":"","permalink":"http://sakurajiang.github.io/2020/06/13/inline_assembly/","excerpt":"","text":"why当你的项目的主要语言是C/C++的时候，你需要进行极致的优化或者想实现的代码需要高度的硬件定制性时，就需要使用到内连汇编。 how我们通过使用asm关键字，语法如下： 12345asm ( assembler template : output operands (optional) : input operands (optional) : clobbered registers list (optional) ); assembler template:：汇编语言，比如”movl %%eax, %%ebx” ，这句话的意思是将eax寄存器的值拷贝到ebx寄存器中。 output operands:：为assembler template中的汇编代码提供输出参数(指定assembler template中汇编代码输出到C/C++的哪个变量)，并且指定这个变量存在哪个寄存器中，比如”=a”(b)，表示将结果写到b这个变量中（当然需要先声明变量b），该变量存储在eax寄存器。=表示该操作数是只写的，之前的数据被抛弃。注意，如果你在assembler template中对eax寄存器赋值，那么也就修改了b变量的值。举个例子： 12345int a = 5; asm (\"movl $6,%0; movl $9,%%eax;\" :\"=a\"(a) : :); 最后，a的值为9，而不是6。 input operands：为assembler template中的汇编代码提供输入参数(指定assembler template中汇编代码需要使用到C/C++的哪个变量)，并且指定该变量存储在哪个寄存器中，比如”a”(a)，表示将a变量的值存储在eax寄存器。此时在assembler template中访问eax寄存器，也就是访问a变量 clobbered registers list：告诉gcc，asm里的汇编代码会使用到这些寄存器，所以gcc不能使用这里面的寄存器。当然在input或者output列出的寄存器不需要在这里重复列出，如果asm里的汇编代码会以不可预知的方式修改内存，那么还需要将”m”加到clobbered registers list。 看完了语法之后，下面以例子开始说明： 先举一个简单的例子，即将变量a的值赋值给b: 1234567891011121314#include&lt;iostream&gt; using namespace std;int main() &#123; int b,a=10;asm(\"movl %1, %%eax; movl %%eax, %0;\" :\"=r\"(b) /* output */ :\"r\"(a) /* input */ : /* clobbered register */ );cout &lt;&lt; \"a := \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b := \" &lt;&lt; b &lt;&lt; endl; return 0;&#125; 其中0%表示参数b，%1表示参数a，如果是output operands中有多个参数，那么%index就会顺延，比如如果output operands是:”=r”(b),”=r”(c) 而input operands是”r(a), r(b)”，那么%0表示b，%1表示c，%2表示a，%3表示b。 写下一个例子之前，我们先了解一下cmpxchgl指令，根据文档解释，cmpxchgl有两个参数，分别是source_operand和dest。cmpxchgl会比较eax寄存器和dest中的值，如果相等，就将source_operand的值赋给dest，否则，就把dest的值赋值给eax寄存器。还有一个需要注意的是，如果在assembler template中加了lock，那么dest就必须存储在memory中。下面我们以例子说明： 123456789void testCmpxchg(int compareValue,int exchangeValue,int dest)&#123; int result = 0; __asm__ __volatile__(\"lock;\\n\" \"cmpxchg %1, %3;\\n\" :\"=a\"(result) :\"r\"(exchangeValue),\"a\"(compareValue),\"m\"(dest) :\"memory\",\"cc\"); std::cout&lt;&lt;\"result =\"&lt;&lt;result&lt;&lt;\"compareValue=\"&lt;&lt;compareValue&lt;&lt;\"exchangeValue=\"&lt;&lt;exchangeValue&lt;&lt;\"dest=\"&lt;&lt;dest&lt;&lt;std::endl;&#125; 输入参数是4,5,4，则输出4,4,5,5。输入参数是4,5,5，输出5,4,5,5。","categories":[],"tags":[{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"汇编","slug":"汇编","permalink":"http://sakurajiang.github.io/tags/汇编/"}],"keywords":[]},{"title":"collect_crash","slug":"collect_crash","date":"2020-06-09T16:00:00.000Z","updated":"2020-07-26T10:20:37.770Z","comments":true,"path":"2020/06/10/collect_crash/","link":"","permalink":"http://sakurajiang.github.io/2020/06/10/collect_crash/","excerpt":"","text":"what主要是简单介绍如何收集crash，包括SDK、符号表收集、以及解析堆栈。后续会出新的文章详细介绍。这里主要是以breakpad举例，但是思路都是想通的，其他的框架也差不多。 howclientclient端主要是收集crash数据，对于breakpad的使用以及原理不在这篇文章的范围，主要讲述的是client端需要收集哪些数据。首先想到的就是堆栈、操作系统以及手机的基础属性、还有APP的版本等，当然还有一些别的数据，这里推荐直接对照成熟的crash收集平台，比如bugly、听云等。按照我的经验，比较重要但是没那么显眼的属性有以下几个：前后台、渠道、系统日志。当然还可以扩展思路，比如和日志系统、应用轨迹(即从用户打开APP开始到最后回到后台整个过程中，用户的所有交互行为。)、网络性能数据打通，获取更多的crash前后的上下文。 CICI端的作用就是收集符号表和mapping文件。除了这些我们还需要一些额外的信息，比如渠道、AppId、AppSecret、env等。将打包过程中生成的mapping文件和so文件拷贝到一个统一的目录，然后将mapping文件和so文件的路径以及上面的额外信息放在一个文件中，这样我们需要的信息都在这个文件中，可以通过遍历文件的方式将生成对应的symbol文件，将其上传到服务端，需要注意的是上传成功后不要立即将原来的so文件删除，因为有可能你的APP会接入多个crash收集系统，而为了防止重复生成symbol文件的问题，当遍历完一个文件后，设置一个标志，而后不再遍历该文件。当然还可以设置一个时间期限，比如7天。 server这里的server端不涉及到数据的存储，只是接口层面的数据接口，server端主要做的事情是解析堆栈，也就是输入参数有两个，分别是Client收集的数据和CI端收集的数据，输出则是前端页面消费的数据。比较难的数据就是将crash分类。复杂程度和前端需要的数据相关。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://sakurajiang.github.io/tags/linux/"},{"name":"native_crash","slug":"native-crash","permalink":"http://sakurajiang.github.io/tags/native-crash/"},{"name":"breakpad","slug":"breakpad","permalink":"http://sakurajiang.github.io/tags/breakpad/"}],"keywords":[]},{"title":"stack_backtrace","slug":"stack_backtrace","date":"2020-05-04T16:00:00.000Z","updated":"2020-07-26T07:40:00.027Z","comments":true,"path":"2020/05/05/stack_backtrace/","link":"","permalink":"http://sakurajiang.github.io/2020/05/05/stack_backtrace/","excerpt":"","text":"what在计算机中，stack backtrace(又称为stack trace、stack traceback)是程序执行中某一时间点的stack frames的报告，而每个stack frame对应一个还没有返回的函数调用，里面包含函数的局部变量、参数、使用的寄存器等。举个例子，比如funcA调用了funcB，而funcB还没返回，那么此时stack中就有两个stack frame，一个是funcA的，一个是funcB的，当然两个都是在一个stack中。那么stack backtrace就会包含这两个stack frame。 why当程序出错的时候，可以通过stack backtrace获取有效的信息。 how主要有三种方式，参考breakpad中的代码，以stackwalker_arm中的GetCallerFrame为例，主要包含三种方式，按顺序分别是根据CFI、根据fp、扫描stack，下面主要介绍根据fp register来backtrace： fp register首先先了解一下stack frame，方式是直接看汇编代码，由于gcc版本会有多个，在本地测试不方便，因此，直接在arm线上编译器编写。代码如下： 123int funcA()&#123; printf(\"this is funcA\");&#125; 编译时加入-mapcs-frame选项，则对应的汇编如下： 12345678910mov ip, sp //将sp的值存入ip push &#123;fp, ip, lr, pc&#125; //将pc、lr、ip、fp的值压栈，且每次sp的值减小4，且是先减小4，然后在压栈，即pc的值存储在sp-4，lr的值存储在sp-8，ip的值存储在sp-12,fp的值存储在sp-16中 sub fp, ip, #4 //将ip的值减去4存入fp ldr r0, .L2 bl printf nop mov r0, r3 //将r3的值存入r0 sub sp, fp, #12 //将fp中的值减去12存入sp ldm sp, &#123;fp, sp, lr&#125; //从sp中取值3个值分别存入fp、sp、lr，对应的是sp-&gt;fp，sp+4-&gt;sp，sp+8-&gt;lr bx lr 我们主要关注fp、ip、lr、pc这几个寄存器，从上面的注释可以看到，该stack frame中首先将sp的值存入ip中，然后压入了4个寄存器的值，即此时，而后将ip的值减去4存入fp中，这样操作之后，该stack frame中就有4个寄存器的值。如下表格： ip register previous function area pc lr ip sp register fp 之所以顺序是如此，因为，根据arm的官方文档描述：The registers are stored in sequence, the lowest-numbered register to the lowest memory address (start_address), through to the highest-numbered register to the highest memory address (end_address).而根据寄存器的编号大小是可以知道是这个顺序。 经过sub fp, ip, #4之后的stack frame如下 previous function area fp register pc lr ip sp register fp 而经过sub sp, fp, #12之后的stack frame如下 previous function area fp register pc lr ip sp register fp 经过ldm sp, {fp, sp, lr}之后的stack frame如下 ip register previous function area fp register pc lr register lr sp register ip fp register fp 注意registers中的值都是地址，所以，当我们对寄存器的值取值之后才是寄存器值对应那块地址中存储的值，所以，下面会出现寄存器的值和取值两个用词，注意区分，从上面就可以看出，我们进行stack backtrace其实只需要知道fp register的值即可，假设我们知道fp register的值，将其-4之后取值就会得到该frame的lr 那块区域的值，即该函数的调用者，同时，将该值减12取值就会得到调用者的fp的值，于是就可以继续这个递归。获取方法的整条链路。 从上面可以看出，pc、ip寄存器是不需要的，所以，可以进行优化，即将-mapcs-frame选项删除，gcc则会使用默认的mno-apcs-frame选项，注意在gcc5.0之后，-mapcs-frame选项已被废弃，产生的汇编如下: 123456789push &#123;fp, lr&#125; //将lr、fp寄存器的值压栈，且每次sp的值减小4，且是先减小4，然后在压栈，即lr的值存储在sp-4，fp的值存储在sp-8 add fp, sp, #4 //sp寄存器的值加4存入fp中 ldr r0, .L2 bl printf nop mov r0, r3 //将r3的值存入r0 sub sp, fp, #4 //将fp的值减去4存入sp pop &#123;fp, lr&#125; //从栈中弹值存入fp和lr，且每次sp增大4，且是先弹出再存值，因此sp的值存入fp，sp+4的值存入lr。sp同样增大了8 bx lr 经过push {fp, lr}之后的栈如下： previous function area lr sp register fp 经过add fp, sp, #4 previous function area fp register lr sp register fp 经过sub sp, fp, #4 previous function area fp register lr sp register fp pop {fp, lr} sp register previous function area lp register lr fp register fp 此时，fp的值存入了fp register，lr的值存入了lr register，且stack frame收缩了。即sp register此时指向了之前的stack frame。跟之前一样，可以通过fp跟踪整个调用链，就不展开了。 上面的例子都是arm编译器编译的，arm64编译的会不一样，比如stack frame的fp寄存器的值，建议读者自己跑一遍。 题外话这里说句题外话，从上面的这些例子可以看出，函数调用返回后，只是stack frame收缩或没有收缩了，但是不管收缩还是没有收缩，数据都是未被清理的，这也就会导致如果两个stack frame完全一样，那么就会导致后一个stack frame的局部变量如果没有赋初值，就会复用上一个stack frame的局部变量的值，举个例子。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;void func1(void)&#123; int a = 23; int b = 24; int c; c = a + b; printf(\"a = %d, b = %d, c = %d\\n\", a, b, c);&#125;void func2(void)&#123; int a; int b; int c; printf(\"a = %d, b = %d, c = %d\\n\", a, b, c);&#125;int main(void)&#123; func1(); func2(); return (0);&#125;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://sakurajiang.github.io/tags/linux/"},{"name":"native_crash","slug":"native-crash","permalink":"http://sakurajiang.github.io/tags/native-crash/"}],"keywords":[]},{"title":"gradle","slug":"gradle介绍和实战","date":"2018-10-29T16:00:00.000Z","updated":"2020-07-06T12:11:10.433Z","comments":true,"path":"2018/10/30/gradle介绍和实战/","link":"","permalink":"http://sakurajiang.github.io/2018/10/30/gradle介绍和实战/","excerpt":"","text":"什么是gradle简单的说gradle是一套构建工具，所谓构建工具就是根据一堆输入信息，生成一系列产物，复杂的说gradle是一套框架，所有的参数配置其实都严格对应相应的API，我们没有必要可以记住这些API，我们需要掌握的是大体流程，然后借助官方SDK+API来完成自己的需求。 为什么会有gradle在Gradle爆红之前，常用的构建工具是ANT，然后又进化到Maven。ANT和Maven这两个工具其实也还算方便，现在还有很多地方在使用。但是二者都有一些缺点，所以让更懒得人觉得不是那么方便。比如，Maven编译规则是用XML来编写的。XML虽然通俗易懂，但是很难在xml中描述if{某条件成立，编译某文件}/else{编译其他文件}这样有不同条件的任务。于是gradle就应运而生，gradle采用的语言是groovy，groovy能让你写java语言像写脚本一样简单，同时gradle是一种DSL语言，即Domain Specific Language，领域相关语言。什么是DSL，说白了它是某个行业中的行话。在gradle的体现有很多，比如sourceSets代表源文件的集合等。 如何使用gradle1.首先我们需要学习一下groovy，值得一提的是groovy语言在编译的时候已经编译为java类字节码，然后运行在JVM虚拟机中，可以理解为它扩展了Java语言，写法十分的奔放，比如定义变量使用def定义，但是这个关键字也不是必需的，语句结尾可以不使用;，单引号严格对应Java中的双引号，双引号则和脚本语言中的双引号类似，当含有$符号时，则它会$表达式先求值，三引号中的字符串支持换行。暂时先了解这些，详细的可以直接看GDK。2.接下来我们就介绍一下gradle的行话，在gradle中，每一个待编译的工程都是一个Project对象，每个Project在编译的时候包含多个Task，比如一个Android项目的编译可能就包含Java源码编译Task、资源编译Task、JNI编译Task、lint检查的Task、打包生成APK的Task、签名Task等等。一个Project包含的Task的数量是由编译脚本执行的插件决定的，插件就是用来定义Task，并且具体执行这些Task的东西。而gradle作为一个框架，主要负责定义流程和规则，具体的编译工作则是通过编译插件来完成，比如编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android LIbrary插件。该中有两个Project，根据gradle设计，每一个Project都对应一个build.gradle对象，而build.gradle就是该Project的编译脚本，如果只有这些，那么你编译的就需要进入到每一个Project中，然后执行编译脚本，这样效率很低，于是gradle提供了Multi-Projects Build，即多个项目一起编译，实现很简单，就是再项目根目录增加一个build.gradle文件，然后再增加一个settings.gradle，前者可以什么都不写，后者就是通过include标签将所有的Project包含进来，如：include &#39;:app&#39;, &#39;:buildsrc&#39;，同时我们还可以在这里添加一些初始化的函数，比如：1234567 def initSomeValue()&#123; Properties properties = new Properties(); File fileProperties = new File(rootDir.getAbsolutePath()+&quot;/local.properties&quot;); properties.load(fileProperties.newDataInputStream()); gradle.ext.myApi = properties.getProperty(&quot;sdk.dir&quot;); println(&quot;init&quot;+gradle.myApi);&#125; 该函数就是将SDK的目录赋值给gradle的额外属性myApi中，下次直接通过gradle.myApi获取该属性。目前我们了解的内容如下：每一个Project都必须设置一个build.gradle文件。对于multi-projects build，需要在根目录下也放一个build.gradle，和一个settings.gradle。一个Project是由若干tasks来组成的，当gradle xxx的时候，实际上是要求gradle执行xxx任务。这个任务就能完成具体的工作。下面说一下gradle的工作流程，简单地说就是先执行settings.gradle，完成初始化过程，然后解析每一个build.gradle，其中的Task会被添加到有向图中，用于解决依赖关系，最后就是执行阶段，执行gradle XXX，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍。接下来介绍几种对象：1.Gradle对象，当执行gradle XXX的时候，gradle会从默认的配置脚本中构造一个Gradle对象，在整个构建过程中只有一个Gradle对象，Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。2.Project对象，每一个build.gradle对象都会生成一个Project对象，在gradle中，Project对象对应的是Build Script，在build.script中，我们一般需要做如下几件事，分别是：应用插件、设置属性等。3.Settings对象，每个settings.gradle都会生成一个Settings对象，注意，对于其他gradle文件，除非定义了class，否则会转换成一个实现了Script接口的对象。这一点和3.5节中Groovy的脚本类相似。讲了这么多，那么一般怎么用呢？对于Java和Groovy而言，我们一般会把公共的方法放在一个类中，然后在别的类中import该类，但是在Gradle中，一般都是通过在build.gradle中定义插件，然后在插件中定义Task来完成，定义Task可以通过task函数来定义，一个Task包含多个Action，所以Task有两个函数，分别是doFirst和doLast，即最先执行和最后执行。普及了基础知识，接下来直接看这个项目吧,代码里差不多都有注释。这里需要再补充的就是自定义gradle插件步骤：1.新建一个module（我一般是选择Android Library） 2.除了main文件夹和build.gradle全部删除，注意main文件夹下的内容也要删除 3.在main下新建groovy文件夹 4.在groovy新建package，名字自己随意取，跟包名类似 5.在package下新建name.groovy文件，name自己取，如下： 12345678910111213package com.sakurajiang.testimport org.gradle.api.Pluginimport org.gradle.api.Projectpublic class MyPlugin implements Plugin&lt;Project&gt; &#123; void apply(Project project) &#123; def log = project.logger log.error &quot;========================&quot;; log.error &quot;精简的MyPlugin，开始修改Class!&quot;; log.error &quot;========================&quot;; &#125;&#125; 6.在main目录下新建resources文件夹 7.在resources文件夹下新建META-INF文件夹 8.在META-INF文件夹下新建gradle-plugins文件夹 9.在gradle-plugins文件夹下新建name.properties文件，这里的文件名就是引用该插件时用到的名字。其中的内容是implementation-class=com.sakurajiang.test.MyPlugin，后面的值就是步骤5中的文件的包名加类名。 10.在该module的build.gradle文件中配置如下属性 1234567891011121314151617181920apply plugin: &apos;groovy&apos;apply plugin: &apos;maven&apos;dependencies &#123; compile gradleApi() //gradle sdk compile localGroovy() //groovy sdk&#125;repositories &#123; jcenter()&#125;group=&apos;sakurajiang&apos;version=&apos;1.0.0&apos;uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(&apos;../repo&apos;)) &#125; &#125;&#125; 11.选择AS中右边的gradle，选择自定义的插件，选择upload中的uploadArchives 12.在需要使用该插件的module中的build中添加如下代码：1234567891011buildscript &#123; repositories &#123; maven &#123; url uri(&apos;../repo&apos;) &#125; &#125; dependencies &#123; classpath &apos;sakurajiang:buildsrc:1.0.0&apos; &#125;&#125;apply plugin: &apos;Z&apos; 其中’Z’就是步骤9中的name，其中的classpath就是group：modulename：version。 13.选择Make Project，至此就可以在Build中看到自定义插件中的信息了。自定义插件到此完成。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"gradle","slug":"gradle","permalink":"http://sakurajiang.github.io/tags/gradle/"}],"keywords":[]},{"title":"校招总结","slug":"校招总结","date":"2017-10-09T16:00:00.000Z","updated":"2020-07-06T09:36:07.192Z","comments":true,"path":"2017/10/10/校招总结/","link":"","permalink":"http://sakurajiang.github.io/2017/10/10/校招总结/","excerpt":"","text":"前言离我校招结束也有一段时间了，之前一直想着写一篇校招总结的，但是一直拖拖沓沓到现在，心里总是有些抗拒，总想着再拖会，写一篇更好的总结，离4.12也已经好几个月了，我也正有点写东西的必要了(严肃脸)。 还是前言作为一个实际懵懵懂懂但却自以为是的人，在大二结束时才幡然醒悟需要开始学相关的技术了，好能够找到好工作，在秋招以前，我都以为找工作是大四快结束的时候才开始找的，所以，在我刚刚踏入校园的那一刻开始，我的大学计划是大一好好玩、大二想一下自己喜欢干什么、大三开始学、大四找工作。这么看着好像是一回事，但是除了第一条做的还不错，别的几条都是有点赶鸭子上架的意思，做的都不太好，或者说，这个计划其实就是有问题的，就比如第二条而言，我设定这个计划的时候就是想着大二在那空想自己喜欢干什么，从不会亲自去实践一下自己是否真的喜欢，永远都是站在岸上，却想着自己能够学会游泳。至于大四找工作那个就更离谱了，因为找工作很早就开始了，这也就是我为什么说我自己实际懵懵懂懂但却自以为是的原因。 假装进入正题所以，先说一下我们的正题，那就是校招总结，打算分为三个阶段来说，顺序就是准备、开始、结束这三个阶段来说。 准备阶段准备阶段如果要细说的话就篇幅太大，可能会舍本逐末，所以，大概就是找好方向、早做准备、早点开始。对于一个应届生而言，在找好方向这一块我觉得应该你首先需要确定自己不想干什么，然后自己不讨厌干什么，自己能干什么这几个方面去考虑，去确定一个大体的方向，这里就拿程序猿举例，分为很多方向，比如Android、前端、后台之类的，然后呢，如果你在学习这个方面的过程中，突然想学习一下别的方面的技术，没关系，喜欢就去学，就算你过一两个星期发现自己不喜欢了，但那又怎样？技术本就是相通的，点终究会串成线，线会织成面，当然，在你确定不喜欢之后你需要马上回到主线程中，不要觉得这是浪费时间，站在岸上永远都学不会游泳，只有在不断的尝试中才能逐渐清晰自己喜欢干什么。但是切记不可三心二意。 正题面试部分此部分是我以前部分面试后的总结，不分先后顺序，有一个由于找不到当初记录的资料，所以比较少，没错，说的就是最后爱奇艺面试那个。因为对于秋招没有好好准备，所以面试也不多，此外，别人的面试经验其实只能当个参考，以一个过来人的经验看，最重要的其实是你对自己简历上写的东西一定要熟，要知其然并且知其所以然，还有就是如果想进好一点的公司，常见的算法一定要会。 有赞1.AA里面有几张表2.数据库用了什么框架3.多线程里如何保证单例模式的正常4.Material Design的意义5.Retrofit实现原理6.intentservice和service的区别7.单例模式的懒加载在哪里设置同步比较好8.activity在onCreate中多少秒出现ANR，service呢？contentProvider会出现ANR吗？ 虽然没有过，但是还是有收获的，遇到问题还是要多问几个为什么，还是应该保持哲学家的好奇心，不要对于知识理所当然，同时，逻辑要清晰，对于组件要明白为什么需要它们，了解它们的作用。对于方法需要了解它的作用，返回值，参数的意义。当然，也没有必要完全否定自己。只是需要适当的调整方向，不能再继续去看进阶的东西，但是先应该回头将基础重新理一遍。另外，简历上的东西一定要完全弄懂，注意是完全弄懂，毕竟面试官要了解你能不能胜任这个工作，都会先从简历上着手，如果你连简历上的东西都不是很清楚，自然就不会有谈下去的心思。至于为什么我需要让他了解我，让他觉得我能胜任这个工作，因为你就是来应聘这份工作的啊。 搜狗数据库更新时我们怎么做？1.数据库什么时候更新？当我们应用升级的时候，用户安装更新，此时用户的数据库其实是没有更新的，只有当我们访问数据库的时候才会更新，访问数据库其实就是指调用自定义SQLiteOpenHelper类中的getReadableDatabase()或者getWritableDatabase()方法。2.应用是如何知道数据库需要更新的？当用户安装了我们最初的程序之后，此时访问数据库的时候会将数据库的版本号置为1.0(假设一开始是1.0)，当我们升级我们的数据库时，需要自己在程序中传入一个新的version参数，是在new自定义SQLiteOpenHelper类的对象时传入，当我们传入的新的version参数比原来的大时，就会调用onUpgrade(db, version, mNewVersion);方法，源代码如下： db.beginTransaction(); try { if (version == 0) { onCreate(db); } else { if (version &gt; mNewVersion) { onDowngrade(db, version, mNewVersion); } else { onUpgrade(db, version, mNewVersion); } } db.setVersion(mNewVersion); db.setTransactionSuccessful(); } finally { db.endTransaction(); } } 当用户更新我们的应用时，此时用户的数据库版本号还是1.0，但是新程序中的version参数是2.0，当用户访问数据库的时候，应用程序就知道此时需要更新数据库，然后就会调用onUpgrade(db, version, mNewVersion);方法，最后将版本号换成2.0。3.那么我们在onUpgrade(db, version, mNewVersion);方法中如何更新表呢？SQLite提供了ALTER TABLE，能够重命名和增加列名，但是无法删除列名，而且只能在最后增加列名，那么当遇到删除列名的时候需要怎么办呢？我们可以先采用四步：1.将需要更新的表变成一个临时表2.重新创建一个表，表名就是之前的表名。3.将临时表中的数据插入到新的表中4.删除临时表这样就完成了数据表的更新。 爱奇艺由于面完爱奇艺之后拿到了offer，然后就出去浪了，当时就简单的记了一下，现在写的时候找不到了，所以只能大致的说一下，先是让你自己写一个排序算法，然后对这个算法优化，然后是Android常见的面试题，其中包括设计模式等，还有就是问你使用过的框架以及它的源码等等，然后问到后面就是别的也不知道问什么，来，写算法吧，然后就开始在黑板上手写算法，都是一些很常见的算法，记得大部分在牛客网上都遇到过。包括电话面试的话，总共有四轮技术面和一轮HR面。 寻找招聘公司的途径互联派把这个放第一个不是因为它多好，而是我用它貌似一次面试都没有，搞不懂他们的内推是怎样的意思，也可能是我自己太菜吧，反正后面我都是看一下他们的信息，然后去对应招聘公司的官网或者以下几个网站去投简历。 v2ex这上面的感觉还不错 水木社区也还行 牛客网一般般 官网这个是最正经的。 最后说点什么，这不是鸡汤在你找工作的过程中，你可能会遇到很多挫折和问题，特别对于学校不是很好的学生而言，比如笔试过后没有面试、一面之后就没有消息、你以为你能过的结果没过、每次你抱期望去面试结果都是失败、看到旁边的同学都不找了想放弃、努力找了那么久结果还是没找到、你兴致勃勃的去参加宣讲会结果那家公司只是打着招聘的幌子去宣讲自己的公司，作为一个过来人，我想说，如果不甘心，那就只能收拾心情，总结反思继续找，当然，有可能你找到春招结束，也不会找到，找工作有时候也是看运气的，如果甘心，那就不找了，其实最重要的就是在于你甘不甘心。我就是因为不甘心所以从秋招一直找到了春招，一直到4.12才拿到爱奇艺的offer，也是我第一份正式的offer。所以如果你不甘心就只能收拾心情，总结反思继续找了。 最后最后再放一个我的简历链接吧，也不知道是不是最后的版本，但估计差不多，希望能给需要的人一些帮助，毕竟找工作确实辛苦。简历","categories":[],"tags":[{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"校招总结","slug":"校招总结","permalink":"http://sakurajiang.github.io/tags/校招总结/"}],"keywords":[]},{"title":"AReview-ANR","slug":"AReview-ANR","date":"2017-04-02T16:00:00.000Z","updated":"2020-07-06T09:21:27.877Z","comments":true,"path":"2017/04/03/AReview-ANR/","link":"","permalink":"http://sakurajiang.github.io/2017/04/03/AReview-ANR/","excerpt":"","text":"前记发现好久没写博客了，主要是最近忙着春招，忙着看算法和将以前的知识重新回顾，所以很久没更了，其实一直在写，只是写的不系统，所以没更出来，今天抽空特地更一下。ps:春招真难，还没找到工作。。。 ANR分析ANR流程什么是ANRANR是指在Android中，当触摸或者按键事件以及特殊事件没有在规定的时间中完成，那么就会出现ANR(也有可能不会出现ANR)，这里的特殊事件就是指Service、BroadCastReceiver、ContentProvider。 在源码中是如何体现的？以Service为例：1.在realStartServiceLocked方法中会调用bumpServiceExecutingLocked(r, execInFg, &quot;create&quot;);方法，这个函数的作用就是延时发送消息，当在Service的onCreate方法回调之后，就会调用AMS.serviceDoneExecuting(IBinder token, int type, int startId, int res)来清除之前发送的消息。所以在onCreate()方法中不能超过20S。2.在AS.sendServiceArgsLocked方法中也会bumpServiceExecutingLocked(r, execInFg, &quot;start&quot;);，然后当回调onStartCommand();方法后也会调用AMS.serviceDoneExecuting(IBinder token, int type, int startId, int res)方法来清除之前发送的消息。所以在onStartCommand()中也不能超过20S，同时因为在onStartCommand()会调用onStart(),所以在onStart()中也不能超过20S。也就是说采用的手法是消息机制，就是在启动的时候延时发送一个消息，如果成功启动，那么就会移除这个消息，反之就会使用AMS中的MainHandler去发送SERVICE_TIMEOUT_MSG这个消息，在MainHandler中的handleMessage来处理消息，最后会调用到AMS.appNotResponding()。以BroadCastReceiver为例：在processNextBroadcast方法中调用setBroadcastTimeoutLocked(timeoutTime);方法设置超时时间，当没超时时，调用cancelBroadcastTimeoutLocked();超时时，由BroadcastHandler发送BROADCAST_TIMEOUT_MSG，在BroadcastHandler的handleMessage中调用broadcastTimeoutLocked(false);来强制结束广播。并且调用mService.appNotResponding(mApp, null, null, false, mAnnotation);使用的依然是handler消息机制。以ContentProvider为例：ContentProvider发生ANR和其他的都不一样，当使用ContentProvider的时候，若是目标进程不存在，则会创建目标进程，在创建目标进程后会调用AMS.attachApplicationLocked，此时就会延时发送一个消息，延时也是10S，当provider成功publish之后，也就是在AMS.publishContentProviders中会移除这个消息，反之最后会调用到AMS.removeProcessLocked。杀掉ContentProvider所在的进程。注意:关于CONTENT_PROVIDER_PUBLISH_TIMEOUT超时时机是指在startProcessLocked之后会调用AMS.attachApplicationLocked为起点，一直到AMS.publishContentProviders的过程。所以对于ContentProvider而言，如果不需要创建新进程，那么就不会出现这个情况，在不需要创建新进程的时候，也可能会出现ANR，并且会调用AMS.appNotResponding()。 总结ANR发生的原因是，在Android的源码中规定了事件或者特殊事件需要在规定时间内完成，提升用户的体验，但是没有完成。在这里事件指触摸或者按键，特殊事件指Service、BroadCastReceiver、ContentProvider。 所采取的措施都是通过Handler消息机制。对于Service而言：在Service的onCreate，onStart、onStartCommnand生命周期方法中超时20S。对于BroadCastReceiver而言：在onReceive()超时10S。对于ContentProvider而言：从AMS.attachApplicationLocked到AMS.publishContentProviders的过程中耗时超过10S。对于ContentProvider而言，不会走AMS.appNotResponding()，其他的都走。AMS.appNotResponding()处理中主要是将CPU使用情况和进程的trace文件信息，保存到/data/system/dropbox；","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AReview","slug":"AReview","permalink":"http://sakurajiang.github.io/tags/AReview/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"AReview-消息机制","slug":"AReview-消息机制","date":"2017-02-11T16:00:00.000Z","updated":"2020-07-06T09:22:03.164Z","comments":true,"path":"2017/02/12/AReview-消息机制/","link":"","permalink":"http://sakurajiang.github.io/2017/02/12/AReview-消息机制/","excerpt":"","text":"消息机制概述 从开发角度而言，Handler是Android消息机制的上层接口，所以，消息机制主要就是Handler的运行机制，Handler的作用就是在一个线程中发送消息，然后在另一个线程中处理，通过在消息中存放数据达到线程间通信。如果你想在哪个线程中接收消息，那你就要在那个线程中生成一个Handler对象（当然实际上是在哪个线程中调用了Looper.loop()方法，那么就会在哪个线程中接收消息）。Handler的运行需要Looper，MessageQueue的支撑。所以接下来就分别分析这三个类。 MessageQueue这个类翻译过来就是消息队列，但是这其实是一个链表，因为对于这个类而言，它的作用就是存取handler发送的消息，它包含的主要操作就是插入和读取，读取的时候也会涉及删除操作，意思就是一个消息只能被处理一次，所以使用链表的结构会更好，因为链表在插入和删除上有优势。这个类的对象是在Looper的构造函数中生成的，也就是说一个Looper对象就对应自己的一个MessageQueue对象，代码如下: private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 而对于一个线程而言，就只有一个Looper对象，所以一个线程就只有一个MessageQueue对象。为什么一个线程就只有一个Looper对象，我们继续往下看。 Looper这个类的作用就是管理handler发送的消息，也就意味着它需要和MessageQueue一起使用，这可能就是在源码里为什么会将MessageQueue的构造放在Looper的构造函数里。在Looper的构造函数里，会构造一个MessageQueue对象，同时会得到当前的线程，代码如下: private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 这也就意味着Looper的操作都是基于当前线程的，那我们是如何实现线程切换的呢？其实说起来很简单，我们只需要得到每个线程中的Looper对象就可以了。那么，如何得到呢？接下来就介绍一个重要的类:ThreadLocal,掌声欢迎。 ThreadLocalThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定的线程中可以获取到存储的数据，对于其他线程则无法获取到数据。这样说太抽象了，直接上代码: public class MainActivity extends Activity { private ThreadLocal&lt;String&gt; stringThreadLocal; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TestThreadLocal(); } public void TestThreadLocal(){ stringThreadLocal=new ThreadLocal&lt;&gt;(); stringThreadLocal.set(&quot;main&quot;); Log.e(&quot;log&quot;, &quot;main=&quot; + stringThreadLocal.get()); new Thread(&quot;thread1&quot;){ @Override public void run() { super.run(); stringThreadLocal.set(&quot;thread1&quot;); Log.e(&quot;log&quot;,&quot;thread1=&quot;+stringThreadLocal.get()); } }.start(); new Thread(&quot;thread2&quot;){ @Override public void run() { super.run(); stringThreadLocal.set(&quot;thread2&quot;); Log.e(&quot;log&quot;,&quot;thread2=&quot;+stringThreadLocal.get()); } }.start(); } } 运行结果如下: 从上面的Log可以看出，在不同的线程中访问同一个ThreadLocal对象，ThreadLocal获取到的值是不一样的。这就是ThreadLocal的奇妙之处。ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前的ThreadLocal的索引去查找对应的value值。而不同的线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。 这样的话就很简单了，通过这个ThreadLocal类我们就可以轻松的得到各个线程中的Looper对象了，从源码中我们也可以看出来: static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 这里就贴这一段了，贴多了看着不好看，有兴趣的同学可以下去自己看一下Looper的源码，其实很简单。既然我们可以得到各个线程中的Looper对象，那么也就意味着其实我们就已经实现了线程切换。然后我们再看一下Loope对象中的重要方法： prepare()：这个方法的作用是构造一个Looper对象，调用的顺序是先调用prepare(boolean quitAllowed)方法，然后调用sThreadLocal.set(new Looper(quitAllowed));方法，其中quitAllowed的值的作用就是区分主线程和其他线程，区分的作用是设置主线程不允许退出的。 loop()：这个方法的作用是循环遍历整个消息队列，将handler发送的消息送给msg.target.dispatchMessage(msg);处理，这是一个死循环，退出的唯一方式就是MessageQueue的next()方法返回null，msg.target其实就是你定义的handler对象，这样就实现了将消息又返回给handler自身来处理。而且，实现了线程的切换。 quie()和quitSafely():这两个方法的作用就是退出loop()循环，两个的区别就是，第一个是立即退出，第二个时等消息队列中的已有消息处理完毕再退出。所以，当我们手动创建Looper的时候注意在合适的时候把loop退出。 Handler这个类的作用就是发送消息和处理消息，当你在创建一个Handler对象的时候，在Handler的构造函数中会得到当前的线程的Looper对象，按照之前的分析，得到了Looper对象其实就得到了MessageQueue对象，这里注意是当前线程，当我们调用sendMessage(message)方法的时候，会将一个消息发送到调用Looper.loop()方法所在的线程的消息队列中，跟在哪个线程里调用sendMessage(message)方法没有关系，然后创建Handler的线程的Looper对象的Loop()方法就会将消息返回给handler对象的dispatchMessage(msg);来处理。也就是说将sendMessage(message)在别的线程中调用，最后message会在调用Looper.loop()方法的线程中来执行。使用Handler发送消息有两种方式，一个是post(runnable)，还有一个是sendMessage(message)，在调用第一个的时候，会调用getPostMessage(Runnable r)方法，将Runnable对象存储到Message对象中，所以第一个还是调用第二个，下面看一下Handler的dispatchMessage(Message msg)，代码如下: public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 其中的msg.callback就是Runnable对象，而mCallback就是当你创建Handler是通过传递一个Handler.Callback对象的时候的Handler.Callback对象。 public Handler(Callback callback) { this(callback, false); } 最后就是Handler自身的handleMessage(msg)。这就是Handler的dispatchMessage(Message msg)的执行顺序，也就是先执行Runnable对象，然后是Handler.Callback对象，最后是Handler自身的handleMessage(msg);。 从使用流程分析当我们创建一个Handler的时候，在Handler的构造函数里会调用Looper.myLooper();来得到当前的线程的Looper对象，得到了Looper对象也就得到了当前线程的MessageQueue对象，注意这里是当前线程，然后用创建好了的Handler对象来发送消息，一般来说发送消息都会在别的线程，因为这样才有意义，然后当调用Handler的sendMessage(message)后，就会调用MessageQueue的enqueueMessage(msg, uptimeMillis);方法，这样就将消息发送到了调用Looper.loop()方法所在的线程的消息队列中，然后将消息发送给msg.target.dispatchMessage(msg);来处理，其中的msg.target就是你创建的Handler对象，然后消息就得到了处理。在实际的开发中，我们的发送消息都会在别的线程，并且在这个线程发送消息之前会完成一些耗时任务，比如下载，然后下载完成后发送消息，在handleMessage(Message msg)或者run()去执行操作，因为这两个方法的调用都是在创建Handler的线程中调用的，这样就完成了将下载任务指定到专门的下载线程中，并且能够在原来的线程中操作下载任务的结果。这也就是实现了将一个任务切换到指定的线程中工作。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AReview","slug":"AReview","permalink":"http://sakurajiang.github.io/tags/AReview/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"AReview-超简单的Binder，AIDL和Messenger的原理及使用流程","slug":"AReview-超简单的Binder，AIDL和Messenger的原理及使用流程","date":"2016-12-14T16:00:00.000Z","updated":"2020-07-06T09:23:02.580Z","comments":true,"path":"2016/12/15/AReview-超简单的Binder，AIDL和Messenger的原理及使用流程/","link":"","permalink":"http://sakurajiang.github.io/2016/12/15/AReview-超简单的Binder，AIDL和Messenger的原理及使用流程/","excerpt":"","text":"Binder的原理 要想了解AIDL就需要先了解Binder的原理，所以这里先说一下Binder原理，Binder的原理大概是这样： 服务器端：当我们在服务端创建好了一个Binder对象后，内部就会开启一个线程用于接收binder驱动发送的消息，收到消息后会执行相关的服务器代码。 Binder驱动：当服务端成功创建一个Binder对象后，Binder驱动也会创建一个mRemote对象，该对象的类型也是Binder类，客户就可以借助这个mRemote对象来访问远程服务，注意这里是借助，真正调用的时候需要将这个转换成对应的对象，比如使用AIDL的时候就要转换成AIDL对象。 客户端：客户端要想访问Binder的远程服务，就必须获取远程服务的Binder对象在binder驱动层对应的mRemote引用。当获取到mRemote对象的引用后，就可以调用相应Binder对象的暴露给客户端的方法(如果有方法的话)。 AIDLAIDL的本质其实就是系统为我们提供了一种快速实现Binder的工具，我们完全可以不用AIDL，自己去写代码实现Binder，但是当你写出来的时候会发现其实和AIDL自动生成的代码一模一样。我们接下来来分析一下原理，因为AIDL的实现其实就是快速实现Binder，所以原理自然离不开Binder。但是在分析原理之前，我们先将系统根据我们定义的AIDL文件自动生成的java文件分析一下。比较重要的就是Stub和它的内部代理类Proxy。我们说一下重要的方法： asInterface(android.os.IBinder obj)用于将服务器的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于统一进程，那么返回服务器的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。 onTransact(int code,android.os.Parcel data,android.os.Parcel reply,int flags)这个方法运行在服务端的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由服务端 的onTransact方法来处理。这个方法有四个参数，分别是code ，data，reply，flags.code是确定客户端请求的方法是哪个，data是目标方法所需的参数，reply是服务器端执行完后的返回值。如果这个方法返回false，那么客户端的请求会失败。 Proxy#getBookList这里的getBookList方法就是在自定义的AIDL文件中定义的方法，这个方法运行在客户端，当客户端远程调用此方法的时候，内部实现是这样的：首先在代理类中创建该方法所需要的输入型Parcel对象_data，输出型Parcel对象_reply和返回值对象List;然后把该方法的参数信息写入_data中，接着mRemote调用transact方法来发起RPC(远程过程调用)请求， 同时当前线程挂起，然后服务端的onTransact方法会被调用，直到RPC返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果并返回(如果有返回值的话)，之前创建的参数其实就是onTransact()方法需要的参数。 说完了重要方法，接下来分析AIDL原理： 服务端：因为要实现Binder，必须在服务器端创建一个Binder对象，如何创建呢？就是newAIDL接口中的Stub内部类，代码示例如： Binder mBinder=new IBookManager.Stub(){接口方法实现} 其中IBookManager是系统根据我们自己定义的IBookManager.AIDL所生成的类。 Binder驱动：在AIDL中，Binder驱动其实就是AIDL，在AIDL的Proxy类中会传入一个Binder参数，生成一个mRemote引用。 客户端：要实现客户端跨进程和服务端通信，必须获得服务端的Binder对象在binder驱动层对应的mRemote引用，如何获得呢？首先绑定远程服务，绑定成功后的ServiceConnection中的IBinder service其实就是mRemote引用，但是因为是使用AIDL方式，所以需要在客户端中调用IBookManager.Stub.asInterface(android.os.IBinder obj)方法将服务器返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务器的远程方法了。 根据原理，我们得出AIDL的使用流程，其实很简单，大致就是在服务端创建一个Service，然后创建一个Binder对象，最后在客户端得到这个Binder对象。 AIDL使用流程：先建立AIDL，如果在你建立的AIDL接口中，有自定义的类，那么，也需要建立这个类的AIDL，并且名字要完全相同。同时在使用的时候，一定要显示的导入这个类。接下来的流程就是跟Binder的一样了。 服务器端：创建Binder对象，并且实现接口中的方法。 客户端：绑定service，得到Binder对象在驱动层对应的mRemote引用。 ####重点1.当你在客户端调用服务器的方法的时候，其实是通过代理去访问，详情可以看上面的重点方法介绍里的Proxy#getBookList，所以你在客户端连续调用两次服务器的同一个方法的时候，比如，这里的getBookList，你会发现，里面的对象都不一样。因为每次在调用方法的时候，在代理类中都会创建该方法所需要的参数对象，所以里面的对象会变化。 2.AIDL中无法使用普通的接口，只能使用AIDL接口，并且实现AIDL接口的时候不能用implements，因为需要实现的接口其实是自定义接口.Stub，而不是自己定义的那个接口。使用implements无法实现。 3.解注册的时候需要使用到RemoteCallbackList，需要注意的是这个类的beginBroadcast()和finishBroadcast()一定要配对使用，否则会出现异常java.lang.IllegalStateException: beginBroadcast() called while already in a broadcast，特别是在使用for循环的时候。 4.对于AIDL中的in，out，inout这里就直接附上一篇别人写的博客，这篇博客讲的很详细，而且我也赞同他的观点，纸上得来终觉浅，绝知此事要躬行。 5.当使用客户端调用服务器的方法的时候，被调用的方法运行在服务器的Binder线程池中，同时客户端会被挂起，如果此时服务端方法执行耗时的话，就会导致客户端线程长时间阻塞，如果客户端线程是UI线程的话，就会导致客户端ANR，注意的是onServiceConnected(ComponentName name, IBinder service)和onServiceDisconnected(ComponentName name)都运行在UI线程，所以不能在这里调用服务端耗时的方法。同理，对于服务端调用客户端的方法的情况，比如服务端调用客户端的listener中的方法的时候也是一样。即服务端挂起，方法运行在客户端的Binder线程池中。 6.当服务端因为某种异常原因停止，我们需要重新启动服务端，这里有两种方式，因为AIDL的底层是Binder，所以可以使用Binder的linkToDeath和unlinkToDeath方法。还有一种方式是在onServiceDisconnected(ComponentName name)重新绑定。这两个区别就是第二种方式可以访问UI，第一种不行，因为像之前说的，onServiceDisconnected(ComponentName name)是运行在UI线程里的。而第一种方式使用的时候需要设置一个IBinder.DeathRecipient接口用于接收服务端binder因为特殊原因消失的通知，当收到通知的时候就会回调binderDied()方法，我们在这里unlinkToDeath并且重新绑定service。而这个binderDied()方法是运行在客户端的Binder线程池中的。 Messenger的原理及使用Messenger大致的原理是这样的，因为Messenger的底层还是AIDL，所以，原理和AIDL差不多。 服务器：首先需要在服务器创建Binder对象，如何创建呢？通过Messenger来创建，所以我们需要先构造Messenger对象,对于Messenger的构造方法有两种，如下: public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target); } public Messenger(Handler target) { mTarget = target.getIMessenger(); } 所以我们需要先构造一个Handler，这个Handler的作用其实就是处理消息。然后我们再通过这个Handler来构造Messenger对象，这个Messenger对象其实就是将客户端发送来的消息传递给Handler来处理，然后我们需要得到Binder对象，通过在Service的onBind方法中return Messenger.getBinder()，这样就得到了Binder对象。 Binder驱动：跟AIDL一样，还是Service。 客户端：也是需要得到服务端的Binder对象在binder驱动层对应的mRemote引用，获得的方式是将ServiceConnection中的IBinder service当做参数传入Messenger的构造函数中，如: Messenger mService=new Messenger(service)； 然后就可以用mService.send(msg)给服务器发消息。实现跨进程通信。因为这里是借助Messenger，所以无法调用服务器端的方法，只能通过message来传递消息。而当服务器需要回应客户端的时候，就需要客户端提供一个Messenger，然后服务器得到这个Messenger，因为在就像客户端向服务端发送请求的时候，也是服务器提供一个Messenger，然后客户端得到这个Messenger。那么如何实现呢？因为客户端和服务器已经建立了连接，所以只需要在客户端发送消息的时候，通过消息的replyTo参数向服务器传入一个Messenger，然后服务器在接收到客户端的消息的时候得到通过message的replyTo参数得到这个Messenger，然后利用这个向客户端发送消息就可以了。主要代码如下:在客户端发送消息给服务器的时候: message.replyTo=clientMessenger; 服务器接收消息的时候 Messenger clientMessenger=msg.replyTo; 这样就在服务器端得到了客户端的Messenger，然后在服务器端通过clientMessenger.send(message);就向客户端发送了消息。 重点1.对于使用Messenger而言，底层其实是AIDL，但是没有AIDL灵活，因为这是借助Messenger来发送消息从而进行消息的传递，不能直接调用服务端的方法，而使用AIDL是直接可以调用服务端的方法。2.对于服务端的Messenger的作用是将客户端传递的消息传递给Handler来处理，而客户端的是发送消息给服务端。3.Messenger是以串行的方式处理客户端发来的消息，当消息多的时候就就不合适了。而AIDL是可以并发处理客户端传来的消息。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AReview","slug":"AReview","permalink":"http://sakurajiang.github.io/tags/AReview/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"RestAPP-简洁的事件分发","slug":"RestAPP-简洁的事件分发","date":"2016-11-15T16:00:00.000Z","updated":"2020-07-06T09:35:18.720Z","comments":true,"path":"2016/11/16/RestAPP-简洁的事件分发/","link":"","permalink":"http://sakurajiang.github.io/2016/11/16/RestAPP-简洁的事件分发/","excerpt":"","text":"说在前面的话事件分发是一个重点也是难点，所以，本篇幅有点长，如果耐心看完本篇，相信读者会有收获的。同时，读者也可以自己写例子测试，毕竟，纸上得来终觉浅，绝知此事要躬行。但是，对于水平高的读者，其实最好的方式是看源代码，因为一切原因都可以从源头找到答案。 关于事件分发 关于事件分发，其实主要就是理解三个函数，这三个函数分别是dispatchTouchEvent(MotionEvent ev)，onInterceptTouchEvent(MotionEvent ev)以及onTouchEvent(MotionEvent ev)，这里直接上一张图： 这张图将分发事件中的重要的三个函数之间的关系表达的比较清晰，这里再简单的解释一下上面的伪代码:一个点击事件产生后，会从外到内传递，传递到根ViewGroup后，会调用根ViewGroup的dispatchTouchEvent方法，然后如果自己的onInterceptTouchEvent方法返回true，表示拦截事件，那么这个事件就会自己处理，也就是调用自己的onTouchEvent方法，如果返回false，就表示自己不拦截这个事件，事件就会传递给子元素，也就是调用子元素的dispatchTouchEvent方法，如此传递下去，直到事件被处理。 知道了关系以后，我们还需要了解这三个函数，了解一个函数，其实无非就是理解它的作用，传入的参数以及返回值。先说dispatchTouchEvent(MotionEvent ev):这个函数的作用是分发事件，不管是ViewGroup还是View都有这个方法，它的返回值受本身的onInterceptTouchEvent(MotionEvent ev)和child.dispatchTouchEvent(MotionEvent ev)共同影响（从上面那张图就可以看出来），返回的各个值的意义如下:return true ：表示该View内部消化掉了所有事件。 return false ：事件在本层不再继续进行分发，这个false也就是本身的dispatchTouchEvent(MotionEvent ev)返回值，而这个返回值会回溯给上层控件的dispatchTouchEvent(MotionEvent ev)，表示自己没有接受这个事件，不管上层控件是view还是viewGroup，都是交由上层控件的onTouchEvent(MotionEvent ev)方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。 如果事件分发返回系统默认的 super.dispatchTouchEvent(ev)，事件将分发给本层的事件拦截onInterceptTouchEvent(MotionEvent ev)方法进行处理，而不是super的onInterceptTouchEvent。因为return super.dispatchTouchEvent(ev)会去运行父viewGroup的dispatchTouchEvent(ev)，然后运行onInterceptTouchEvent，那么这个onInterceptTouchEvent是谁的呢？根据方法是基于对象的，所以就会运行child的onInterceptTouchEvent(MotionEvent ev)也就是本层的事件拦截器，而不是super的onInterceptTouchEvent。详情可以参考规则中的第十条。 然后是onInterceptTouchEvent(MotionEvent ev):这个函数的作用是拦截事件，只有ViewGroup有这个方法，返回的各个值的意义如下:return true ：表示将事件进行拦截，并将拦截到的事件交由本层控件 的 onTouchEvent 进行处理；return false ：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的dispatchTouchEvent进行处理。 如果返回super.onInterceptTouchEvent(ev)，默认false，即表示不拦截该事件，这样事件才能以分发下去。最后是onTouchEvent(MotionEvent ev):这个函数的作用是处理触摸事件，ViewGroup和View都有这个方法，返回值的意义如下:如果return true，表示onTouchEvent处理完事件后消费了此次事件。此时事件终结； 如果return fasle，则表示不响应事件，如果是ACTION_DOWN事件，那么该事件将会不断向上层View的onTouchEvent方法传递，直到某个View的onTouchEvent方法返回true，如果到了最顶层View还是返回false，那么事件就会交给Activity处理。且在同一个事件系列中，当前View无法再次接收到该事件序列，如果不是ACTION_DOWN事件，那么不会返回给父view的onTouchEvent处理，而是给Activity处理，并且该view可以继续接收该事件序列； 如果return super.onTouchEvent(event);，默认是true，即表示处理事件。那这个和return true有什么区别呢？从代码就可以看出来，return super.onTouchEvent(event)会执行super.onTouchEvent(event)这个方法。比如，当你继承EditText后，重写onTouchEvent(MotionEvent event)方法，如果你将return super.onTouchEvent(event);换成return true，就会发现当你按返回取消输入框，再次点击自定义EditText时就会无法弹出输入框，解决办法可以是将return true修改成return super.onTouchEvent(event)，或者是在之前调用一次super.onTouchEvent(event)方法，弹出输入框是在action为ACTION_UP的时候弹出的。 重要的知识点(大家拿本子记一下，高考必考啊)1.一个viewGroup一旦决定拦截事件(这里分两种情况，一个是拦截了ACTION_DOWN事件，还有一个是没有子View满足分发事件的条件或者子view在ACTION_DOWN时返回了false)，那么后面的事件序列都会交给它处理，并且不会再调用onInterceptTouchEvent(ev)方法， 当ACTION_DOWN事件成功传入子view的时候， 那么父ViewGroup在别的事件分发的时候，比如ACTION_MOVE，每次都会调用onInterceptTouchEvent来判断是否拦截当前事件。 也就是说，父ViewGroup的onInterceptTouchEvent不会再次调用的时机只是自己来处理这个事件，也就是自己的onTouchEvent被调用，只有这个时候才不会再次调用onInterceptTouchEvent，当事件传入子view来处理事件的时候，父ViewGroup都会每次都调用onInterceptTouchEvent来决定是否拦截当前事件。 2.dispatchTouchEvent无论返回true还是false，事件都不再进行分发，只有当其返回super.dispatchTouchEvent(ev)，才表明其具有向下层分发的愿望，但是是否能够分发成功，则需要经过事件拦截onInterceptTouchEvent的审核。事件是否向上传递处理是由onTouchEvent的返回值决定的。 3.正常情况下，一个事件序列只能被一个view拦截且消耗，因为，一旦决定拦截事件，那么这个事件只能被这个view消耗,并且它的onInterceptTouchEvent(ev)方法也不会再次调用(这里的拦截和规则一中的拦截是一样的。这里的再次调用是指当确定拦截事件后，除了在ACTION_DOWN时调用onInterceptTouchEvent(ev)，后面都不调用，其实跟规则一中说的一样)，如果你想这个事件序列被多个view拦截消耗，那么你可以在拦截事件的那个view中的onTouchEvent()方法中调用你想让其拦截事件的那个view的onTouchEvent()方法来实现。 4.view一旦用onTouchEvent()开始处理事件，如果没有处理ATION_DOWN事件，那么同一个事件序列中的事件也不会交给他处理，会回溯给他的父控件，如果你处理了ACTION_DOWN但是没有处理ACTION_MOVE或者ACTION_UP，那么这个事件还是被你消耗，不会调用父控件的onTouchEvent方法，最后会是Activity处理，后面的事件还是继续交给你处理。其实，这就类似现实，如果别人第一次叫你做事，你没做好，那么后面就都不会放心叫你做了，如果你第一次做好了，后面没做好，别人还是会给你做的，所以，第一次很重要。 5.view的onTouchEvent默认都是消费事件的(返回true)，除非是不可点击的，也就是longClickable和clickable都为false，只有这个属性会影响view的onTouchEvent的返回值，别的属性不会，比如，Enabled属性，就算是Enabled属性为false，也就是disable状态，view的onTouchEvent默认返回的还是true。 6.事件传递是由外向内的，即事件总是传递给父元素，再由父元素分发给子控件，通过requestDisallowInterceptTouchEvent();方法可以在子元素中干预父元素的事件分发过程，但是不能干预ACTION_DOWN事件，因为当时ACTION_DOWN事件的时候，父元素会重置FLAG_DISALLOW_INTERCEPT标志位。 7.使用内部拦截法的时候，为了弄清楚顺序，我就直接调试，结果，运行到父元素的dispatchTouchEvent后，不会去调用父元素的onInterceptTouchEvent方法，直接就到了子元素的dispatchTouchEvent，依然会运行到子view的onTouchEvent，等到ACTION_UP的时候才会又跑到父元素中的dispatchTouchEvent和onInterceptTouchEvent去判断是否拦截ACTION_UP事件。我倒腾了一天，才发现是需要移动，也就是让move多次调用才行，因为事件是由外向内的，当第一次ACTION_MOVE事件到的时候，先运行父ViewGroup的dispatchTouchEvent方法，此时FLAG_DISALLOW_INTERCEPT依然是设置成true，所以，不会运行父ViewGroup的onInterceptTouchEvent方法，直接就会运行子view的dispatchTouchEvent方法，然后FLAG_DISALLOW_INTERCEPT被设置成false，于是当第二次的ACTION_MOVE到来的的时候，才会去运行父viewGroup的onInterceptTouchEvent方法，然后子view收到ACTION_CANCEL事件，等到第三个ACTION_MOVE的时候父viewGroup才开始拦截事件。但是因为我之前是调试，所以都只有一次move事件，结果就不一样了。也是醉了。并且使用内部拦截法的时候，ACTION_UP事件也会被父view拦截，不会传递到子view中，也就意味着子view的onClick事件不会响应，这一点要记住。 8.内部拦截法和外部拦截法的区别:内部拦截法需要到该事件的第三个的时候才有用，也就是该事件的第一个依然被子view得到，外部拦截法则是到第二个就有用了，子view不会得到该事件的任何一个，比如，拦截ACTION_MOVE的时候，使用内部拦截法在拦截第三个ACTION_MOVE的时候才拦截了，因为第一个ACTION_MOVE会被子view得到，而使用外部拦截法则是第二个ACTION_MOVE的时候就拦截了，因为子view不会得到ACTION_MOVE中的任何一个。详情可以见9，10。所以，使用外部拦截法要好点。 9.当viewGroup没有拦截ACTION_DOWN而拦截了ACTION_MOVE或者ACTION_UP的时候，那么，第一个被拦截的动作不会在viewGroup中的onTouchEvent中触发，也不会在子view的onTouchEvent中触发，而是子view会受到ACTION_CANCEL事件。该事件序列后面的事件都会被拦截，并且下一个同类型的事件传来时，不会再调用viewGroup的onInterceptTouchEvent方法，直接就调用viewGroup的onTouchEvent方法，这里解释一下，什么是第一个被拦截的动作，比如，多个move的时候，第一个move就不会被父view或者子view执行，感觉是这个事件变成了ACTION_CANCEL事件传递到了子view。也就是说，一旦在这种情况下，ACTION_UP事件永远不会被子view接收。也就意味着，不管是使用外部拦截法还是内部拦截法，只要拦截了，那么子view就收不到ACTION_UP事件。还有就是ViewGroup就不要拦截ACTION_UP了，因为这样大家都得不到ACTION_UP事件，何必呢？ 10.为了讲述方便，当从一个ViewGroup分发事件到子ViewGroup时，在子ViewGroup的dispatchTouchEvent方法中调用父类的dispatchTouchEvent，发现不会继续调用父类的onInterceprTouchEvent，而是直接调用子ViewGroup的onInterceptTouchEvent，为什么在这里调用父类的dispatchTouchEvent不会跟着调用父类的onInterceptTouchEvent？我调试和看源码发现当运行到findChildWithAccessibilityFocus()方法时，view会变成接受到事件的view，然后就不知道了。水平还是看不懂源代码。其实这是因为我对java的理解有错误，基于方法都是基于对象的，所以在子viewGroup中调用父类的dispatchTouchEvent，也就是super.dispatchTouchEvent()时，这时会运行到父viewGroup的dispatchTouchEvent里，会调用onInterceptTouchEvent方法，这时的onInterceptTouchEvent其实就已经是子viewGroup的onInterceptTouchEvent方法，而不是父ViewGroup的dispatchTouchEvent方法，因为方法是基于对象的。 11.onClick发生的前提就是可点击，并且收到了ACTION_DOWN和ACTION_UP事件。这里解释一下，这里的收到了用词不是那么准确，应该是能接收到事件，并且return super.onTouchEvent()了，记住是return super.onTouchEvent()，如果是return true都不行，因为return true没有执行view的onTouchEvent方法，而点击事件是在ACTION_UP中设置的。即在ACTION_UP的时候源码中调用了performClick()方法。这里贴一部分源代码 TextView的源代码: final boolean superResult = super.onTouchEvent(event); View的源代码: case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-fragment生命周期","slug":"RestAPP-fragment生命周期","date":"2016-11-09T16:00:00.000Z","updated":"2020-07-06T09:31:45.321Z","comments":true,"path":"2016/11/10/RestAPP-fragment生命周期/","link":"","permalink":"http://sakurajiang.github.io/2016/11/10/RestAPP-fragment生命周期/","excerpt":"","text":"先说一下 之前我觉得v4包下的fragment和app下的fragment生命周期应该是一样的，结果不一样。 app包下的fragment生命周期开关屏幕时fragment的生命周期 直接在最开始使用add方法添加到activity后，fragemnt的生命周期 关闭屏幕后的生命周期: 打开屏幕后的生命周期: 销毁activity后的生命周期: 调用各个方法后fragment的生命周期当fragment1加载后，点击按钮后用add方法加载fragment2后生命周期: 调用remove方法后fragment生命周期： 调用attach后fragment的生命周期: 调用detach后fragment的生命周期: 调用replace加载fragment2后fragment2以及fragment1的生命周期 销毁activity后的生命周期: v4包下的fragment生命周期开关屏幕时的fragment生命周期 直接最开始使用add方法添加到activity后，fragemnt的生命周期 关闭屏幕后的生命周期: 打开屏幕后的生命周期: 销毁activity后的生命周期: 调用各个方法后fragment的生命周期当fragment1加载后，点击按钮后用add方法加载fragment2后生命周期: 调用remove方法后fragment生命周期 调用attach后fragment的生命周期: 调用detach后fragment的生命周期: 调用replace加载fragment2后fragment2以及fragment1的生命周期 总结1.显示fragment有add，attach，show。消失fragment有remove，detach，hide。第一次fragment要动态添加到activity中，必须使用add方法，增加到回退栈只能通过addToBackStack()方法。 2.调用add方法运行的生命周期是从onAttach到onResume，(app包下的fragment是从onCreate到onResume)，remove方法运行周期是onPause到onDetach，并且，都是先销毁再添加，即调用add方法的时候还调用了销毁的方法，那么都是先销毁再添加，但是由于v4下的fragment在add方法的时候会执行onAttach到onResume，就像我在上一篇博客(viewPager下fragment生命周期)中讲的一样，fragment的onAttach，onCreate都会在别的fragment的除了onAttach，onCreate之外的生命周期之前，所以，调用replace方法后的生命周期，v4下的fragment是这样，app下的fragment是那样。并且，在remove的时候调用 addToBackStack()方法，那么调用remove生命周期只会是onPause到onDestroyView。3.调用attach方法运行的生命周期是onCreateView到onResume ，detach方法运行生命周期是onPause到onDestroyView ，同时这两个谁先使用谁先调用，也就是那边的生命周期先走。这个方法的作用就是将fragment试图粘到UI试图中，而不是将fragment粘在activity上。4.调用show()和hide()方法不会运行声明周期。5.要想消失后正确的显示，必须调用与让其消失对应的方法，即如果你通过detach方法让fragment消失，那么就要用attach方法，别的都不行。对别的也是一样。6.因为fragment是依赖activity的，所以，activity先于fragment准备好，后于fragment消失，但是，v4下的fragment的onStart在activity的onstart之前，这一点，可以翻阅源码查看:v4下fragment的onStart源码: /** * Called when the Fragment is visible to the user. This is generally * tied to {@link Activity#onStart() Activity.onStart} of the containing * Activity&apos;s lifecycle. */ @CallSuper public void onStart() { mCalled = true; if (!mLoadersStarted) { mLoadersStarted = true; if (!mCheckedForLoaderManager) { mCheckedForLoaderManager = true; mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false); } if (mLoaderManager != null) { mLoaderManager.doStart(); } } } app下fragment的onStart源码 public void onStart() { throw new RuntimeException(&quot;Stub!&quot;); }","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-viewPager下fragment的生命周期","slug":"RestAPP-viewPager下fragment的生命周期","date":"2016-11-09T16:00:00.000Z","updated":"2020-07-06T09:32:15.149Z","comments":true,"path":"2016/11/10/RestAPP-viewPager下fragment的生命周期/","link":"","permalink":"http://sakurajiang.github.io/2016/11/10/RestAPP-viewPager下fragment的生命周期/","excerpt":"","text":"为什么写这个 在网上也有很多这个例子，但是感觉讲的都不很清楚，于是想自己跑一遍来看看整个过程，话不多说，下面就直接开始，我们知道ViewPager对fragment的管理其实是通过Adapter来管理的，下面我就分情况一一介绍，首先是Adapter继承FragmentPagerAdapter时的情况。 先吐槽一下我之前其实已经快写好了博客，但是，后面突然发现我设置Log的位置不对，设置在了super之前，这个时候方法还没执行完，只是开始执行，这时就会产生一些偏差，就是一点不同，就是在启动程序的时候的setUserVisibleHint()方法的执行时间上不同，如下: Log语句放在super之前 Log语句放在super之后 别的时候都是一样的。 以下的测试都是将Log语句放在super后面的时候的生命周期 当Adapter继承FragmentPagerAdapter 先上Adapter的代码 public class MyAdapter extends FragmentPagerAdapter{ public MyAdapter(FragmentManager fm) { super(fm); } @Override public int getCount() { return list.size(); } @Override public Fragment getItem(int position) { return list.get(position); } } 在我们使用的时候Adapter一般都是这么写的，测试的时候，我在viewpager中加了四个fragment，主要代码如下 myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(1); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(0); fragmentManager=getSupportFragmentManager(); 我们直接看结果：当程序启动的时候，生命周期如下： 当从第一个fragment滑到第二个fragment的时候 当从第二个滑到第三个的时候 当从第三个滑到第四个的时候 当从第四个滑到第三个的时候 当从第三个滑到第二个的时候 当从第二个滑到第一个的时候 由上图，我们可以得出，当程序执行的时候，viewpager加载fragment的顺序是，先onAttach当前的fragment，再向左遍历左边的fragment，遍历右完后，再向遍历，但这只是onAttach和onCreate的执行顺序，然后当OnCreateView和onActivityCreated的时候则是先遍历加载左边的，再遍历加载右边的，最后才是当前页。然后第一次的onStart、onResume的时候则是又按照onAttach和onCreate的顺序执行。为什么要说第一次的onStart、onResume，因为当屏幕关闭的时候，执行顺序还是按照OnCreateView和onActivityCreated的顺序，这里选的时间是从第一个fragment滑到第二个fragment之后，关闭屏幕，生命周期如下: 看到这里，估计很多人就很乱了，就想问fragment的加载顺序到底是什么呢？这时，我通过如下代码得到fragment的list表，代码如下: getfragmentList=getSupportFragmentManager().getFragments(); Log.e(&quot;log&quot;, &quot;getfragmentlist&quot; + getfragmentList); if(getfragmentList!=null) { for (int i = 0; i &lt;getfragmentList.size();i++) Log.e(&quot;log&quot;, &quot;getfragmentlist&quot; +i + getfragmentList.get(i)); } 这时，运行程序，加载完所有的fragment后的list顺序，如下： 由于屏幕原因，list中的后面看不到，但是通过for循环中的输出，还是可以看出fragment加载顺序其实是fragment2 fragment1 fragment3 fragment4，也就是onCreateView、onActivityCreated时的顺序，也就是说在onCreateView的时候建立了fragment的顺序，除了第一次，后面的生命周期都是按照这个顺序走的(除了滑动的时候)，就像上面的关闭屏幕时候的生命周期一样，细心的朋友可能注意到了图片后面的1 0 2 3，那这个是什么呢？这是各个fragment对应的下标，这个是你在list中添加fragment的顺序，如代码: public void addFragment(){ list.add(myfragment1); list.add(myfragment2); list.add(myfragment3); list.add(myfragment4); } 也就是fragemnt2对应1，fragemnt1对应0，fragemnt3对应2，fragemnt4对应3，这个顺序控制着fragment在页面中的顺序，也就是fragment1，fragment2，fragment3，fragment4。这里验证一下，修改代码，如下: public void addFragment(){ list.add(myfragment2); list.add(myfragment1); list.add(myfragment3); list.add(myfragment4); } 运行程序，加载完所有的fragment后的list的顺序，如下: 这里就是fragment1对应1，fragment2对应0，fragment3对应2，fragment4对应3，页面中的fragment顺序是fragment2，fragment1，fragment3，fragment4。 还是拿之前的在list中添加fragment的顺序来进行下面的测试，也就是fragemnt2对应1，fragemnt1对应0，fragemnt3对应2，fragemnt4对应3，即fragment在页面中的顺序，也就是fragment1，fragment2，fragment3，fragment4来继续说，因为我们设置了 viewPager.setCurrentItem(0);，所以我们先onAttach ，onCreate fragemnt1，又设置了 viewPager.setOffscreenPageLimit(1);，所以再onAttach ，onCreate fragemnt2，那么为什么先onCreateView onActivityCreated fragment2呢？这是因为viewpager的加载机制，会自动的将左右两边加载出来，所以，一下子就会加载两个，为了确保所有的view都创建，所以，将最开始要显示的view放在最后，即把fragment2的onCreateView，onActivityCreated放在fragment1的后面，那么，为什么fragment1的onStart，onResume先执行呢？这是为了用户体验，即将当前需要显示的先显示，因为这个时候是fragment1先显示。这里有一个奇怪的地方，就是第二个滑到第三个和第三个滑到第二个的图片，第二个滑到第三个的时候，fragment1是先执行onPause，onStop，onDestroy方法，再执行fragment4的onCreateView，onActivityCreated，onStart，onResume方法，而第三个滑到第二个的时候，则是先执行fragment1的onCreateView，onActivityCreated再执行fragemnt4的onPause，onStop，onDestroy方法，最后再执行onStart，onResume方法。为什么呢？这里先放一下，先验证上面的猜想，将代码修改一下 myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(2); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(1); fragmentManager=getSupportFragmentManager(); 结果如下：所以，这个顺序也验证了我们之前的想法，但是那个奇怪的地方还没解决，我们再修改代码： myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(1); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(1); fragmentManager=getSupportFragmentManager(); 程序运行结果如下： 因为我们显示的就是第二个页面，所以从第二个页面滑到第三个，效果如下： 从第三个滑到第二个，效果如下：我们再加载完所有的fragment，再从第二个滑到第三个试试，就是不执行onAttach和onCreate，这样看的舒服一点，结果如下： 可以看到，执行顺序其实是类似的。也就是，当fragemnt3滑到fragemnt2的时候，fragemnt1的onCreateView和onActivityCreated会在fragemnt4的onPause，onStop，onDestroyView，先执行，然后再执行fragment1的onStart，onResume，为什么呢？我觉得，为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管，当onAttach，onCreate之后，会先确定一个顺序，这里称为顺序2，也就是中左右，但是当onCreateView执行后，就确定了顺序3，这个顺序3就是getSupportFragmentManager().getFragments();得到的list的顺序，后面的生命周期(除了第一次启动以及左右滑动时的生命周期)都是按照这个顺序执行的，也就是左右中，为什么说除了第一次启动以及左右滑动时的生命周期，这里先说第一次启动，因为，在第一次启动后的onStart和onResume都是按照onAttach的顺序，而不是按照fragment的顺序，左右滑动的生命周期是按照你在viewPager中给添加fragment的顺序，这一点后面解释，确定了fragment顺序后，排在链表前面的fragment的方法肯定在排在后面的fragment方法之前，这一点很重要，举个例子，就比如上面的关闭屏幕那张生命周期图片，因为链表的顺序，所以生命周期会是这样。这里再解释上面的滑动顺序，这里贴上我添加fragment的代码 list.add(myfragment1); list.add(myfragment2); list.add(myfragment3); list.add(myfragment4); 可以看出顺序是fragment1，2，3，4。这个顺序就是顺序1，顺序1是在滑动的情况会用到。为什么我会将之前的顺序命名为顺序2，因为这个顺序是最开始你在程序中通过add(fragment)确定的顺序，在滑动的时候，谁在前面谁先生成视图或者先销毁，也就是谁在前面谁先执行，这里需要明确一点就是，任何fragment的第一部分生命周期肯定运行在别的fragment的除第一部分生命周期的生命周期前面，这一点很重要，同时还有一点，当既有fragment视图生成又有fragment视图销毁的时候，其实就是滑动的时候，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行，这里解释后面一点，修改代码: myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(1); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(3); 当第一次从3滑到2的时候生命周期如图: 因为顺序1是fragment1，2，3，4。所以应该是fragment1先执行第一部分，再执行第二部分生成视图，再fragment4执行销毁视图，再fragment1执行第三部分。但是结果却是这个，说明当既有fragment视图生成又有fragment视图销毁的时候，其实就是滑动的时候，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行。 看第二个滑到第三个，第三个滑到第二个这个情况，先看第一次第二个滑到第三个的情况，因为，任何fragment的第一部分生命周期肯定运行在别的fragment的除第一部分生命周期的生命周期前面，同时哦，对于生成视图的那个fragment的第一部分生命周期和第二部分的生命周期不会同时进行，又因为在顺序1中，fragment1在fragment4的前面，所以，fragment1先销毁，fragment4再生成和显示，所以，先执行fragment1的onAttach，onCreate，再执行fragment1的onPause，onStop，onDestroyView，再执行fragment4的onCreateView，onActivityCreated。而在第三个滑到第二个时，因为，不需要onAttach和onCreate，又因为在顺序1中，fragment1在fragment4的前面，所以，会先执行fragment1的onCreateView，onActivityCreated，再执行fragment4的onPause，onStop，onDestroyView。然后到显示的时候，再执行fragment1的onStart，onResume。为什么不会直接运行fragment1的onCreateView，onActivityCreated，onStart，onResume呢？因为viewPager.setOffscreenPageLimit(1);方法的限制，所以只有先将销毁视图的fragment的视图销毁，才能显示，所以接下来执行fragment4的onPause，onStop，onDestroyView，最后执行fragment1的onStart，onResume。然后，再一次从第二个滑到第三个的情况，因为，不需要onAttach和onCreate，又因为在顺序1中，fragment1在fragment4的前面，所以，fragment1先销毁，fragment4再生成和显示，所以，先执行fragment1的onPause，onStop，onDestroyView，再执行fragment4的onCreateView，onActivityCreated，onStart，onResume。这里可能有人会说，为什么不是按照顺序2来判断，因为在顺序2中，fragment1也是在fragment4之前呀，这里还是原来的代码: myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(1); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(3); 这时，顺序1是fragment1，2，3，4.而顺序2变成fragment4，3，2，1。这两个顺序中fragment1和fragment4顺序不一样，看从2滑到3的生命周期，如图： 因为fragment1先销毁fragment4再生成显示，所以是按照顺序1，不是顺序2。为了验证我的猜想，然后我去翻源代码，找了好久，但是没有找到，原谅我是个彩笔，如果有大神找到，请告诉我。不胜感激。 同时，这里还有一点，那就是setUserVisibleHint()方法执行的时间，这个方法不是属于生命周期的范围，我觉得这个方法调用的时间是如果是都要生成视图，也就是第一次显示的时候，那么就和onAttach的顺序是一样的，如果显示后移动的情况，那么看移动到当前位置时是否需要生成新的fragment视图，如果需要先生成，即先执行生成页的setUserVisibleHint()方法，然后再执行先前页的这个方法，在执行当前页的这个方法就像当从第二页滑到第三页的时候setUserVisibleHint()方法执行的顺序一样，即先执行fragment4的setUserVisibleHint()方法，再执行fragment2的setUserVisibleHint()方法，最后再是fragment3的setUserVisibleHint()方法。总的来说，为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管，，**顺序1是由viewpager中的添加fragment时设置的，顺序2是根据顺序1和viewPager.setCurrentItem();，以及viewPager.setOffscreenPageLimit(1);共同决定的，顺序2就是在顺序1中先找出viewPager.setCurrentItem()的fragment，然后向左遍历fragment，然后向右遍历fragment。这就是onAttach，onCreate的顺序，举个例子，顺序1是1，2，3，4。viewPager.setCurrentItem(0)，viewPager.setOffscreenPageLimit(1);，那么顺序2就是fragment2，1，3，4。如果viewPager.setCurrentItem(2)，viewPager.setOffscreenPageLimit(1);不变，顺序2就是2，3，4，1。如果是viewPager.setCurrentItem(2)，viewPager.setOffscreenPageLimit(2);，顺序2就是fragment2，1，4，3。顺序3也是顺序1和viewPager.setCurrentItem();，以及viewPager.setOffscreenPageLimit(1);共同决定的，只是先遍历viewPager.setCurrentItem();，再遍历viewPager.setCurrentItem();右边的，最后再 遍历viewPager.setCurrentItem();，顺序3使用最广泛，除了顺序1和顺序2，别的都是顺序3。更简单的说，为了便以理解，可以将fragment的生命周期分成四部分，第一部分就是onAttach，onCreate。第二部分是onCreateView，onActivityCreated。第三部分是onStart，onResume。第四部分就是onPause，onStop，onDestroyView。因为，fragmentPagerAdapter只会销毁视图，所以后面的onDestroy，onDetach就不用管记住几个规则: 1.有三个顺序，分别是顺序1，顺序2，顺序3。顺序1就是添加fragment的顺序，顺序2就是中左右，顺序3就是左右中。 2.第一次启动的时候，生命周期的第一，三部分按照顺序2，第二部分按照顺序3 3.滑动的时候按照顺序1，并且谁在前面谁先生成视图或者先销毁，也就是谁在前面谁先执行，但是，生命周期的第一部分和第二部分不会在一起执行。也就是说当生成视图的fragment在销毁视图的fragment之前，但是同时，生成视图的fragment的第一部分要执行，这时，执行顺序就是，生成视图的fragment的第一部分，销毁视图的fragment第四部分，生成视图的fragment的第二部分，第三部分。如果，这时，生成视图的fragment的第一部分不用执行，那么就会先执行生成视图的fragment的第二部分，当要执行第三部分的之后，由于viewPager.setOffscreenPageLimit(1);方法的限制，所以只有先将销毁视图的fragment的视图销毁，才能显示，所以第三部分没有直接跟着第二部分执行，而是最后执行。 4.剩下的时候都是按照顺序3，比如关闭屏幕，重新显示之类的。 5.因为setUserVisibleHint()这个方法，不算生命周期，所以这个执行的时间就是谁先显示谁先调用，并且，当isVisibleToUser为false的时候执行在第一部分之前，isVisibleToUser为true的时候执行在第一部分之后 说的很啰嗦，其实看图片的结果就知道了，为了验证上面的结果，我去翻源码，找了好久，但是没找到，原谅我水平不够，如果有大神找到的话，请告诉我，不胜感激。** 当Adapter继承FragmentStatePagerAdapter先上Adapter代码 public class MyAdapter extends FragmentStatePagerAdapter{ public MyAdapter(FragmentManager fm) { super(fm); } @Override public int getCount() { return list.size(); } @Override public Fragment getItem(int position) { return list.get(position); } } 程序主要代码如下： myAdapter=new MyAdapter(getSupportFragmentManager()); viewPager.setOffscreenPageLimit(1); viewPager.setAdapter(myAdapter); viewPager.setCurrentItem(0); fragmentManager=getSupportFragmentManager(); 程序运行结果： 第一个滑到第二个 第二个滑到第三个 第三个滑到第四个 第四个滑到第三个 第三个滑到第二个 第二个滑到第一个 第一个滑到第二个后按Pause 第一个滑到第二个后的fragemntList 第二个滑到第三个后的fragemntList 第三个滑到第二个后的fragmentList 从上图可以看出，跟FragmentPagerAdapter相比，FragmentStatePagerAdapter每次销毁的时候是直接remove，所以会在销毁之后重新显示的话，就会执行fragment的所有周期函数来显示。 FragmentPagerAdapter的destroyItem()方法 @Override public void destroyItem(ViewGroup container, int position, Object object) { if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, &quot;Detaching item #&quot; + getItemId(position) + &quot;: f=&quot; + object + &quot; v=&quot; + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object); } FragmentStatePagerAdapter的destroyItem()方法 @Override public void destroyItem(ViewGroup container, int position, Object object) { Fragment fragment = (Fragment) object; if (mCurTransaction == null) { mCurTransaction = mFragmentManager.beginTransaction(); } if (DEBUG) Log.v(TAG, &quot;Removing item #&quot; + position + &quot;: f=&quot; + object + &quot; v=&quot; + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) { mSavedState.add(null); } mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null); mCurTransaction.remove(fragment); } 注意最后两张图片中的list，分别有一个是空的，这也就说明，这里的fragment为空，但是依然占着位置，下次生成这个的时候，直接插入到这个位置，所以顺序2还是不会改变。同时，也没有后面的1 0 2 3，同时，上面划分的Fragment生命周期四部分也不一样，最后一部分应该再加上onDestroy，onDetach。生命周期的差异就体现在当有销毁又有生成fragment的视图的时候，这个时候跟FragmentPagerAdapter不一样，都是生成视图的fragment的第一部分先执行，再销毁视图的fragment去销毁视图，再生成视图的fragment显示。其实这就是上面的规则3。 当使用懒加载的时候呢？很明显生命周期会是一样的，因为设置懒加载的操作，并没有影响生命周期，所以生命周期是一样的，只是懒加载保证了显示哪页加载哪页的数据，有兴趣的朋友可以自己测试一下，毕竟纸上得来终觉浅，绝知此事要躬行。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-传递参数的单例模式","slug":"RestAPP-传递参数的单例模式","date":"2016-09-26T16:00:00.000Z","updated":"2020-07-06T09:33:11.719Z","comments":true,"path":"2016/09/27/RestAPP-传递参数的单例模式/","link":"","permalink":"http://sakurajiang.github.io/2016/09/27/RestAPP-传递参数的单例模式/","excerpt":"","text":"为什么懒汉式还存在单例模式我们在项目中会经常使用到，有常见的懒汉式、饿汉式,很多人搞不懂饿汉式既然既是线程安全的又是不需要线程同步，为什么还会存在懒汉式呢？存在即是合理，就论需要在构造函数中传递参数而言(当然这里的参数是不变的，如果参数是可变的，那么每次创建的对象都不一样，那么之前创建的对象都没用，违背了单例模式的设计初衷)，懒汉式做的就比饿汉式好。首先，我们以懒汉式为例，代码如下: 父类： public class Father { public Father(String s,int i){ System.out.println(&quot;s=&quot;+s); System.out.println(&quot;i=&quot;+i); } } 主函数: public class Main { public static void main(String[] args) { // TODO Auto-generated method stub testSon(); testSonB(); testSonC(); } public static void testSon(){ Son son=Son.getSonInstance(&quot;a&quot;, 1); } public static void testSonB(){ SonB sonb=SonB.getInstance(&quot;z&quot;, 2); } public static void testSonC(){ SonC sonc=SonC.getInstance(&quot;q&quot;, 3); } } 使用懒汉式的子类: public class Son extends Father{ private static Son son; private Son(String s, int i) { super(s, i); // TODO Auto-generated constructor stub } public static Son getSonInstance(String s,int i){ if(son==null){ synchronized (Son.class) { son=new Son(s,i); } } return son; } } 使用静态内部类方式的子类： public class SonB extends Father{ private static String s; private static int i; private SonB() { super(s, i); // TODO Auto-generated constructor stub } private static class LoadSonB { private static final SonB SONB_INTANCE=new SonB(); } public static SonB getInstance(String s1,int i1){ s=s1; i=i1; return LoadSonB.SONB_INTANCE; } } 使用饿汉式方式的子类: public class SonC extends Father{ private static String s; private static int i; public SonC() { super(s, i); // TODO Auto-generated constructor stub } private static SonC sonc=new SonC(); public static SonC getInstance(String s1,int i1){ s=s1; i=i1; return sonc; } } 输出结果: s=a i=1 s=z i=2 s=null i=0从上面的结果可以看出，懒汉式和静态内部类的方式都可以在构造函数中像父构造函数传递值，而饿汉式不行，为什么？因为静态内部类在类加载的时候不会加载，静态内部类和非静态内部类一样，都是在被调用时才会被加载，而静态变量、静态方法、静态块都是在类加载的时候就已经”准备好了”,也就是可以被使用或者已经被执行，所以使用静态内部类方式的时候可以，因为，类加载的时候静态内部类还没加载，所以构造函数还没运行，当静态内部类被调用时，参数已经被赋值了，所以可以。而使用饿汉式，由于sonc属于static变量，而且在声明的时候new了，那时参数还没有赋值时，构造函数已经被调用了，所以不行。如果不能理解这里，可以看http://www.cnblogs.com/zhguang/p/3154584.html。 那么如果使用饿汉式怎么办呢？答案是办不到，因为饿汉式需要在类加载的时候就生成对象，那个时候无法传递参数。当然，如果传递参数不是发生在构造函数中，那么就可以使用饿汉式，代码如下: public class SonD { private static String s; private static int i; public SonD() { // TODO Auto-generated constructor stub String s2=s; System.out.println(&quot;s2&quot;+s2); } private static SonD sond=new SonD(); public static SonD getInstance(String s1,int i1){ s=s1; i=i1; System.out.println(&quot;s1=&quot;+s); System.out.println(&quot;i1=&quot;+i); System.out.println(&quot;get&quot;); return sond; } } 主函数: public class Main { public static void main(String[] args) { // TODO Auto-generated method stub testSonD(); } public static void testSonD(){ SonD sond=SonD.getInstance(&quot;m&quot;, 4); } } 运行结果: s2null s1=m i1=4 get 为什么这里s2=null呢？因为s是static，而且在声明的时候直接new了，所以值是null，因此，我们使用饿汉式的时候传递值是不能在构造函数中进行的，而要在别的地方，比如类SonD中的getInstance()方法中就行，这样就实现了使用饿汉式传递参数，不过注意这里的传递参数不是发生在构造函数中的，如果是构造函数需要传入参数，就要使用懒汉式，而且，使用饿汉式传递参数，不能在构造函数中传递(类SonD的输出结果证实这一点)，现在是不是有些理解懒汉式为什么存在呢？其实，综上所述，使用单例模式的时候，最好使用内部类的方式来实现。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货","slug":"RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货","date":"2016-09-21T16:00:00.000Z","updated":"2020-07-06T09:32:56.339Z","comments":true,"path":"2016/09/22/RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货/","link":"","permalink":"http://sakurajiang.github.io/2016/09/22/RestAPP-一款MVVM设计模式的Gank.io客户端——小憩干货/","excerpt":"","text":"先给客官来几张项目部分截屏主页面 搜索页面 搜索结果页面 大图页面 为什么写这个客户端？ 我学习android也有一年多了，都说项目才是检验自己学习成果的最好方式，正好最近学习Material Design, RxJava &amp; Retrofit框架和MVVM设计架构也有一段时间了，正好，网络上有gank.io这个免费接口，虽然已经有不少人写过这个客户端，但是没有一个是用MVVM设计架构的，于是我便写了这个项目。这个项目是我的第一个上线项目，可以查看图片，视频，技术文章等，支持收藏，搜索等，界面是仿网易云音乐，用户可以选择观看模式和摇一摇模式，界面简洁大方，操作简单易懂。到现在，这是第一个也是唯一一个使用MVVM设计架构的Gank.io客户端，想想还是挺有成就感的。 这个项目用了什么？ 项目使用了Material Design, RxJava &amp; Retrofit框架和MVVM设计模式，图标是使用svg和icon.用的都是最新的东西。图片的加载是用picasso,显示是使用RecyclerView，控件用的几乎都是Material Design，并且遵从Material Design规格要求，使得整个界面看起来很有Material Design风格，页面架构采用的是少activity多fragment，减少资源的消耗和更快的响应页面间切换和交互，使得用户体验更好。 为什么用这些？ 关于这个问题，我先回答我特别喜欢RxJava和MVVM，先说RxJava，这个其实主要是为了解决异步问题，特别是对handler厌烦的人而言，RxJava的出现实在是太及时了，RxJava不算一种框架，它不能拿来就使用，但是它特别好，因为它所实现的大概就是，你输入一个东西，然后输出你想要的东西，这么说可能很宽泛，举个例子，比如在这个项目中，你的输入是通过Retrofit得到的数据，而这个数据是一个类，但是你只想要其中的url，怎么办？RxJava就可以，你只需要使用map操作符就可以(当然在这个项目中我没有这么写，因为我不只是想得到url)，而使用Retrofit就是因为它对RxJava进行了很好的支持，当然，它本身也很方便。然后就是MVVM了，这个框架也出现一阵子了，对于使用这个框架，就不得不介绍Data Binding Library这个库了，这个库和mvvm一起使用，简直爽的不行，Data Binding Library这个库能让你在xml中进行数据绑定，在没有使用这个库之前，每次我们写xml都只是为了加载一个布局，除了这个功能，xml几乎没有别的作用，这样就让代码变得复杂、繁琐。那么如何使用这个库呢？我的建议是去官网，当然至于如何翻墙，我就不说了，毕竟僧多肉少(#阴险)，如果不会翻墙或者不想看英文的同学，这里我推荐去看简书。 而对于为什么Material Design，只能说，谁用谁知道，毕竟是官方的东西。 你能从这个项目中学到什么？ 1.RxJava和Retrofit结合进行网络请求，以及如何将请求和ProgressDialog结合，也就是展示网络请求的过程。 2.如何更好的在项目中使用Data Binding Library这个库来实现MVVM设计架构。 3.如何实现少Activity多Fragment页面架构，以及如何在一个Fragment中更好的嵌套另一个Fragment。 4.在Viewpager下更好的使用Fragment，以及多重ViewPager嵌套下，各个Fragment的处理方式，几乎涵盖了Fragment的各种使用方式以及和activity交互方式，比如，优雅的控制让Fragment自己决定处理返回事件还是让activity来处理。 5.一些简单的自定义View，比如自定义Edittext实现带有清除效果的搜索框。 6.Material Design库中绝大部分控件的使用，遵从Material Design规格要求，使得整个界面看起来很有Material Design风格。 7.如何让RecyclerView和Data Binding Library更好的结合。 8.如何更好的封装程序以及继承，让业务层和逻辑层更好的分离。 9.这个项目用的都是最新最火的框架和设计模式，所以你以后肯定会用到，而且在很长的时间里都不会有”过期”这一说(当然，知识是没有过期这一说法的，原谅我语文不好)。 10.我现在大四，也就意味着我有很多自由的时间，如果你在看我项目的时候遇到任何问题都可以和我联系，我会尽快给你回复，而且由于我技术比较菜(#谦虚)，所以没有专家盲点(指对一个事务知道的越多，就越发不记得”不知道这个事”的情形)，也就能更好的回答你们的问题(第一次将自己技术菜说的这么清新脱俗#害羞)。 地址: Github：https://github.com/sakurajiang/RestAPP 应用宝 :http://sj.qq.com/myapp/detail.htm?apkName=com.example.jdk.restapp 最后 欢迎各位客官多多光临我的Github，喜欢这个项目的同学可以star一下，不胜感激，你的star是对我的肯定和鼓励(#调皮)。 目前我只放在了应用宝上，喜欢的可以下载支持下，不方便在应用宝下载的，在Github上还有直接下载地址。 如果你看到了这里，说明你已经看完这篇博客了，谢谢各位花时间看这篇博客，最后再来几张截屏，Good luck！ 摇一摇页面 抽屉页面 关于作者页面","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-如何制作app图标以及logo","slug":"RestAPP-如何制作app图标以及logo","date":"2016-09-18T16:00:00.000Z","updated":"2020-07-06T09:33:53.964Z","comments":true,"path":"2016/09/19/RestAPP-如何制作app图标以及logo/","link":"","permalink":"http://sakurajiang.github.io/2016/09/19/RestAPP-如何制作app图标以及logo/","excerpt":"","text":"第一步：制作一个图标 怎么制作呢？这里给大家推荐一个网站http://www.logoko.com.cn/，在这里你可以简单的制作一个图标，操作简单，一看就会。这里以我生成的一个图片为例: 这里生成的图片在最下面会有广告，我们需要自己再截图一次，毕竟是免费的，可以理解。 第二步：将图标变成圆角 为什么要变成圆角？因为现在主流的app都是圆角图标，这里依然给大家推荐一个网站http://www.roundpic.com/，在这里只需要将图片上传到这个网站，就可以制作出圆角图片，操作简单，一看就会。这里依然以我生成的图片为例: 第三步：生成各个分辨率的图标 这里依然是一个网站http://icon.wuruihong.com/，将图片上传到这个网站就可以了，这里已android为例，如果不自定义尺寸，就会生成七个不同分辨率的图片，这七个就是android需要的，同时还支持预览。这里最后会是一个压缩包。 显示在手机上最后的样子: 是不是感觉特别简单，这三个网站都不用注册哟，赶快尝试一下吧！","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框","slug":"RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框","date":"2016-09-16T16:00:00.000Z","updated":"2020-07-06T09:34:08.050Z","comments":true,"path":"2016/09/17/RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框/","link":"","permalink":"http://sakurajiang.github.io/2016/09/17/RestAPP-如何通过自定义EditText来得到一个类似网易云音乐的带有清除功能的搜索框/","excerpt":"","text":"运行效果: 先上代码，等会讲解: 自定义的EditTexT类如下: public class CustomClearAndSearechEdittext extends EditText implements View.OnFocusChangeListener,TextWatcher{ private Drawable mClearDrawable; /** * 控件是否有焦点 */ private boolean hasFoucs; public OnClickSearchListener mOnClickSearchListener; public interface OnClickSearchListener{ public void onClickSearch(); } public void setOnClickSearchListener(OnClickSearchListener onClickSearchListener){ this.mOnClickSearchListener=onClickSearchListener; } public CustomClearAndSearechEdittext(Context context) { this(context, null); } public CustomClearAndSearechEdittext(Context context, AttributeSet attrs) { super(context, attrs); init(context); } public CustomClearAndSearechEdittext(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } private void init(final Context context) { //获取EditText的DrawableRight,假如没有设置我们就使用默认的图片 final Drawable drawable = ContextCompat.getDrawable(context, R.drawable.abc_ic_clear_mtrl_alpha); setTextColor(getCurrentHintTextColor()); mClearDrawable=drawable; mClearDrawable.setBounds(0, 0, mClearDrawable.getIntrinsicWidth()+10, mClearDrawable.getIntrinsicHeight()+10); //默认设置隐藏图标 setClearIconVisible(false); //设置焦点改变的监听 setOnFocusChangeListener(this); //设置输入框里面内容发生改变的监听 addTextChangedListener(this); } /** * 当手指抬起的位置在clean的图标的区域 * 我们将此视为进行清除操作 * getWidth():得到控件的宽度 * event.getX():抬起时的坐标(该坐标是相对于控件本身而言的)，可以理解成距离左边框的距离 * getTotalPaddingRight():clean的图标左边缘至控件右边缘的距离 * getPaddingRight():clean的图标右边缘至控件右边缘的距离 * 于是: * getWidth() - getTotalPaddingRight()表示: * 控件左边到clean的图标左边缘的区域 * getWidth() - getPaddingRight()表示: * 控件左边到clean的图标右边缘的区域 * 所以这两者之间的区域刚好是clean的图标的区域 */ @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_UP) { if (getCompoundDrawables()[2] != null) { boolean searchable=event.getX()&gt;((getWidth()-getPaddingRight()+80)); boolean touchable = event.getX() &gt; (getWidth() - getTotalPaddingRight()) &amp;&amp; (event.getX() &lt; ((getWidth() - getPaddingRight()))); if (touchable) { this.setText(&quot;&quot;); } if(searchable&amp;&amp;mOnClickSearchListener!=null){ Toast.makeText(getContext(),&quot;search&quot;,Toast.LENGTH_SHORT).show(); mOnClickSearchListener.onClickSearch(); } } } return super.onTouchEvent(event); } /** * 当ClearEditText焦点发生变化的时候，判断里面字符串长度设置清除图标的显示与隐藏 */ @Override public void onFocusChange(View v, boolean hasFocus) { this.hasFoucs = hasFocus; if (hasFocus) { setClearIconVisible(getText().length() &gt; 0); } else { setClearIconVisible(false); } } /** * 设置清除图标的显示与隐藏，调用setCompoundDrawables为EditText绘制上去 * @param visible */ protected void setClearIconVisible(boolean visible) { Drawable right = visible ? mClearDrawable : null; setCompoundDrawables(getCompoundDrawables()[0], getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]); } /** * 当输入框里面内容发生变化的时候回调的方法 */ @Override public void onTextChanged(CharSequence s, int start, int count, int after) { if(hasFoucs){ setClearIconVisible(s.length() &gt; 0); } } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void afterTextChanged(Editable s) { } } XML文件如下: &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tool_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?actionBarSize&quot; android:background=&quot;@color/themeColor&quot; app:contentInsetStart=&quot;0.0dp&quot; app:layout_scrollFlags=&quot;enterAlways|scroll&quot; app:theme=&quot;@style/ToolbarStyle&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/search_til&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;com.jdk.gank.restapp.CustomizedWidget.CustomClearAndSearechEdittext android:id=&quot;@+id/search_et&quot; android:hint=&quot;输入搜索内容&quot; android:inputType=&quot;text&quot; android:singleLine=&quot;true&quot; android:imeOptions=&quot;actionSearch&quot; android:paddingRight=&quot;70dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; &lt;ImageView android:id=&quot;@+id/search_iv&quot; android:layout_width=&quot;30dp&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@mipmap/search&quot; android:gravity=&quot;center_vertical&quot; android:textSize=&quot;25dp&quot;/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.Toolbar&gt; 在fragment中使用: public class WatchAndShakeFragment extends Fragment implements CustomClearAndSearechEdittext.OnClickSearchListener{ @Bind(R.id.search_tv) ImageView search_iv; @Bind(R.id.search_til) TextInputLayout textInputLayout; @Bind(R.id.search_et) EditText editText; public static WatchAndShakeFragment newInstance(){ if( watchAndShakeFragment ==null){ watchAndShakeFragment =new WatchAndShakeFragment(); } return watchAndShakeFragment; } public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { if(v!=null){ ButterKnife.bind(this,v); return v; } v=inflater.inflate(R.layout.fragment_watch_shake,container,false); ButterKnife.bind(this, v); ((AppCompatActivity)getActivity()).setSupportActionBar(toolbar); actionBar= ((AppCompatActivity)getActivity()).getSupportActionBar(); editText.setFocusable(true); editText.setFocusableInTouchMode(true); ((CustomClearAndSearechEdittext)editText).setOnClickSearchListener(this); toolbar.setNavigationIcon(R.drawable.ic_back_28dp); toolbar.setNavigationOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { actionBar.setDisplayHomeAsUpEnabled(false); toolbar.setNavigationIcon(null); editText.setFocusable(false); editText.setFocusableInTouchMode(false); } }); return v; } } } 下面是讲解: 其实主要讲的就是CustomClearAndSearechEdittext类，在这个类中完成所有的功能，继承一个EditText，然后在EditText中设置图片，首先我们得到图片，然后我们调用mClearDrawable.setBounds(0, 0, mClearDrawable.getIntrinsicWidth()+10, mClearDrawable.getIntrinsicHeight()+10);这个方法来提供画图片的画布，这个意思就是说，这个图片后面是画在这个地方的，值得注意是我们可以在这里设置图片的大小，但是不能设置图片的位置，比如，我这里就是在图片原来的基础上增加了10，之前我也一直想着在这里设置位置，但是行不通，然后我想着通过onDraw()重新将图片画上去，但是太麻烦，那么我们如何设置图片的位置呢？很简单，就是在xml里，因为我们的清除图片是在右侧，所以，我们设置android:paddingRight=&quot;70dp&quot;来控制图片的位置，因为这个图片我们是通过 protected void setClearIconVisible(boolean visible) { Drawable right = visible ? mClearDrawable : null; setCompoundDrawables(getCompoundDrawables()[0], getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]); } 来显示的，主要就是 setCompoundDrawables(getCompoundDrawables()[0], getCompoundDrawables()[1] ,right, getCompoundDrawables()[3]);也就是说，我们是将右边的图片画上去了，别的地方都没有图片，也就是说，这个图片其实是EditText中的，所以我们可以通过android:paddingRight=&quot;70dp&quot;来控制图片的位置，这里清除图片设置好了，接下来，就是设置事件了，我们重写onTouchEvent(MotionEvent event)方法来设置事件，在上面的代码的注释中已经写的很详细了，我就不写了，接下来就是设置搜索的事件了，由于搜索的按钮是在EditText中(由我们的布局知道)，所以我们也需要通过重写onTouchEvent(MotionEvent event)方法来设置事件，也就是当我们按下的坐标大于搜索框到屏幕左边的距离时，就会触发onTouch事件，然后我设置了回调来处理这个事件。整个过程也解析完了，其实挺简单。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-RestAPP开发总结","slug":"RestAPP-RestAPP开发总结","date":"2016-08-22T16:00:00.000Z","updated":"2020-07-06T09:32:00.921Z","comments":true,"path":"2016/08/23/RestAPP-RestAPP开发总结/","link":"","permalink":"http://sakurajiang.github.io/2016/08/23/RestAPP-RestAPP开发总结/","excerpt":"","text":"为什么做这个APP终于做完这个APP了，大概花了我20天，这个APP的功能的确很简单，我也不知道为什么会花这么久，之所以想着做这个APP，是因为我想将这三个RxJava、Retrofit和MVVM模式放在一起使用。 为什么使用这三者关于这个问题，我先回答我特别喜欢RxJava和MVVM，先说RxJava，这个其实主要是为了解决异步问题，特别是对handler厌烦的人而言，RxJava的出现实在是太及时了，RxJava不算一种框架，它不能拿来就使用，但是它特别好，因为它所实现的大概就是，你输入一个东西，然后输出你想要的东西，这么说可能很宽泛，举个例子，比如在这个项目中，你的输入是通过Retrofit得到的数据，而这个数据是一个类，但是你只想要其中的url，怎么办？RxJava就可以，你只需要使用map操作符就可以(当然在这个项目中我没有这么写，因为我不只是想得到url)，而使用Retrofit就是因为它对RxJava进行了很好的支持，当然，它本身也很方便。然后就是MVVM了，这个框架也出现一阵子了，对于使用这个框架，就不得不介绍Data Binding Library这个库了，这个库和mvvm一起使用，简直爽的不行，Data Binding Library这个库能让你在xml中进行数据绑定，在没有使用这个库之前，每次我们写xml都只是为了加载一个布局，除了这个功能，xml几乎没有别的作用，这样就让代码变得复杂、繁琐。那么如何使用这个库呢？我的建议是去官网，当然至于如何翻墙，我就不说了，毕竟僧多肉少(#阴险)，如果不会翻墙或者不想看英文的同学，这里我推荐去看简书。 从这个APP能学到什么关于这个，我只能说我也是刚接触这三者没多久，由于专家效应，所以我觉得我写可能更适合初学者去看看，看一下刚接触这个应该怎么写，然后自己再试着改进，而不是直接去看别人写好的，毕竟，纸上得来终觉浅，觉知此事要躬行，这样就能学到更多的东西。其实大家主要就是要看RecyclerViewDataBindingAdapter这个Adapter和那几个Fragment，以及对应的xml文件，特别是RecyclerViewDataBindingAdapter。 做完这款APP的反思关于这个问题，首先从布局上来考虑，由于我一开始不知道自己想做曾什么样子，只知道大概什么样子，然后想着边做边改，但是写着写着，我就后悔了，因为到最后发现有很多界面的布局类似，而我没有将这些布局整合成一个，而是写了好几个，而改的话又要重新制定，因为对于mvvm模式，使用include标签会比较困难，因为是将数据绑定直接绑定在xml中，而要使用include标签就会比较困难了。所以在做一个APP之前应该先想好这个APP具体该做成什么样子，而不能边做边看，想着能将一些好看的view加进去。然后就是对于使用mvvm的反思，由于这个APP有显示网络图片的功能，而一开始我看mvvm没有看那么仔细，结果导致我不知道如何使用Data Binding Library达到通过一个url给image设置图片，然后我就新建了一个Adapter，然后写完之后，我又看着很不爽，我就想着能把这两个整合到一起，于是我又回去重新看一遍Data Binding Library，结果发现自定义一个setter可以达到这个效果，于是我就将两者整合到一起，顺便将这个Adapter封装成自己的一个小框架，以后使用RecyclerView和Data Binding Library可以直接拿这个Adapter了(窃喜)，所以，我们应该在做一个项目前，将项目所需要的主要的技术都认真看一遍，而不能想着边做项目边学，因为如果这样，由于你的项目不单单是使用一个技术，所以在使用的时候，可能会因为整个项目太大，而不适合去在这个项目中练习如何使用这个框架，如果你重新建一个项目专门去练习使用这个框架(假设你那时还有另开一个专门练习这个框架的项目的心情，因为那时你往往只会想着去解决这个问题，而不会另开一个项目，而由于你是在一个项目中使用这个框架，而你对这个框架又不熟悉，那么你碰到的问题，可能就不只是单单这个框架的问题，还有可能跟框架结合这个项目有关系，那时候你可能在网上找不到答案)，由于你还做着这个项目，你就不会有那份认真的去练习这个框架，那样需要的时间可能就会很久，而且，你对这些框架不熟悉，当你整合到一起的时候，可能会出现各种bug，而那个时候你往往没有那份认真调试的心情，因为你对这些都不熟悉，然后就会比较虚，不知道如何下手。最后一个反思就是，一定要学会科学的、理性的进行调试，遇到问题google以及stackoverflow。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-webview和其他控件混合使用","slug":"RestAPP-webview和其他控件混合使用","date":"2016-08-22T16:00:00.000Z","updated":"2020-07-06T09:32:30.656Z","comments":true,"path":"2016/08/23/RestAPP-webview和其他控件混合使用/","link":"","permalink":"http://sakurajiang.github.io/2016/08/23/RestAPP-webview和其他控件混合使用/","excerpt":"","text":"当我们使用webview的时候，我们会经常的和其他控件一起使用，那么如何让webview适应布局呢？直接上代码: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/webview_linearlayout&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_weight=&quot;11&quot; android:layout_height=&quot;0dp&quot;&gt; &lt;WebView android:id=&quot;@+id/show_webview_wv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt;&lt;/WebView&gt; &lt;/LinearLayout&gt; &lt;RelativeLayout android:layout_weight=&quot;1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot;&gt; &lt;TextView android:id=&quot;@+id/count_tv&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;ImageButton android:id=&quot;@+id/interest_ib&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_toRightOf=&quot;@id/count_tv&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; 这就是布局文件，至于剩下的我就不需要再写了，主要就是布局，这里再提一下一个大坑，如果你将webview的高度android:layout_height=&quot;wrap_content&quot;换成 android:layout_height=&quot;match_parent&quot;你会发现下面的控件在最开始的时候有抖动的现象，这就很影响体验了，我之前也是出了这个毛病，果断不能忍，于是去看代码，查看是哪里重新刷新了布局，结果一直调试，花了好久，结果就是然并卵，最后我就尝试着将高度变成wrap_content，然后出乎意料就好了，那么到底为什么呢？答案是跟这两个没关系(我也是后来为了整明白这个才发现的)，之所以出现跳动，是因为我之前设置了显示webview的activity是全屏，而启动它的activity不是全屏，跳动是因为由一个非全屏的activity调到一个全屏的activity，而尴尬的是我还没发现好的解决办法，但是，以后如果碰到webview和activity全屏的问题，如果出现抖动，一定要注意。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-使用SQLite遇到的一个问题","slug":"RestAPP-使用SQLite遇到的一个问题","date":"2016-08-22T16:00:00.000Z","updated":"2020-07-06T09:33:38.962Z","comments":true,"path":"2016/08/23/RestAPP-使用SQLite遇到的一个问题/","link":"","permalink":"http://sakurajiang.github.io/2016/08/23/RestAPP-使用SQLite遇到的一个问题/","excerpt":"","text":"我们都知道SQLite是不允许插入空行的，但是很多时候我们对于插入的数据是不知道的，其中可能就会有没有值，然后就造成空行，那么我们如何判断呢？很多人说只要我们将得到的数据重新整理一遍就好了，一旦为空就给他赋值，我也是这么想的，结果悲剧了，下面直接出代码: public URLTableData setUrlTableData(URLTableData urlTableData){ if(urlTableData.getUrl().length()&lt;=0){ urlTableData.setUrl(&quot;该链接不存在&quot;); } if(urlTableData.getWho().equals(null)){ urlTableData.setWho(&quot;佚名&quot;); } if(urlTableData.getDesc().equals(null)){ urlTableData.setDesc(&quot;不存在&quot;); } if(urlTableData.getCreatedAt().toString().length()&lt;=0){ urlTableData.setCreatedAt(null); } return urlTableData; } public ContentValues CreatParms(URLTableData urlTableData) { setUrlTableData(urlTableData); ContentValues _ContentValues = new ContentValues(); _ContentValues.put(&quot;URLValue&quot;,urlTableData.getUrl()); _ContentValues.put(&quot;URLCreateAt&quot;,ChangeTimeFormat.changeToYearMonthDay(urlTableData.getCreatedAt())); _ContentValues.put(&quot;URLWho&quot;,urlTableData.getWho()); _ContentValues.put(&quot;URLDesc&quot;,urlTableData.getDesc()); return _ContentValues; } public Boolean insertToURLTable(URLTableData urlTableData) { ContentValues _ContentValues = CreatParms(urlTableData); Long p_NewID = getMySqLiteDatabase().insert(getTable(), null, _ContentValues); urlTableData.set_id(p_NewID.intValue()); return p_NewID &gt; 0; } 这里的三个函数我解释一下大概什么意思，第一个是给得到的数据重新赋值，第二个是设置ContentValues，第三个是执行插入。但是每次数据插入都不成功，然后我进行调试，发现每次都是运行到 if(urlTableData.getWho().equals(null)){ urlTableData.setWho(&quot;佚名&quot;); } 这条语句就出现异常(我捕获了异常)，其中我的urlTableData.getWho()得到的who是空的，然后再调用equal()方法就出现了异常，那么我们应该怎么判断呢？既然知道了原因，那么其实就很简单,只要将上面的第一个函数setUrlTableData(URLTableData urlTableData)改成下面这样: public URLTableData setUrlTableData(URLTableData urlTableData){ if(urlTableData.getUrl()==null){ urlTableData.setUrl(&quot;该链接不存在&quot;); } if(urlTableData.getWho()==null){ urlTableData.setWho(&quot;佚名&quot;); } if(urlTableData.getDesc()==null){ urlTableData.setDesc(&quot;不存在&quot;); } if(urlTableData.getCreatedAt().toString()==null){ urlTableData.setCreatedAt(null); } return urlTableData; } 这样就好了嘛，当然如果是单个数据插入，而不是整个对象插入，就可以通过设置insert(参数)方法来设置，这里就不赘述了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"RestAPP-使用recyclerView遇到的一些问题","slug":"RestAPP-使用recyclerView遇到的问题","date":"2016-08-22T16:00:00.000Z","updated":"2020-07-06T09:33:27.394Z","comments":true,"path":"2016/08/23/RestAPP-使用recyclerView遇到的问题/","link":"","permalink":"http://sakurajiang.github.io/2016/08/23/RestAPP-使用recyclerView遇到的问题/","excerpt":"","text":"在使用RecyclerView时，突然发现数据无法显示出去在使用RecyclerView时，突然发现数据无法显示出去，遇到这种情况可以看看传入的数据是否为空，如果为空，是不会显示任何东西的。因为传入的数据为空，不会调用onCreateViewHolder(参数)方法，自然也不会调用onBindViewHolder(参数)方法，所以你上面就不会有任何的显示，即使你在item的布局中就给了每个控件初始的值，就像下面这样: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#ff0000&quot;&gt; &lt;ImageView android:id=&quot;@+id/meizi_imageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:id=&quot;@+id/video_TextView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hhh&quot;/&gt; &lt;/LinearLayout&gt; 即使这样依然不会显示出来，因为都没有调用onCreateViewHolder(参数)方法来显示item，什么时候调用onCreateViewHolder(参数)方法呢？看下面这句话Called when RecyclerView needs a new RecyclerView.ViewHolder of the given type to represent an item.，也就是说当RecyclerView需要一个新的给定类型的ViewHolder来描绘一个item时才会调用。那么我们想即使传入的数据为空时，也要将自己的item显示出来，那么我们应该怎么办呢？代码如下: /** * Created by JDK on 2016/8/4. */ public class AdapterRecyclerViewMeizi extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;{ private Context mContext; private MyViewHolder myViewHolder; private List&lt;Meizi&gt; meiziList; public AdapterRecyclerViewMeizi(Context context,List&lt;Meizi&gt; meiziList) { this.mContext=context; this.meiziList=meiziList; } public LayoutInflater getInflater(){ return LayoutInflater.from(mContext); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if(viewType==-1){ View v=getInflater().inflate(R.layout.meizi_item,parent,false); return new MyEmptyViewHolder(v); } View v=getInflater().inflate(R.layout.meizi_item,parent,false); myViewHolder=new MyViewHolder(v); return myViewHolder; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if(holder instanceof MyViewHolder) { Log.i(&quot;Logcat&quot;, &quot;onBindViewHolder&quot; + meiziList.get(position).url); Picasso.with(mContext).load(meiziList.get(position).url).into(((MyViewHolder)holder).meiziImage); } } @Override public int getItemCount() { return meiziList.size()&gt;0?meiziList.size():1; } @Override public int getItemViewType(int position) { if(meiziList.size()&lt;=0){ return -1; } return super.getItemViewType(position); } class MyViewHolder extends RecyclerView.ViewHolder { ImageView meiziImage; TextView videoText; public MyViewHolder(View itemView) { super(itemView); Log.i(&quot;Logcat&quot;, &quot;MyViewHolder&quot;); meiziImage= (ImageView) itemView.findViewById(R.id.meizi_imageView); videoText= (TextView) itemView.findViewById(R.id.video_TextView); } } class MyEmptyViewHolder extends RecyclerView.ViewHolder{ public MyEmptyViewHolder(View itemView) { super(itemView); } } } 这里解释一下getItemViewType(参数)这个方法，先看原话:Return the view type of the item at position for the purposes of view recycling.，也就是说这个方法返回的是position位置的item的View的类型，这样做的目的是view回收，这个方法默认返回的是0，我们在这里给他复写，当传入的数据为空时，就返回-1，然后再在 onCreateViewHolder(参数)判断，当然我们也可以根据传入的数据为空这个条件来判断，也就是meiziList.size=0来判断；同时注意一下这里的getItemCount(参数)方法，这个方法返回的是item的总数目。如果我们按正常的方式写，也就是return meiziList.size();，那么还是不会显示，所以感觉onCreateViewHolder(参数)是根据getItemCount(参数)方法返回的值来判断的。根据上面的这些代码，我们可以这样来设置自己的RecyclerView，也就是说当传入的数据为零时，我们显示的内容就是:没有传入任何数据，创建布局文件meizi_none_item，代码如下: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:textColor=&quot;#ff0000&quot; android:textSize=&quot;30sp&quot; android:text=&quot;@string/meizi_none_item&quot;/&gt; &lt;/LinearLayout&gt; 然后将上面的 if(viewType==-1){ View v=getInflater().inflate(R.layout.meizi_item,parent,false); return new MyEmptyViewHolder(v); } 修改成 if(viewType==-1){ View v=getInflater().inflate(R.layout.meizi_none_item,parent,false); return new MyEmptyViewHolder(v); } 这样结果如图: 在mvvm中使用RecyclerView进行数据绑定在这里需要提一下，再在对item的布局文件进行数据绑定时，一定要记住对于variable的name命名一定不能有_，要比较正常的生命变量，如果你的声明如下: &lt;data&gt; &lt;variable name=&quot;android_meizi&quot; type=&quot;com.example.jdk.restapp.ModelData.entity.Meizi&quot;/&gt; &lt;/data&gt; 这里对name的命名就是android_meizi，这个时候就会报下面的错误: 我是按照this来实现mvvm中使用RecyclerView，因为这个问题，我整了好久，最后实在没办法，我就尝试着改名字，最后是这样的: &lt;data&gt; &lt;variable name=&quot;androidMeizi&quot; type=&quot;com.example.jdk.restapp.ModelData.entity.Meizi&quot;/&gt; &lt;/data&gt; 不说了，我哭会去。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"RestApp","slug":"RestApp","permalink":"http://sakurajiang.github.io/tags/RestApp/"}],"keywords":[]},{"title":"做AA项目时的一些封装心得以及一些技巧","slug":"AA-做AA项目时的一些封装心得及一些技巧","date":"2016-08-03T16:00:00.000Z","updated":"2020-07-06T09:13:06.901Z","comments":true,"path":"2016/08/04/AA-做AA项目时的一些封装心得及一些技巧/","link":"","permalink":"http://sakurajiang.github.io/2016/08/04/AA-做AA项目时的一些封装心得及一些技巧/","excerpt":"","text":"如果你想整个应用程序只有一个你创建的某个类的对象时，可以采用如下的技巧在你创建的类中，将构造函数的属性设置为私有，然后再定义一个静态方法给外部使用，也就是单例模式，具体代码如下: public class SQliteDataBaseConfig { private static final String AA_DATABASE_NAME=&quot;my_aa_database_name&quot;; private static final int AA_DATABASE_VERSION=1; private static SQliteDataBaseConfig sQliteDataBaseConfig_instance; private SQliteDataBaseConfig(){ } public static SQliteDataBaseConfig getsQliteDataBaseConfig_instance(){ if (sQliteDataBaseConfig_instance==null){ sQliteDataBaseConfig_instance=new SQliteDataBaseConfig(); } return sQliteDataBaseConfig_instance; } } 这里需要说一下:由于这个类的构造函数是私有的，也就意味着这个类不能被继承。当然这里提的这种形式的单例模式是属于懒汉形式的，但是这样是线程不安全的，那么什么是线程不安全呢？学过操作系统的都知道，一个进程可以包含多个线程，假设你的代码所在的进程有多个线程，那么这多个线程都可以访问这段代码，当它们同时访问这段代码，如果每次运行的结果和单线程运行的结果相同，并且其他的变量的值也和预期的是一样的，那么就是线程安全的。想深入了解单例模式的人推荐看一下这篇博客单例模式，写的真的很好。 若你想在某一个类的父类构造函数中，用一个类的对象作为参数，那么这个类的对象要声明为static public class MySqliteOpenHelper extends SQLiteOpenHelper{ private static SQliteDataBaseConfig sQliteDataBaseConfig; private MySqliteOpenHelper(Context context){ super(context,sQliteDataBaseConfig.getAADatabaseName(),null,sQliteDataBaseConfig.getAADatabaseVersion()); } } 这也很好理解，因为当这个类构造时，作为参数的类对象可能还没实例化，所以需要将其声明为static。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AA","slug":"AA","permalink":"http://sakurajiang.github.io/tags/AA/"}],"keywords":[]},{"title":"对于做AA项目时对于view的重新理解","slug":"AA-对于做AA项目时对于view的重新理解","date":"2016-08-03T16:00:00.000Z","updated":"2020-07-06T09:14:20.496Z","comments":true,"path":"2016/08/04/AA-对于做AA项目时对于view的重新理解/","link":"","permalink":"http://sakurajiang.github.io/2016/08/04/AA-对于做AA项目时对于view的重新理解/","excerpt":"","text":"做这个AA项目时，本着尽可能将不懂得东西搞明白的想法，我对于view有了更深的理解，下面是我打的一个比方。假设activity是工人，那么这个工人开始工作时通过attach()方法启动了一个phoneWindow对象，这个对象就是一个窗户，然后有了窗户就应该装一块玻璃，而installDecor()方法就是得到玻璃的，这是一个DecorView，在系统的视图树中，这是根视图，下面就是一个linearLayout，然后在这个LinearLayout下面是两个FrameLayout，其中一个下面直接放入一个TextView，这个TextView用于显示标题，另一个FrameLayout下面再接一个LinearLayout，而这个LinearLayout就是我们真正开始放入内容的布局。然后有了窗户后我们应该贴窗花，因为这样才会显得有内容，那么，什么是窗花呢？窗花就是各种控件，也就是在布局xml中定义的各种控件，当然，有xml方式就有代码的方式，大同小异。那么如何将窗花贴到玻璃上呢？这里需要说明，你将窗花贴到玻璃上，并不是说直接贴在玻璃上，而是贴在一张纸上再贴在玻璃上，因为这样方便管理(包括撤销和添加的位置等)，这一点很重要，这也就意味着，显示出来的控件一定是贴在纸上的，不管是窗户上原来的纸还是你新创建的纸，同时，如果你要寻找到窗花，可以通过findViewById()方法来寻找到，但是如果你要对窗花进行修改和使用，那么这个窗花一定是要在纸上的，而且你找到的窗花一定要是这个纸上的窗花，也就是在findViewById()方法前加上view来指定是哪张纸，也就是说这张纸一定要加载出来，比如，一下代码: ViewGroup viewGroup1= (ViewGroup) LayoutInflater.from(this).inflate(R.layout.activity_main,null); RelativeLayout r= (RelativeLayout) viewGroup1.findViewById(R.id.r); Button b=new Button(this); b.setText(&quot;b1&quot;); r.addView(b); setContentView(r); 这个代码是没有问题的，但是，如果将第一行代码删了，变成： RelativeLayout r= (RelativeLayout) findViewById(R.id.r); Button b=new Button(this); b.setText(&quot;b1&quot;); r.addView(b); setContentView(r); 那么，就会报错，内容大概是调用addView(b)方法的对象是空的。那么纸是什么呢?纸其实就是view，是通过LayoutInflater的inflate()方法生成的，同时这里还需要提一点，如果你想将一张纸上的窗花黏在另一张纸上，那么，你首先需要将这个窗花从原来的纸上撕下来，然后再将这个窗花贴在另一张纸上，这里的撕就是原来纸调用removeView()方法，然后黏在另一张纸上，就是另一张纸调用addview()方法，那么这样能实现什么呢？1.动态的将布局呈现2.将布局的一部分替换掉3.实现类似侧滑菜单的效果这里还要提一点，因为窗口的大小是有限的，所以可能你的纸上的控件没有显示完全，如果你将这个纸上边的控件清除再调整纸的位置，或者直接通过调整纸的位置将纸上边的控件挤掉，来达到让这张纸完全显示的结果，那么这意味着什么呢?意味着可以通过这种方式实现侧滑菜单的效果。其实说到底，侧滑菜单的效果的实现实际上就是实现将布局的一部分替换掉和动态呈现布局的功能，要掌握替换布局和动态呈现布局的原理，并且灵活运用。比如实现侧滑菜单就有几种方式，不过原理都是一样的，下面列举一下我的两种方式：1.在主布局中就有侧滑时需要的布局，只是一开始不让它呈现出来(设置高度等属性)，然后当点击时呈现出来(往往是通过替换掉原来呈现出来的控件)2.在主布局中没有侧滑时需要的布局，当点击时让它自己动态加载出来，然后贴在相应的位置的纸上。 同时需要注意一下，setcontentView()方法是将纸黏在玻璃上，那么这张纸是哪张纸呢？这张纸就是你传入的参数，比如下面两种代码的区别: super.onCreate(savedInstanceState); super.onCreate(savedInstanceState); RelativeLayout r= (RelativeLayout) findViewById(R.id.r); RelativeLayout r= (RelativeLayout) findViewById(R.id.r); TextView t1= (TextView) r.findViewById(R.id.t); TextView t1= (TextView) r.findViewById(R.id.t); t1.setText(&quot;t1&quot;); t1.setText(&quot;t1&quot;) b.setText(&quot;b1&quot;); b.setText(&quot;b1&quot;); r.addView(b); r.addView(b); setContentView(r); setContentView(R.layout.activity_main); 这两代码就是最后一行不同，左边的代码显示出来是一个内容为t1的TextView和B1的Button， 右边的代码显示出来的是只有一个内容为hello world的TextView 这也就说明了显示出来的内容就是你传入的纸的内容，有人可能觉得这是废话，但是你写代码的时候可能就会搞混了，所以在这里提出来，一定要记住。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AA","slug":"AA","permalink":"http://sakurajiang.github.io/tags/AA/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"布局阶段","slug":"AA-布局阶段","date":"2016-08-03T16:00:00.000Z","updated":"2020-07-06T09:14:33.608Z","comments":true,"path":"2016/08/04/AA-布局阶段/","link":"","permalink":"http://sakurajiang.github.io/2016/08/04/AA-布局阶段/","excerpt":"","text":"这一阶段是对于布局的设置，因为对于一般的软件而言，当你点击进去某个activity时，往往这个activity与之前的activity有一些地方的显示是相同的，比如，头部和尾部，那么这时为了减少工作量，我们可以使用include标签，对于include标签的使用，在这里提一下需要注意的地方，如果你要在include标签中重新指定布局参数(android:layout_*属性)，，就必须覆盖android:layout_height和android:layout_width。因为这样才会生效，不然会提示错误。如果你是想指定过一个id，那么重新指定的id会覆盖原来的id。同时这里需要提一下很重要的一点，如果你想在代码中为include标签重新指定内容，那么如果你直接通过id找到这个include标签，然后将view添加到这个标签中，这样是得不到的，可能就是你通过id的确找到了这个标签，但是这个并不是真正的viewgroup，所以你无法将自己的view添加到上面，代码如下: public void setActivityTitle(int RLayoutId,int account){ //找到include标签 LinearLayout linearLayout1= (LinearLayout) findViewById(R.id.include1); //找到要附在include标签上的view LinearLayout linearLayout= (LinearLayout) LayoutInflater.from(this).inflate(RLayoutId, null); TextView textView= (TextView) linearLayout.findViewById(R.id.usertitlt_tv); textView.setText(getString(R.string.useractivitytitle_name) + &quot;(&quot; + account + &quot;)&quot;); //附在include标签上 linearLayout1.addView(linearLayout); } 这样是得不到的，那么我们应该怎么做呢？代码如下： public void setActivityTitle(int RLayoutId,int account){ //找到include标签 LinearLayout linearLayout1= (LinearLayout) findViewById(R.id.include1); //将这个标签设置为不可见，注意这里设置为不可见，而不是GONE，因为如果是GONE就意味着这个include标签不存在，那么可能会影响整个布局 linearLayout1.setVisibility(View.INVISIBLE); //找到这个include标签在的那个整个布局，之所以这里通过id来找，而不是通过inflate来生成，是因为生成之后你还需要再setcontextview()。 RelativeLayout relativeLayout= (RelativeLayout) findViewById(R.id.mainRelativeLayout); LinearLayout linearLayout= (LinearLayout) LayoutInflater.from(this).inflate(RLayoutId, null); TextView textView= (TextView) linearLayout.findViewById(R.id.usertitlt_tv); textView.setText(getString(R.string.useractivitytitle_name) + &quot;(&quot; + account + &quot;)&quot;); //将要附加的view附加在整个布局上。 relativeLayout.addView(linearLayout); } 这就是使用include标签需要注意的一些地方。在这里也需要说一下布局的各个属性问题，由于篇幅问题，这里就提一个，就是layout_margin和padding的区别，layout_margin是控件在布局显示的样子，padding则是控件的内容在控件中的位置，同时，Layout_grivaty与grivaty这两者与之相似，layout_grivaty与layout_margin对应，而grivaty与padding对应，那么，layout_margn与layout_grivaty有什么区别呢？grivaty与padding又有什么区别呢？layout_grivaty与grivaty的值都是给定的，我们只能在这些给定的属性中选择，而layout_margn与padding的值我们可以任意给，相对于layout_grivaty和grivaty更灵活，我们根据需要选择合适的属性。总之有layout的就是跟控件在布局中显示有关，没有的则是控制控件的内容的位置。 今天在设置布局时，因为我们想将所有的title去掉，那么如果我们去每一个activity中找，并且去掉，这样是非常不合理的，因此我们需要在一个activity中管理一下，因此我定义了一个activityFrame继承了activity，这样我真正的activity都可以继承自定义的activity，这样管理起来就很方便，那么我们可以requestWindowFeature(Window.FEATURE_NO_TITLE);来让它没有标题，同时因为我们需要动态的添加布局，我们可以这么办，步骤可以分为三步:1.先找到我们需要插入的位置的布局，如我要插入到下面布局中的relativeLayout布局中 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.example.jdk.myaa.MainActivity&quot;&gt; &lt;include layout=&quot;@layout/title_layout&quot; android:id=&quot;@+id/include1&quot;&gt;&lt;/include&gt; &lt;include layout=&quot;@layout/buttom_layout&quot; android:id=&quot;@+id/include2&quot;&gt;&lt;/include&gt; &lt;RelativeLayout android:id=&quot;@+id/main_bodyRelativeLayout&quot; android:layout_below=&quot;@id/include1&quot; android:layout_above=&quot;@id/include2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; 我们如何找到这个布局呢？通过代码: RelativeLayout relativeLayout= (RelativeLayout) findViewById(R.id.main_bodyRelativeLayout);这样就找到了这个布局。2.找到我们需要插入的布局，如我要插入如下布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;GridView android:id=&quot;@+id/gv&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; android:paddingTop=&quot;130dp&quot; android:horizontalSpacing=&quot;10dp&quot; android:verticalSpacing=&quot;100dp&quot; android:numColumns=&quot;3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:listSelector=&quot;@drawable/myselector&quot; &gt;&lt;/GridView&gt; &lt;/LinearLayout&gt; 这个如何寻找呢？通过下面代码:ViewGroup v= (ViewGroup) LayoutInflater.from(this).inflate(R.layout.main_bodylayout, null);其中R.layout.main_bodylayout是上面布局的名字。3.将这个布局添加到对应的位置的布局中：relativeLayout.addView(v);这样就完成了动态添加，当然所添加的布局的属性会与你需要插入的布局属性相同，也就是跟第二步骤的布局相同，但是你也可以自己设置，设置的代码如下： RelativeLayout.LayoutParams layoutParams=new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT); relativeLayout.addView(v,layoutParams); 这样就行了。 上面是添加一个布局到对应位置中去，那么如何添加一个控件到对应的位置中去呢？这个步骤与上述类似1.与上面一致2.找到我们需要插入的控件，比如我想插入这个布局中的GridView控件，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;GridView android:id=&quot;@+id/gv&quot; android:paddingLeft=&quot;20dp&quot; android:paddingRight=&quot;20dp&quot; android:paddingTop=&quot;130dp&quot; android:horizontalSpacing=&quot;10dp&quot; android:verticalSpacing=&quot;100dp&quot; android:numColumns=&quot;3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;200dp&quot; android:listSelector=&quot;@drawable/myselector&quot; &gt;&lt;/GridView&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hahaha&quot;/&gt; &lt;/LinearLayout&gt; 那么我们该如何找到呢？代码如下： ViewGroup v= (ViewGroup) LayoutInflater.from(this).inflate(LayoutId, null); GridView g= (GridView) v.findViewById(R.id.gv); v.removeView(g); 这里说一下第三行代码的作用，如果你没有这行代码，那么就会报错：The specified child already has a parent. You must call removeView() on the child&#39;s parent first.也就是说这个控件已经有一个parent了，我们要使用这个控件，就必须使用这个parent，如果你要强制使用这个控件，那么你就需要让这个控件与这个parent脱离父子关系，也就是用这行代码，要理解这个，我们先理一下activity和window，view的关系其实我们可以这么理解，假设activity是一个工人，他做了一个window，而这个window需要玻璃，玻璃就是这个view，更准确是viewgroup，也就是根视图，然后我们需要打扮这个窗户，也就是往窗户上贴窗花，假设我们的窗花是需要贴在纸上，然后让纸贴在玻璃上，因为这样我们以后要清除的时候，只要把纸撕了就行，也就是说方便管理，然后这个窗花就是控件，纸就是view，也就是各种子视图，然后我们这里的情况是要在这张纸上贴别的纸上的窗花，我们当然得把它撕下来先，也就是去掉父子关系，这就是第三行代码的作用。不知道这么说你们是不是理解了呢？这里再加一些内容，其中的窗户实际上是phonewindow，而玻璃是viewgroup,那么这个玻璃是怎么创建的呢？是通过activity方法中的attach()方法创建的，通过源代码你也可以看的到这是一个phonewindow对象，那么什么时候调用的attach()方法呢？是在ActivityThread中 performLaunchActivity中调用了，那么这里的纸是怎么创建的呢？是通过LayoutInflater的inflate()方法创建的，原料就是那些layout布局文件，而这里的窗花就是控件，这个是在layout中写出来的或者用代码动态生成。将窗花贴在纸上是通过addview()方法，将纸贴在玻璃上，是通过setcontentview()方法。那么玻璃(viewgroup)怎么生成的呢？实际上是通过installDecor();方法得到的，这里的viewgroup更准确的说是DecorView，而installDecor();方法是生成DecorView，并且根据窗口属性加载顶级视图布局、获取mContentParent、设置一些基本属性等。接下来还是放一张图片来说一下:一、DecorView为整个Window界面的最顶层View。二、DecorView只有一个子元素为LinearLayout。代表整个Window界面，包含通知栏，标题栏，内容显示栏三块区域。三、LinearLayout里有两个FrameLayout子元素。 (20)为标题栏显示界面。只有一个TextView显示应用的名称。也可以自定义标题栏，载入后的自定义标题栏View将加入FrameLayout中。 (21)为内容栏显示界面。就是setContentView()方法载入的布局界面，加入其中。这样是不是清晰点了。3.与上面一样。 relativeLayout.addView(g);至于这里为什么事g而不是v应该理解吧。 这里还需要说一下，setcontentview()方法的作用，作用其实就是将纸贴在玻璃上，但是这里需要提一下： 当activity 调用 setContentView() 时，Android 才会去绘制 layout 上的各个元素，并为其分配内存。只有分配了内存以后,才能继续执行findViewById(); 才能得到引用，不然得到空引用。空引用意味着，后面使用相应变量时就会发生访问的对象不存在的问题。当Activity重新setContentView()以后，那些之前绘制的控件，内存都被灭掉了。这也就是说，你需要先setcontentview，然后再将布局动态添加上去。不然就白费了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AA","slug":"AA","permalink":"http://sakurajiang.github.io/tags/AA/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"设置监听器的问题","slug":"AA-设置监听器的问题","date":"2016-08-03T16:00:00.000Z","updated":"2020-07-06T09:14:43.051Z","comments":true,"path":"2016/08/04/AA-设置监听器的问题/","link":"","permalink":"http://sakurajiang.github.io/2016/08/04/AA-设置监听器的问题/","excerpt":"","text":"1.include标签无法直接设置监听器就是说通过findViewById()方法找到这个标签，然后给它设置监听器，不起作用 LinearLayout l= (LinearLayout) activity.findViewById(R.id.include2) l.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(&quot;Logcat&quot;, &quot;hahha&quot;); } }); 2.传入一个context，创建一个view，然后使用findViewById()方法找到对应的控件，然后设置监听，不起作用 View v= LayoutInflater.from(context).inflate(R.layout.buttom_layout,null); ImageView imageView= (ImageView) v.findViewById(R.id.buttom_ImageView); imageView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(&quot;Logcat&quot;, &quot;hahha&quot;); } }); 猜测:因为你新创建了一个view，所以你设置的监听是设置到了你新建的这张view上，而不是显示的view上，所以点击显示的view当然不起作用。要想让这个监听器起作用，应该将绑定监听器的view贴在视图上，也就是setContentView(参数);测试:在你的oncreate(）方法加入如下代码: ViewGroup v= (ViewGroup) LayoutInflater.from(this).inflate(R.layout.buttom_layout,null); // ImageView imageView= (ImageView) l.findViewById(R.id.buttom_ImageView); ImageView imageView= (ImageView) v.findViewById(R.id.buttom_ImageView); Log.i(&quot;Logcat&quot;, &quot;&quot; + imageView); // Log.i(&quot;Logcat&quot;,&quot;&quot;+l); imageView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.i(&quot;Logcat&quot;, &quot;hahha&quot;); } }); setContentView(v); 这时点击就有用了。因为这个我调试了一下午，还好被我找到了。血的教训。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"AA","slug":"AA","permalink":"http://sakurajiang.github.io/tags/AA/"}],"keywords":[]},{"title":"TextView的部分点击事件和点击事件","slug":"Android-TextView的部分点击事件和点击事件","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:19:14.290Z","comments":true,"path":"2016/08/03/Android-TextView的部分点击事件和点击事件/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-TextView的部分点击事件和点击事件/","excerpt":"","text":"1.在TextView中实现部分点击我在activity中使用了clickablespan这个类，然后完全按照视频上的操作下来，发现点击时不响应，于是我便设置了电话的链接，发现这时点击自己设置的区域就会响应，但是如果我把电话链接删了，这时就又不会响应，于是我便上网查找，如何设置Textview的部分点击，发现是因为我少加了一行代码myTextView.setMovementMethod(LinkMovementMethod.getInstance());加上之后就行了（可是视频里也没有，可能是视频太早了，系统的源代码进行了细微的更改）。结论：使用clickablespan为TextView设置部分点击，记得要为TextView设置movementMethod。2.在TextView中实现完全点击这个只需要为textview设置监听器就行，由于我是在之前的代码中直接加入的，然后当我点击我之前设置的部分点击的区域时，发现是先调用clickablespan中的onclick()，然后是onclicklistener中的onclick()，而点击电话的链接时，是直接跳转到拨打电话的页面，即不会调用clickablespan中的onclick()方法，也不会调用onclicklistener中的onclick()方法，因为没有打印出这两个方法中的输出语句。同时这里有一点需要提一下，如果这时你在xml文件中声明android:clickable=&quot;false&quot;, android:linksClickable=&quot;false&quot;，这时你会发现，无论是自己设置的部分区域，亦或是电话的链接，还是textview中的任何地方，都是可以点击的。这是因为无论是setOnClickListener会强制改变clickable属性，而myTextView.setMovementMethod(LinkMovementMethod.getInstance());会改变android:linksclickable的属性（这里得提一点，如果你将myTextView.setMovementMethod(LinkMovementMethod.getInstance())代码去掉，然后设置android:linksclickable=”true”,这时就会有一个有趣的现象，若textview的值中有phone，web之类的，那么无论是自己设置的区域还是phone，web都可以点击，若是没有phone，web之类的，那么自己设置的区域就无法点击，感觉是android:linksclickable=”true”属性是对于android:autolink而设置的，若textview中的内容存在这些，则会让linksclickable设置为true，否则不会。），所以都可以点击。如果你将setonclicklistener()去掉，然后设置android:linksClickable=&quot;true&quot;，android:clickable=”false”，发现自己设置的区域和电话依然可以点击。结论：为TextView设置完全点击时，为TextView设置onclicklistener监听器，若同时还有部分点击，以及电话。那么当点击设置的部分点击区域时，先运行clickablespan中的onclick()，然后是onclicklistener中的onclick()，若点击电话的链接，是直接跳转到拨打电话的页面，即不会调用clickablespan中的onclick()方法，也不会调用onclicklistener中的onclick()方法。同时setOnClickListener会强制改变clickable属性，而myTextView.setMovementMethod(LinkMovementMethod.getInstance());会改变android:linksclickable的属性（这里得提一点，如果你将myTextView.setMovementMethod(LinkMovementMethod.getInstance())代码去掉，然后设置android:linksclickable=&quot;true&quot;,这时就会有一个有趣的现象，若textview的值中有phone，web之类的，那么无论是自己设置的区域还是phone，web都可以点击，若是没有phone，web之类的，那么自己设置的区域就无法点击，感觉是android:linksclickable=”true”属性是对于android:autolink而设置的，若textview中的内容存在这些，则会让linksclickable设置为true，否则不会。）。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"Sqlite的简单使用","slug":"Android-Sqlite的简单使用","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:19:01.600Z","comments":true,"path":"2016/08/03/Android-Sqlite的简单使用/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-Sqlite的简单使用/","excerpt":"","text":"对于Sqlite的简单使用，我们可以用两种方式，先说第一种:这种是大家常用的方式，我们先创建一个类继承SQLiteOpenHelper，对于这个类，我们应该在oncreate()方法中创建表，为什么呢？因为当你创建表时，若这张表是存在的，那么就会报错，也就是说，如果你运行了这个程序之后，再运行一次，当运行到创建表这一块时会报错，因为这张表已经存在，所以说创建表的语句应该放在只会调用一次的方法中，正好oncreate()方法满足，因为这个方法是在数据库创建的时候执行，而对于数据库的创建则会有判断，若这个数据库存在则打开，若不存在则创建(其实就是一些判断，当存在时，就调用SQLiteDatabase的openDatabase()方法，若不存在就调用SQLiteDatabase的openOrCreateDatabase()方法)，所以我们应该把创建表的语句写在onCreate()中，可以理解成onCreate()方法是创建表的方法，同时这里需要提一点，数据库是什么时候完全建立或打开了呢?只有当调用了SQLiteDatabase的openDatabase()方法或则SQLiteDatabase的openOrCreateDatabase()方法才行，而不是说调用了自己创建的类的构造函数就行，对于这种使用sqlite的方式，我们应该在activity中调用自己定义类的getWritableDatabase()或者getReadableDatabase()方法，我们通过源代码可以知道，其实这两种方法还是通过调用SQLiteDatabase的openDatabase()方法以及SQLiteDatabase的openOrCreateDatabase()方法，同时这里需要提到自己定义的类的另一个方法，就是onUpgrade()方法，这个方法有三个参数，第一个是表，第二个是数据库之前的版本，第三个是数据库之后的版本，同时这里需要提一点，并不是调用这个方法来实现数据库版本的更新，而是数据库版本更新之后会调用这个方法，这里的两个数据库版本号是为了标注从哪个版本升级到哪个版本，在这个方法中我们应该干什么呢？我们可以增加一些表或者删除一些表，或者更改数据以便和新版本的数据库联系。至于如何更新数据库，可以在activity中调用自己定义类的构造函数，同时这里需要提一下，我们之前说过，这个构造函数并没有打开或创建数据库的功能，如果你去查看源代码就会发现，只是赋值而已，对于数据库的更新，我们肯定需要打开这个数据库，所以还需要调用getWritableDatabase()或者getReadableDatabase()方法。这里再提一下这两个方法的区别，之前我记得的是前者打开或者创建一个可读可写的数据库，后者是打开或创建一个可写的数据库，但是当我实现数据库版本更新时，我用的是getReadableDatabase()方法，但是依然成功，为什么是但是呢？因为数据库是只可读的时候不允许更改数据库的版本号，后来我上网查询知道了，原来这两个方法的区别是:getWritableDatabase()方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，倘若使用的是getWritableDatabase() 方法就会出错。getReadableDatabase()方法则是先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后会继续尝试以只读方式打开数据库。如果该问题成功解决，则只读数据库对象就会关闭，然后返回一个可读写的数据库对象所以说以后用getReadableDatabase()方法更好。接下来说第二种方式:这种方式就是不定义一个类来继承SQLiteOpenHelper，而是继承object就好，然后设置一个构造函数，参数包括context，当然还可以包括一些别的，别入版本号之类的，至于这里要参数context，是因为我们需要使用到context中的openOrCreateDatabase()方法，当然我们也可以不带任何参数，因为我们可以使用SQLiteDatabase的静态方法openOrCreateDatabase()，其实context中的openOrCreateDatabase()方法也是通过调用SQLiteDatabase的静态方法openOrCreateDatabase()，只是因为使用context的openOrCreateDatabase()方法简单点，所以这样用了。然后我们可以调用用SQLiteOpenHelper对象的execSQL,query(),insert(),setVersion()等等方法来实现这些增删改查等，然后再activity中调用自己定义的类及定义的方法就行。综上所述，其实对于sqlite的使用，最重要的类就是SQLiteDatabase，而SQLiteOpenHelper则是一个包装了SQLiteDatabase类的一些方法的辅助类，辅助你使用sqlite。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"preference的使用以及自定义一个preference","slug":"Android-preference的使用以及自定义一个preference","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:17:39.997Z","comments":true,"path":"2016/08/03/Android-preference的使用以及自定义一个preference/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-preference的使用以及自定义一个preference/","excerpt":"","text":"当你要写一个类似于设置这种界面时，你可能会需要使用到好多的layout，这样做会非常复杂，这时，android提供了一个简单的方法，就是让你的activity继承PreferenceActivity，然后创建一个preference这个xml文件，这个文件是在res/xml中的，然后在activity中调用addPreferencesFromResource(R.xml.mypreferencelayout);方法将自己在xml中定义的界面显示在activity上，对于xml文件的定义，我们需要搞懂这几个标签的意思： CheckBoxPreference:CheckBox选择项，对应的值的ture或flase。 EditTextPreference:输入编辑框，值为String类型，会弹出对话框供输入。 ListPreference: 列表选择，弹出对话框供选择。 Preference：只进行文本显示，需要与其他进行组合使用。 PreferenceCategory：用于分组。 PreferenceScreen:PreferenceActivity的根元素。 RingtonePreference：系统玲声选择。对于这几个标签中比较常用的属性有：title:显示的标题key：唯一标识（至少在同一程序中是唯一）。summary:副标题（小字体显示）等等。那么这是系统自带的标签，我们如何来自定义一个标签呢？答案是，我们自定义一个类，让它继承某一个preference，然后在其中自定义要实现的功能，样式等。那么如何将它和xml挂钩呢？我们只需要将这个类的全称写在xml中就行，类似于 &lt;com.example.android_textpreferencescreen1.MyPreferenceScreen android:key=&quot;m1&quot; android:title=&quot;myPreference&quot; /&gt; 其中com.example.android_textpreferencescreen1.MyPreferenceScreen就是这个类的全称，包括包名和类名，这种方式也适用于别的，比如一个类继承了view，然后在相同类型的布局文件中将这个类的全称写下来就行，注意是要相同类型，如果你将继承了view的类写在preference的xml中，那么就会报java.lang.ClassCastException这个错误。总之如果在xml里边使用自定义控件，那么只需要将类的全称写在xml中就可以。通过这种方式添加时，当加载xml文件时加载到这一项时，只会调用这个类的构造函数，当有多个构造函数时，是调用哪个呢？结果是调用两个参数的这个，至于为什么呢？因为public View (Context context)是在java代码创建视图的时候被调用，如果是从xml填充的视图，就不会调用这个，public View (Context context, AttributeSet attrs)这个是在xml创建但是没有指定style的时候被调用，attr里边传过来的是 xml里边对应的height、 width等参数，包括自己定义的参数，public View (Context context, AttributeSet attrs, int defStyle)这个不用说也懂了吧这是在xml文件中的将自定义的preference和activity挂钩的操作，那么相对应的我们应该有在代码中的操作，这个我们应该知道了，就是在activity中new一个自定义的类的对象就行了。那么我们除了有在xml中对于preference的操作，我们就还有在代码中的操作，这也很简单，我们使用c1=(CheckBoxPreference) findPreference(&quot;c1&quot;);方法来寻找到对应的preference，这里的key就是xml中对应的key，找到这个对象后，我们就可以使用这个对象来操作对应的preference了。同时，在做这个实验的时候发现创建对话框出现unable to add window token null is not for an application错误时，是因为传入的Context的参数不对，需要将参数改为你的activity的名字.this。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"Service中有关于stopselfResult()方法的一些问题","slug":"Android-service中有关于stopselfResult()方法的一些问题","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:18:30.441Z","comments":true,"path":"2016/08/03/Android-service中有关于stopselfResult()方法的一些问题/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-service中有关于stopselfResult()方法的一些问题/","excerpt":"","text":"在一个service中我们使用stopselfresult（）时的一些问题，当我在service中创建一个如下的函数： public void Print(){ for(int i=0;i&lt;100;i++){ try { Thread.sleep(1000); if(i==11){ Log.i(&quot;Logcat&quot;, &quot;qianmian de i=&quot;+i); boolean b=stopSelfResult(mStartId); boolean b1=false; Log.i(&quot;Logcat&quot;, &quot;&quot;+b); Log.i(&quot;Logcat&quot;, &quot;houmian de i=&quot;+i); Thread.sleep(20000); } } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } Log.i(&quot;Logcat&quot;, &quot;i=&quot;+i); } } 这个函数的功能很简单，然后我们在onstartcommand（）方法中调用，我们采用如下两种方式，第一种是直接调用 @Override public int onStartCommand(Intent intent, int flags, int startId) { // TODO Auto-generated method stub mStartId=startId; Log.i(&quot;Logcat&quot;, &quot;&quot;+mStartId); Print(); return super.onStartCommand(intent, flags, startId); } 同时为了验证效果，我们在ondestroy（）方法中写一条log语句， @Override public void onDestroy() { // TODO Auto-generated method stub Log.i(&quot;Logcat&quot;, &quot;onDestroy&quot;); super.onDestroy(); } 然后我们看结果，这个程序的输出结果的主要部分是： ... i=10 qianmian de i=11 true houmian de i=11 i=11 i=12 ... onDestroy 而如果我们采用第二种方式就是创建一个新线程的方式，在onstartCommand()中调用这个函数，方式如下： @Override public int onStartCommand(Intent intent, int flags, int startId) { // TODO Auto-generated method stub mStartId=startId; Log.i(&quot;Logcat&quot;, &quot;&quot;+mStartId); Thread t=new Thread(new Runnable() { @Override public void run() { // TODO Auto-generated method stub Print(); } }); t.start(); return super.onStartCommand(intent, flags, startId); } 这个结果如下： ... i=10 qianmian de i=11 true houmian de i=11 onDestroy i=11 i=12 ... 也就是说，创建一个新的子线程中调用和在主线程中调用结果不同，在子线程中是会直接调用ondestroy()方法，然后接着执行onstartCommand（）方法，在主线程中是继续执行onstartCommand（）方法，再去执行ondestroy（）方法。为什么呢？等我看完主线程与子线程再来解决这个问题。同时，这里还得提一点，看到这个输出结果，有人可能会说执行onDestroy()方法是需要时间的，因为输出语句true在houmian de i=11前面，而houmian de i=11这条输出语句在onDestroy前面，也就是说这时stopselfResult()方法已经执行完了，而ondestroy（）方法还在执行一段时间后再打印ondestroy语句。也就是说onDestroy()方法是需要时间来执行的。其实不是，你可以使用在activity中调用stopService（）方法的方式来终止服务，你会发现onDestroy在你按下的时候马上就打印出来了，也就是说onDestroy（）方法并不会耗费时间，那么这个输出结果是怎么回事呢？感觉可能是stopselfResult()方法和ondestroy（）方法之间的调用花了时间。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"问题","slug":"问题","permalink":"http://sakurajiang.github.io/tags/问题/"},{"name":"Service","slug":"Service","permalink":"http://sakurajiang.github.io/tags/Service/"}],"keywords":[]},{"title":"startService与BindService的区别","slug":"Android-startService与BindService的区别","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:19:07.588Z","comments":true,"path":"2016/08/03/Android-startService与BindService的区别/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-startService与BindService的区别/","excerpt":"","text":"我们做几个实验：1，启动service后，按back键返回。 一开始我没在service中用子线程来调用方法，结果导致点击屏幕没有响应，但是菜单按钮和会主界面的按钮可以按，因为，service还是运行在主线程中的，后面我用子线程调用方法，测试的结果是： 用startService()启动之后，按back键，activity被destroy，但是service继续在运行，也就是说，当activity被销毁后，主线程并没有被销毁，并且程序运行完后，service也没有destroy。而用bindService()启动之后，按back键，activity被销毁，然后onUnbindService，然后ServiceDestroy，但是程序还是一直运行，也就是说bindService和activity是绑定的，当activity消亡时，这个service也消亡。同时这里得提一下，当这个service消亡时，是只运行service中的onUnbind()方法，不会去运行activity中的onServiceDisconnected()方法。2，分别多次按startService按钮和BoundService按钮，看看情况 结果是startService按钮是第一次创建service后，后面每次按都不会再创建，但是都会执行onStartCommand()方法，而对于bindService而言，按一次之后再按不会有变化，但是如果将conn这个变量在BoundService按钮的方法体中再次赋值（之前是在onCreate中赋值），那么结果就不同，当按下一次后再按，结果就会再次执行，再按，再执行，当然如果你调用的方法的执行需要时间，比如打印1-100的数，那么两次结果会穿插输出，而当你按unBound按钮时，就会发现当你按一次时，它不会调用service中的onUnbind()方法，service也不会被destroy，但是再按一次就会报错，内容大概是service没有registered（发生这种情况的原因是这里的conn会跟最后一个按BoundService按钮时候生成的conn一致。）。这与按一次BoundService按钮，再按一次unBoundService按钮结果不同，这时按unBoundService的结果是会调用service中的onUnbind()方法，service也会被destroy。为什么多按几次BoundButton再按一次unBoundButton不会调用service中的onUnbind()方法，service也不会被destroy呢？但是这个service应该是被unBind的了的，不然的话第二次按的话为什么会出现这个service没有registered的错误呢，那么如何被onunBind的呢？而后，我想到将所产生的conn全部存储起来，然后分别当作参数传递给activity中的unbindService(conn)方法，于是我将点击bindButton按钮产生的所有ServiceConnection的对象全都存储到一个ServiceConnnection的数组中，然后在unBindButton中将数组的值分别赋值给conn，这样的话当你点击bindButton产生多个ServiceConnection对象后，点击unBindButton按钮就会依次解除绑定，当你解除最后一个service时，就会调用onUnbind和destroy方法，也就是说，其实onUnbind方法是等所有的service解除绑定后才调用，所以之前只解除一个service时并没有调用这个方法，也就没有destroy，因为这个service和activity还是处在绑定的状态。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"Service","slug":"Service","permalink":"http://sakurajiang.github.io/tags/Service/"}],"keywords":[]},{"title":"关于使用BroadCastReceiver的一些问题","slug":"Android-关于使用BroadCastReceiver的一些问题","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:19:22.037Z","comments":true,"path":"2016/08/03/Android-关于使用BroadCastReceiver的一些问题/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-关于使用BroadCastReceiver的一些问题/","excerpt":"","text":"1.系统启动的时候启动一个service如何实现？我们学完BroadCastReceiver之后，我们可以写一个BroadCastReceiver接收系统启动时的消息，因为系统启动之后是会发消息的，然后我们在onReceive()中启动service，这样就实现了系统启动的时候启动服务。2.Broadcastreceiver接收到消息后宿主进程的生命周期当我们安装了自己写的Broadcastreceiver的程序后，其中的receiver会被放入一个队列中，这个队列的排序是根据intent-filter来排列的，当系统发送了一个消息后，这个消息需要被分发，于是就会在之前那个队列中寻找receiver，我们把这个队列称为分发队列，这个寻找是通过intent-filter来寻找的，找到之后将这个消息分发给对应的receiver，通过Broadcastreceiver来启动这个进程，这时需要注意，这个自己写的Broadcastreceiver中的Activity是没有启动的。当完成这个消息的处理后，没有Activity与这个进程交互，然后这个进程就会变成emptyprocess，等待系统的回收，这个与contentprovider类似。这个就是说，如果要长期运行宿主进程，那么最好用service3.广播接收是在子线程吗？不是，发广播的时候是异步的(同步是指需要等待对方的回复再进行下一步，比如http的访问请求，当我们输入关键字查询时，如果没有返回值我们是看不到内容的，而异步则是不需要等待对方的回复)，异步我们就会想到多线程，但是Broadcastreceiver中的onReceive()方法则是在主线程中的，并不是在子线程中，也就是说我们要更新ui，我们可以直接在onReceiver()中实现，但是同时需要提一点，若在onReceive()方法执行耗时的操作，则会出现ANR(application null response)，这里顺便说一下出现ADR的两种情况，第一种:事件分发超过5秒，第二种:接收到消息后10秒钟内没有处理完。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"BroadCastReceiver","slug":"BroadCastReceiver","permalink":"http://sakurajiang.github.io/tags/BroadCastReceiver/"}],"keywords":[]},{"title":"service学习总结","slug":"Android-service学习总结","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:18:39.047Z","comments":true,"path":"2016/08/03/Android-service学习总结/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-service学习总结/","excerpt":"","text":"学一个东西我们一般要了解它有什么用，那么service有什么用呢？service简洁来说一般是用于处理耗时时间长，并且与activity通讯不频繁的的任务，比如下载一部电影，但是如果你下载一个图片，并且希望当它下载后显示出来，那我们没有必要使用service，我们可以使用线程。那么知道了service的作用后，它有多少种类型呢？对于这个，我们一般是跟分的方式有关，我们可以有三种方式的分法，首先，按照启动方式分，我们可以分为startService和bindService两种，那么这两种有什么区别呢？对于startService而言，它不跟activity绑定，当activity退出时，它不会退出，并且用这种方式启动一个service，我们可以对这个service下达多次的命令，因为当这个service创建后，我们再去点击startButton的按钮，你会发现它不会重新创建一个service，但是会执行onstartCommand()方法，而对于bindService而言，它跟activity是绑定的，如果activity退出，那么它就会onUnbind，然后destroy。而且，当你使用这个方式启动service后，当你再点击，你会发现没有反应，这是因为当你使用一个ServiceConnection类型的参数让activity与service连接后，当你再使用这个类型的同一参数时，就不会再次进行连接，也就是说，如果你同时将ServiceConnection类型的参数在bindButton中重新new一个，也就是说每次点击这个button都会重新创建一个serviceConnection类型的参数，这时就会重新连接，重新调用ServiceConnection中的onServiceConnected()方法但是onbind()方法不会再调用，因为第一次时就已经调用并且返回了一个Ibinder类型的接口，而这个接口的内容是不变的，所以不再调用onBind()方法。而ServiceConnection类型的参数是跟最后一次点击BindButton时new的ServiceConnection类型的参数一样，也就是说，在unBindButton中的unbindService(ServiceConnection类型的参数)方法中传入的参数是最后一次的参数，当我们点击这个button时，会unbind这个service，但是再点击一次就会报错，内容是这个service没有注册，只是第一次点击这个unBindbuttton时不会调用service中的onUnbind()方法，也没有destroy。既然如此，第二次是如何出现service没有注册这个错误的呢？这一点搞不太懂。而后，我想到将所产生的conn全部存储起来，然后分别当作参数传递给activity中的unbindService(conn)方法，于是我将点击bindButton按钮产生的所有ServiceConnection的对象全都存储到一个ServiceConnnection的数组中，然后在unBindButton中将数组的值分别赋值给conn，这样的话当你点击bindButton产生多个ServiceConnection对象后，点击unBindButton按钮就会依次解除绑定，当你解除最后一个service时，就会调用onUnbind和destroy方法，也就是说，其实onUnbind方法是等所有的service解除绑定后才调用，所以之前只解除一个service时并没有调用这个方法，也就没有destroy，因为这个service和activity还是处在绑定的状态。 第二种按照服务性质分为LocalService和RemoteService，对于android而言，RemoteService其实就是不同进程。而对于如何启动不同进程的service，我还不会。第三种按照实现方式分为Java Service和Native Service两种，Native Service是用C，C++实现的服务。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"Service","slug":"Service","permalink":"http://sakurajiang.github.io/tags/Service/"}],"keywords":[]},{"title":"点击listview时得到item中的数据的方式","slug":"Android-点击listview时得到item中的数据","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:20:52.373Z","comments":true,"path":"2016/08/03/Android-点击listview时得到item中的数据/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-点击listview时得到item中的数据/","excerpt":"","text":"我将数据库的数据显示在listview上时，想通过长按listview显示菜单，菜单中包含删除和更新操作，通过长按listview显示菜单，可以通过复写onCreateContextMenu()和onContextItemSelected()方法来实现，这个很简单，在这里就不赘述了，重点在于当我们进行删除操作时，如何删除这一项，也就是我们需要得到这个item中的数据，比如id，这个id是数据库的id，而不是item的id，这两个是不相同的，因为当我们删除其中的某一个item时，item的id和数据库的id就会不同。那么我们如何得到数据库的id呢？这里提供五种种方法:方法一:让listview设置监听器，这里需要提一下，我们最好是设置长按监听器，不然的话，你点击一下，得到了id，然后还要再长按一次，得到菜单，因为长按只会触发OnItemLongClickListener，不会触发OnItemClickListener，当然你可以让OnItemLongClickListener返回的是false，这样就不会拦截事件了，但是只需要设置一个监听器岂不是更好，所以最好设置长按监听器。然后在其中写入如下代码: View v=myListView.getChildAt(position); TextView t=(TextView) v.findViewById(R.id.myTextView1); itemid=t.getText().toString();其中的第一行是得到listview中的item的布局，我这里是自定义的布局，用的是linearLayout，这里得到的也就是lineadlayout，第二行是得到用于显示id的控件，我这里是用的TextView，它的id就是R.id.myTextView1，如果你使用的是系统的布局，那么你的对应的id就是android.R.i d.text1，然后第三行就不用解释了，这样就得到了数据库中的id，当然你还可以得到别的很多数据。方法二:让listview设置监听器，然后用到游标，在监听器中加入如下代码: String sql=”select userid from user”; cursor=sqLiteDatabase.rawQuery(sql, null); cursor.moveToPosition(position); int id2=cursor.getInt(cursor.getColumnIndex(“userid”));这样就得到了这些你所点击的item中的数据库id。方法三:让listview设置监听器，然后写入如下代码: HashMap&lt;String, String&gt; h1= (HashMap&lt;String, String&gt;) parent.getItemAtPosition(position); h1.get(“userid”);这个方法第一行代码得到的是每一个item的值，注意是item的值，这里的item是HashMap结构的。这与第一中方法不同，第一种方法的第一行代码是得到item的布局第二行代码是取值，因为是HashMap结构的，所以采用这个方式取值，其中&quot;userid&quot;是键。方法四:不设置监听器，在onContextItemSelected()方法中写入代码: AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo) item.getMenuInfo(); int q=(int) info.id; Log.i(“Logcat”, “q=”+q); View v1= myListView.getChildAt(q); TextView t2=(TextView) v1.findViewById(R.id.myTextView1); String st=t2.getText().toString();这样的到的st就是你的item的id了。方法五:不设置监听器，在onContextItemSelected()方法中写入代码: AdapterView.AdapterContextMenuInfo info=(AdapterView.AdapterContextMenuInfo) item.getMenuInfo(); String sql=”select userid from user”; cursor=sqLiteDatabase.rawQuery(sql, null); cursor.moveToPosition((int) info.id); int id2=cursor.getInt(cursor.getColumnIndex(“_id”)); 这样就得到了这些你所点击的item中的数据库id。看上述的代码，就会发现这个和方法二类似，方法二的position`就是这里的(int) info.id，这个方法比方法二更简单，因为不用设置监听器。这个方法最简单。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"自定义ContentProvider","slug":"Android-自定义ContentProvider","date":"2016-08-02T16:00:00.000Z","updated":"2020-07-06T09:20:59.489Z","comments":true,"path":"2016/08/03/Android-自定义ContentProvider/","link":"","permalink":"http://sakurajiang.github.io/2016/08/03/Android-自定义ContentProvider/","excerpt":"","text":"对于ContentProvider，我想大家应该都不算陌生，因为它是android四大组件之一，相对而言，它比activity和service要简单挺多，这个contentprovider的作用就是实现各个应用程序之间的（跨应用）数据共享，比如联系人应用中就使用了ContentProvider,你在自己的应用中可以读取和修改联系人的数据，不过需要获得相应的权限。其实它也只是一个中间人，真正的数据源是文件或者SQLite等。那么我们直接开始自定义自己的contentprovider吧1.我们先定义一个类来继承contentprovider，然后复写它的方法，在这里我就复写了一下query()方法，代码如下: public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { // TODO Auto-generated method stub mySqliteOpenHelper =new MySqliteOpenHelper(getContext(), &quot;myDataBase&quot;, null, 1); sqLiteDatabase=mySqliteOpenHelper.getReadableDatabase(); cursor=sqLiteDatabase.query(&quot;user&quot;, null, null, null, null, null, null); return cursor; } 其中数据库myDataBase我已经建好，表也建好并且插入了数据，由于我们这里只是说contentprovider的自定义，就不赘述sqlite的用法了，这个方法返回的是一个cursor对象，这样的话，contentprovider就算建好了，接下来我们要在Manifest文件中声明这个contentprovider，代码如下: &lt;provider android:exported=&quot;true&quot; android:multiprocess=&quot;true&quot; android:authorities=&quot;com.example.android_textsqlit.MyContentProvider&quot; android:name=&quot;.MyContentProvider&quot;&gt; &lt;/provider&gt; 其中authorities就是你的contentprovider的地址，这里需要说明一下，contentprovider是在你这个应用程序安装的时候就会注册到providerManager中，这就像是有一个链表，其中放着很多的URI，当你使用contentResolver去调用这个contentprovider时的各个方法时，就会通过传入的URI来寻找到对应的进程，然后启动这个进程(注意是进程，而不是包括这个进程的整个应用程序)，这里的启动是通过contentprovider来启动的，而不是通过mainactivity来启动，启动之后，当我们的contentprovider用完之后，客户端也退出后，服务器端(也就是contentprovider)就会变为emptyprocess，等待回收。2.我们创建一个客户端来调用contentprovider，主要代码如下: public void LinkContentProvider(){ ContentResolver _resolver=getContentResolver(); Log.i(&quot;Logcat&quot;, &quot;Link&quot;); cursor = _resolver.query(Uri.parse(&quot;content://com.example.android_textsqlit.MyContentProvider/user&quot;), null, null, null, null); Log.i(&quot;Logcat&quot;, &quot;Link1&quot;); }这是得到contentresolver对象，并且通过resolver对象的query()方法来调用contentprovider的query()方法，然后将返回的cursor对象赋值给变量cursor，得到cursor后就很好办了。代码如下: public void Show(View v){ list=new ArrayList&lt;HashMap&lt;String,String&gt;&gt;(); while(cursor.moveToNext()){ map=new HashMap&lt;String, String&gt;(); int userid=cursor.getInt(cursor.getColumnIndex(&quot;userid&quot;)); String username=cursor.getString(cursor.getColumnIndex(&quot;username&quot;)); map.put(&quot;userid&quot;, &quot;&quot;+userid); map.put(&quot;username&quot;, username); list.add(map); } SimpleAdapter simpleAdapter=new SimpleAdapter(MainActivity.this, list, android.R.layout.simple_list_item_2, new String[]{&quot;userid&quot;,&quot;username&quot;}, new int[]{android.R.id.text1,android.R.id.text2}); myListView.setAdapter(simpleAdapter); }这样就将内容显示在了listview上，这里说一下我为什么不使用SimpleCursorAdapter，因为使用SimpleCursorAdapter必须要求主键为_id，而我定义表的时候主键不是这样的，所以我就只好用 SimpleAdapter了。这样我们就实现了简单的自定义的contentprovider了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://sakurajiang.github.io/tags/ContentProvider/"}],"keywords":[]},{"title":"初试Rxjava","slug":"Android-初试Rxjava","date":"2016-07-26T16:00:00.000Z","updated":"2020-07-06T12:11:01.538Z","comments":true,"path":"2016/07/27/Android-初试Rxjava/","link":"","permalink":"http://sakurajiang.github.io/2016/07/27/Android-初试Rxjava/","excerpt":"","text":"配置环境 只需要在项目中的build.gradle中加入 compile &#39;io.reactivex:rxjava:1.0.14&#39; compile &#39;io.reactivex:rxandroid:1.0.1&#39;这两行代码就行。 开始理解RxjavaRxjava采用的是观察者模式，由于我之前知道回调模式，而且我觉得回调模式是比较特殊的观察者模式，它只有一个观察者，所以我拿回调模式进行类比，首先，对于回调模式而言，它一般是暴露一个方法和接口，这里我就直接拿我自己写的一个回调机制来做比较，代码如下:被观察者类: 订阅:开始类比，由上面的代码知道，被观察者是定义了发生怎样的事件和何时发生，看onBindViewHolder(参数)这个方法，这就类比于这个代码，这里的onBindViewHolder(参数)方法和rx.Observable.OnSubscribe&lt;Bitmap&gt;抽象类的作用是一样的，就是设置了发生了什么事以及何时发生(记住是发生以及何时发生，而不是处理了)，然后再加上Observable observable = Observable.create(OnSubscribe类型参数)就是创建了一个被观察者，这里需要记住的就是发生怎样的事件和何时发生是在被观察者中的。然后就是订阅这个，这里完成了两个过程，首先是创建观察者，就是：这其实就是定义(不是声明)了接口中的两个方法，就是建立了观察者，同时通过myRecyclerViewAdapter.setOnItemClickListener(参数)来订阅，建立观察者就是：整个过程类比Rxjava就是:这里就是建立了观察者，同时订阅了，建立观察者就是订阅就是subscribe(参数)完成，这里需要记住的就是定义事件是发生在观察者中，然后通过subscribe(参数)来订阅。observable，observer，subscribe，OnSubscribe的关系可以用下图表示:","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"listview的简单使用","slug":"Android-listView的简单使用","date":"2016-07-25T16:00:00.000Z","updated":"2020-07-06T09:16:45.972Z","comments":true,"path":"2016/07/26/Android-listView的简单使用/","link":"","permalink":"http://sakurajiang.github.io/2016/07/26/Android-listView的简单使用/","excerpt":"","text":"其实对于listView的使用，我们可以参照spinner，因为这两个都是AdapterView，对于AdapterView，我们可以总结为以下四步：1.建立数据源2.建立Adapter3.建立Adapter-dataSource的连接4.绑定adapter到界面组件上(AdapterView)这里需要说明的是，一般来说第二步和第三步都是一起写好的，同时，注意第三步的用词是连接，这很关键，这意味着一旦数据源改变了，我们只是需要再进行第四步就行，因为已经连接好了，这个在listView的插入删除时可能有用，之所以说可能，是因为官方提供了list.add(myEditText.getText().toString());和adapter.notifyDataSetChanged();组合进行增加，adapter.notifyDataSetInvalidated();方法进行删除，不是用更改数据源后再重新绑定的法子，当然，这个也行，代码可以写成：list.add(myEditText.getText().toString());和setListAdapter(adapter);组合是增加，list.remove(1);和setListAdapter(adapter);组合是删除。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"}],"keywords":[]},{"title":"spinner的使用以及自定义Adapter中的getView()什么时候调用","slug":"Android-spinner的使用以及自定义Adapter中的getView()什么时候调用","date":"2016-07-25T16:00:00.000Z","updated":"2020-07-06T09:18:53.415Z","comments":true,"path":"2016/07/26/Android-spinner的使用以及自定义Adapter中的getView()什么时候调用/","link":"","permalink":"http://sakurajiang.github.io/2016/07/26/Android-spinner的使用以及自定义Adapter中的getView()什么时候调用/","excerpt":"","text":"今天在看的是spinner是如何使用的，这里分两种：第一种是直接在xml文件中设置，用到的属性是android:entries=””,当你写完这个之后就可以直接运行了。既然有xml静态的方式，那么另一种大家都懂，就是在代码中动态的写，这里又可以分成两种，第一种使用的是new 一个ArrayAdapter对象，这里需要传递几个参数，第一个是context对象，第二个是布局，第三个是你的数据源对象，这里着重说一下第二个参数，这个参数可以直接使用系统的参数android.R.layout.simple_spinner_item，其实这个就是一个textview，我们也可以自己定义一个layout，其中有textview，然后将这个参数换成自己定义的布局，布局中的textview这两个参数，结果也是可以得。其实创建一个spinner大概可以分成下面四步：1，创建数据源2，创建Adapter3，将数据源和Adapter连接起来4，将Adapter和Adapterview连接起来。但是现实情况下，我们不可能只用系统定义好的Adapter，我们还需要自定义Adapter，那么如何自定义Adapter呢？自定义一个Adapter就需要先继承BaseAdapter，然后重写其中的方法，有getCount(),getItem(int arg0),getItemId(int arg0),getView(int arg0, View arg1,ViewGroup arg2)，其中最重要的就是getview()方法，这个方法我还不是很理解，但是大概就是每次显示一个item时都需要调用这个方法（因为还没有旧的view），当显示完了之后。如果屏幕移动了之后，并且导致有些Item（也可以说是view）跑到屏幕外面，此时如果还有新的item需要产生，则这些item显示时调用的getview方法中的convertview参数就不是null，而是那些移出屏幕的view（旧view），我们所要做的就是将需要显示的item填充到这些回收的view（旧view）中去，最后注意convertview为null的不仅仅是初始显示的那些item，还有一些是已经开始移入屏幕但是还没有view被回收的那些item。同时在这个方法中，我们应该设置将数据源的数据显示在Adapterview上，因为这正是Adapter的功能，然后写好Adapter后，我们在acivity中依然按照上面的四步写代码，这样一个自定义的Adapter和AdapterView就完成了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"关于使用回调设置监听和在activity中设置监听的一些问题及实验","slug":"Android-关于使用回调设置监听和在activity中设置监听的一些问题及实验","date":"2016-07-25T16:00:00.000Z","updated":"2020-07-06T09:19:33.839Z","comments":true,"path":"2016/07/26/Android-关于使用回调设置监听和在activity中设置监听的一些问题及实验/","link":"","permalink":"http://sakurajiang.github.io/2016/07/26/Android-关于使用回调设置监听和在activity中设置监听的一些问题及实验/","excerpt":"","text":"测试view中的回调方法和activity中的onClickListener(参数)方法的执行顺序，以及activity中和自定义view中的同样的方法的执行顺序。当我在自定义view和activity中分别重写onKeyDown(int keyCode,KeyEvent event)，onKeyUp(int keyCode,KeyEvent event),onTouchEvent(MotionEvent event)方法时，发现对于onkeyDown（参数）和onKeyUp(参数)方法而言，方法的执行顺序是先执行view中的onKeyDown(参数)然后执行activity中的onKeyDown(参数)方法，然后执行view中的onKeyUp(参数)和activity中的onKeyUp(参数)方法，但是对于onTouchEvent(参数)方法而言，只是运行view中的onTouchEvent(参数)方法，对于activity中的onTouchEvent(参数)方法不会执行，但是会执行activity中的onClickListener方法，顺序是先执行view中的再执行activity中的onClickListener(参数)方法。 疑惑：为什么点击屏幕时不会调用activity中的onTouchEvent(参数)方法，而是调用onClickListener()方法，按照sundy老师的讲述，对于硬按键被按下时会发一个系统消息，消息的内容大概是哪个按键被触发了，那么这个消息谁来接收呢？是由当前活动状态的上下文接收，这个上下文是在活动的activity里的，activity再发给phonewindow，phonewindow再发给viewtree中的view root，从view root中开始查找焦点元素，然后在这里开始处理这个事件，这里就会有一个事件上传机制，就是说，若这个焦点元素不想处理这个事件，那么就可以将这个事件上传给它的父容器，这样依次传递，这个传递机制是通过处理事件方法的返回值来判断的，若是true，就不传递，表示这个事件处理完毕，若是false或者是默认值就开始往上传递，最上就是activity。而对于屏幕被按下的情况，按下屏幕时也会发一个系统消息，而这时是通过点击的位置来快速查找焦点元素，然后在这里开始处理这个事件，这时就和硬按键被按下一样了。这里有一个特殊情况，当输入法打开时，硬键盘被按下的消息首先传递给输入法窗体，不再发给viewtree中的view root，而对于现在的软键盘而言，若软键盘被打开，则消息传递给软键盘。 结论是：view的先执行，activity的后执行，但是当按下硬按键时会执行view和activity中的，而按下屏幕时是执行view中的，然后执行activity中的onClickListener()方法。 对于点击屏幕时不会调用activity的onTouchEvent(参数)方法，而是调用onClickListener(参数)方法这个结果做的实验。当我将onClickListener(参数)方法注释时，执行顺序是在view中的onTouchEvent(参数)方法中寻找到与按下动作一致的action_down这个动作，然后跳转到activity中的onTouchEvent(参数)方法中，寻找action_down这个动作，然后再继续在activity中的onTouchEvent(参数)方法中寻找接下来的动作，不再跳转回view中，而将onClickListener(参数)方法写进去时，执行顺序是在view中的onTouchEvent(参数)方法中寻找与按下动作一致的MotionEvent.ACTION_DOWN这个动作，然后接着找寻接下来对应的动作，直致找寻完后，再跳转到activity中的onclicklistener()这个方法中，不会再去activity中的onTouchEvent(参数)方法中。 结论是如果有onClickListener()方法，就会在view中的onTouchEvent(参数)方法中寻找对应的动作，寻找完所有的动作后就会跳转到activity中的onClickListener()方法中，而对于没有onClickListener()方法的activity，就会先在view中寻找第一个动作，当执行完一次onTouchEvent(参数)方法后然后跳转到activity中的onTouchEvent(参数)方法中，寻找与按下动作一致的MotionEvent.ACTION_DOWN动作，也就是与第一个动作一致的代码块中，然后再执行activity中与接下来动作一致的代码块，不会再回到view中。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"使用RecyclerView遇到的一些问题","slug":"Android-RecyclerView的简单使用","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:17:23.455Z","comments":true,"path":"2016/07/21/Android-RecyclerView的简单使用/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-RecyclerView的简单使用/","excerpt":"","text":"###1.无法使用RecyclerView，因为我们没有导入v7包 我们如何导入呢？因为我使用的是AS，所以我这里说一下AS的导入，首先，你找到你项目中的build.gradle，注意这里有两个build.gradle，那么我们需要找哪个呢？下面我放了一张图片那么我们应该选哪个内容呢？我们应该选第二个，点进去第二个后，找到dependencies，如图：我们将这个修改为:这里需要注意版本要保持一致，如两张图中都是v7:23，这样应该就没有问题了。 ###2.使用RecyclerView时，需要自定义一个Adapter继承Recycler.Adapter 这里需要继承的是泛型类，比如:其中ＭyRecyclerViewAdapter是自定义的Adapter，而MyViewHolder是ＭyRecyclerViewAdapter中的内部类，继承了RecyclerViewAdapter.ViewHolder，如下:","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"}],"keywords":[]},{"title":"Activity Window View的关系","slug":"Android-activity window view的关系","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:16:06.230Z","comments":true,"path":"2016/07/21/Android-activity window view的关系/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-activity window view的关系/","excerpt":"","text":"activity.java的attach()方法，这个方法传入多个参数，有Context,ActivityThread，Instrumentation等等，我们先不管他们，我们直接找到mWindow = PolicyManager.makeNewWindow(this);这一行代码，也就意味着我们需要找PolicyManager.java，这时我们需要找的是policy这个类，而不是Ipoliy，因为Ipolicy是一个接口，这时看到的是new PhoneWindow(context);也就是说attach()方法是得到一个phonewindow对象，那么这个对象是怎么得到的呢？我们继续跟踪，去看PhoneWindow.java看这个类的构造函数，需要调用父类的构造函数，而父类是window，我们看一下，发现mContext = context;于是我们回到phonewindow.java中，看到mLayoutInflater = LayoutInflater.from(context);我们进入到LayoutInflater.java中，这是一个抽象类，我们找到from()方法，这个方法类似于得到一个系统服务，并且得到LayoutInflater类型的变量，如果LayoutInflate这个类型的变量为空，就会抛出错误LayoutInflate not found.。然后返回LayoutInflate类型的变量，也就是说phonewindow的得到其实就是根据Context得到一个系统服务而已，然后我们回到activity.java中，我们去看setContentView()方法，我们可以看到它调用的是window的setContentView()方法，我们进入看一下，会发现其实就是说根据你传入的值来设置view的样子，有两种参数，一种是int layoutResID，还有一种是View view, ViewGroup.LayoutParams params，这两种参数都行。第一种就会调用LayoutInflater中的inflate()，这个方法至少传入两个参数，如果viewgroup类型的参数为null，就会返回一个view对象，如果不是null，就会调用viewGroup的addview()方法，而第二个就会直接调用ViewGroup的addView()方法。也就是说我们可以直接使用以下一些代码来替代eclipse给我们的 setContentView(R.layout.activity_main);比如: LayoutInflater LayoutInflater1 = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); getWindow().setContentView(LayoutInflater1.inflate(R.layout.activity_main, null));或者: LayoutInflater LayoutInflater1 = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE); getWindow().setContentView(LayoutInflater1.inflate(R.layout.activity_main, null),new ViewGroup.LayoutParams(-1, -1)); 这一种与上一种类似，不过我们就是使用了传入两个参数的setContentView(view arg0,layoutparas arg1)的方法，这里就需要提一下后面的这个参数，在phoneWindow.java的传入一个参数的setconteneView()方法的源码中是这样的setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));这里的MATCH_PARENT其实是viewgroup的public static int类型的变量，值是-1，之所以这里能直接使用是因为在phoneWindow.java类中导入了，我也是后面反应过来的，语句是import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;这是java的基础知识，就不解释了。或者：getWindow().setContentView(LayoutInflater.from(getBaseContext()).inflate(R.layout.init, null),new ViewGroup.LayoutParams(-1, -1));当然还有很多种搭配方式，这里就不一一赘述了。总之，LayoutInflater中的inflate()方法的作用是返回一个不为空的view对象，或者是调用addview()方法并返回传入的viewGroup参数，这个根据你传入的ViewGroup类型的变量是否为空，若为空就返回一个不为空的view对象，若不为空就调用addview方法并返回传入的viewGroup参数，也就是说如果我们能提供一个不为空的viewgroup类型的参数，那么我们就可以直接使用inflate()方法来设置view（但是我提供了一个不为null的viewgroup对象，，下面是我的代码 Button b=new Button(this); b.setText(“b”); LinearLayout linearLayout=new LinearLayout(this); linearLayout.addView(b); linearLayout.setLayoutParams(new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)); LayoutInflater.from(getApplicationContext()).inflate(R.layout.activity_main, linearLayout);但是布局是一片空白，我也不知道为什么？），类似于 LayoutInflater.from(this).inflate(R.layout.activity_main,new AbsoluteLayout(this,null,R.id.myButton) );但是我并不知道如何构造一个不为空的viewgroup对象，然后我们利用返回的view对象当参数传入phoneWindow.java中的setContentView(View view);方法中，然后这个方法调用addview()方法来设置view，至于后面那个可有可无的参数，若不传入，则是宽度高度都是match_parent，也就是为-1，若传入自己设置值，只有-1，-2两个选项有意义，但是我把-1变为-2好像没影响，这个参数应该是控制这个view的宽度和高度呀，但是为什么没影响。。。一个activity构造的时候一定会构造一个phonewindow对象，并且只有一个，activity是控制单元，window是承载单元，view是显示视图，打个比方就是，activity是工匠，他做了一个窗户，而窗户需要贴窗花才好看，layout的那个xml文件就是剪窗花，剪完窗花需要贴上去，而addView就是将窗花贴到窗户上去。 不过这里有一点搞不太明白，就是得到一个LayoutInflater的引用时，由于这个方法是一个抽象方法，也就是意味着不能直接new，我们可以使用两种方式，一种是使用这个LayoutInflater类中的静态方法from()，还有一种就是 LayoutInflater LayoutInflater = (LayoutInflater) this.getSystemService(Context.LAYOUT_INFLATER_SERVICE);(其实这就是from()方法中的主要代码)，可是怎么实现的呢？通过对源码的跟踪我发现当你使用from这个方法时，你会发现当你传入不同的context参数，显示的效果会不同，对于一个button控件而言，用这个参数会是浅黑色的，用getbasecontext是白色的，但是不管你用什么参数，最后应该都会到contextthemewrapper.java中，而这里的代码是这样的：if (LAYOUT_INFLATER_SERVICE.equals(name)) { if (mInflater == null) { mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this); } return mInflater; } return getBaseContext().getSystemService(name);这里我就蒙圈了，也就是说它会回到from方法中，可是也没有看到有构造这个对象呀，回到from的话不就又开始周而复始的调用吗？","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"Activity源码分析准备阶段","slug":"Android-activity源码分析准备阶段","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:16:31.911Z","comments":true,"path":"2016/07/21/Android-activity源码分析准备阶段/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-activity源码分析准备阶段/","excerpt":"","text":"昨天装好了source insight，今天看了一下activity.java这个类，为什么看这个类呢，因为在我学习android过程中见过最多的就是这个，于是我先看了一下经常见到的oncreate方法，在看到onstart方法时，我发现一个叫mLoaderManager的对象，而这个对象是一个叫LoaderManagerImpl的类，并且调研了doStart这个方法，可是我并没有在这个类中找到这个方法，由于刚用这个软件，我通过摸索一下发现原来在软件的左边输入关键字查找只会找出你在右边输入的这个类中的东西，于是我就在右边输入LoaderManager.java，为什么我没有输入LoaderManagerImpl.java这个类呢，因为通过名字我感觉这是一个实现了LoaderManager.java这个接口的类，于是我就去找这个接口，结果发现这个一个抽象类，并不是接口，而且也没看到doStart这个方法，不过我在这个抽象类后面看到了LoaderManagerImpl类，在这个类中找到了doStart方法，兴奋点来了，这个函数的代码的作用就是抛出一个异常，同时打印出 Log.w(TAG, “Called doStart when already started: “ + this, e);然后return。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"}],"keywords":[]},{"title":"写一个简单的加载多张图片的自定义View","slug":"Android-写一个简单的加载多张图片的自定义view","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:19:44.951Z","comments":true,"path":"2016/07/21/Android-写一个简单的加载多张图片的自定义view/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-写一个简单的加载多张图片的自定义view/","excerpt":"","text":"先说一下思路吧，其实很简单，就是将图片黏在视图上就可以，首先加载出显示的视图，然后加载出一个imageView，然后将这个imageView贴上去，这个贴的时候注意贴的位置，不要重复了，为了达到这个目的，我使用的是layoutParams.setMargins(left, 40 + top, right, bottom);方法，然后设置循环加载就可以实现加载多张图片，下面会贴出代码，由于代码极少，我就直接放图片吧。然后，在这里需要说一下，图片中注释了的代码，为什么我要注释这行代码，并将这行代码写到findBitmap()之前呢？因为如果我不这样做，到最后只会加载一张图片，因为这行代码的作用是根据出入的layout加载出视图，而我们都是对视图操作的，在这里就是说，我们是将image贴在视图上，而不是layout上，所以，如果我不这么做，那么每次都是将image贴在新的不同的视图上，到最后setContentView时，传入的mainViewGroup其实就只是贴了一张图上去，所以我需要修改，当然这里可以将前面的这些viewGroup的加载也放在外面，这样就不会多次循环，我这样写，只是为了说明这个问题。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"}],"keywords":[]},{"title":"创建一个简单的对话框","slug":"Android-创建一个简单的对话框","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:19:55.786Z","comments":true,"path":"2016/07/21/Android-创建一个简单的对话框/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-创建一个简单的对话框/","excerpt":"","text":"在android中创建一个对话框可以通过直接用AlterDialog.Builder类来创建一个对象，然后通过调用这个对象的setMessage()设置这个对话框的的显示信息，如果你需要类似于确定、取消这种按钮，你可以调用这个对象的setPositiveButton()方法和setNegativeButton()方法，当然你还可以创建一个类，让它继承DialogFragment这个类，然后复写onCreateDialog的方法，在这个方法中用AlterDialog.Builder类来创建一个对象，然后和上述一样操作，这是对于使用AlterDialog.Builder类的两种形式，其本质是一样的，而另一个方法同样是创建一个类，让它继承DialogFragment这个类，只不过复写的是onCreateView()方法，这个方法需要你自己定义一个布局，这个布局的作用是给你创建的对话框使用的，然后通过View view=inflater.inflate(R.layout.activity_dialog, container);代码，将布局文件和对话框匹配到，然后return view;，通过这种方式得到对话框的好处是自己可以定义对话框的格式，但是我发现通过这种方式创建的对话框无法通过点击取消按钮来退出对话框，然后我上网查询如何做到通过按钮取消，发现全是用AlertDialog.Builder来创建对话框的，没有看到用这种方式创建对话框，即使有的话也没有说如何点击取消按钮来退出对话框，然后我就想算了，反正知道一个方法就好了，管他呢，然后就没管。 但是昨天晚上有个人打电话给我，我们聊了挺久，他说程序员应该较劲，应该有一点强迫症，然后我就觉得不能放弃，然后我今天又重新写这个程序，昨天我虽然没做对，然后我今天按照书上的程序打了一下，但是书上的程序写的好复杂，而且大家都懂的，看这种类型的书需要一个章节的看，因为它可能由于之前写了这份代码，然后在这里就没写，但是这一章内容有点多，于是我便将实现对话框的主要函数看了一下，然后当我把这些自己写在程序中时（我又重新建了一个项目，因为这样看上去比较简洁，不会有别的因素干扰），发现书上的代码是建了两个activity，一个是用来构建对话框，还有一个是调用这个activity的主界面activity，但是我自己的是一个activity，我又不想重新写过，然后我就停下来思考，我如果继续这样写下去，就会遇到和昨天一样的问题，那就是在一个activity中有两个布局文件，如果我用findViewById()方法来找到对话框布局文件中的控件，这时就会报空指针异常，大意是说这个控件的引用是空的，也就是说我无法通过findViewById()方法来找到对话框布局文件中的控件,然后我就百度了一下findViewById()方法的作用，然后发现是因为我用的是findViewById()方法，这个方法默认省略了this，而如果你需要获取别的xml文件的控件，就需要通过获取的View调用findViewById()方法然后就发现这个问题解决了，然后运行程序，但是我又发现点击取消按钮还是没用，然后发现原来是我没有绑定到监听器中，没有添加sureButton2.setOnClickListener(this);这行代码，然后完成后运行就发现可以了。这时我又想，这个this到底是什么呢？我已经见过很多次了，但是糊里糊涂的，还有findViewById()方法到底是怎么实现的，然后我就开始查询源代码，因为我是用view调用了findViewById()方法，所以我就直接去查了view，然后在view中找到了这个方法，然后发现在这这个方法中调用了findViewTraversal()方法，但是这个方法中只有 {if (id == mID) { return this;} return null;}这些代码，然后问题来了，这个mID在Source Insight软件中是黑色的，就是说不能再点进去，线索到这就断了，然后我就找View的最开始，这一般是我的习惯，当线索断了时我就会往最上面翻，然后看到这行代码：@see android.view.ViewGroup，这时我就直接在右边输入了ViewGroup这个类，然后查找了一下findViewById这个方法，但是发现没有，然后我就想，这个findViewById到底是怎么实现的，函数体是什么？然后我就百度了一下使用findViewById()要引用哪个包，我的本意就是想知道这个方法到底在哪被实现了查找的功能，结果我看到一篇深入理解findViewById原理的文章，点进去看了一下，结果令我无语的是前面的步骤和我差不多，但是就在ViewGroup这个View的子类中居然还隐藏着findViewTraversal()方法，也就是说ViewGroup重写了这个方法，然后我继续阅读这篇文章，然后看到这个方法的函数体，这个函数体的返回一个View对象，看这篇文章上写的原理是说，从头开始找，遇到有子控件的就递归接着找，我自己看这个函数是没有看到这样的结果，我只是看着代码，觉得它是在循环找对应id的控件，因为下面一行代码看的不是很清楚：v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0，mPrivateFlags变量实在View类中定义的，而PFLAG_IS_ROOT_NAMESPACE实在ViewGroup中定义的，前面的是一个int型，后面的是一个十六进制的数，不是很懂这是什么意思，但是通过单词的意思大概是一直寻找直到这些标志位变为零，然后就找到这个view，然后返回，这时我想这个方法返回的是一个View又不是控件，是不是还没结束，但是我又找不到别的线索，然后我就想是不是控件都是View的子类，然后去看继承关系发现果然是，这也就是说我大概明白的这个findViewById()大概是怎么个原理，也就是说这个方法是View中的，我们习惯上用的方式是省略了this,也就是对应的View，然后返回一个View对象，这个对象是控件的引用，那么这个问题解决了，还有一个问题，this到底是什么呢？","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"测试保存activity状态用preference的方式","slug":"Android-测试保存activity状态用preference的方式","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:20:42.079Z","comments":true,"path":"2016/07/21/Android-测试保存activity状态用preference的方式/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-测试保存activity状态用preference的方式/","excerpt":"","text":"this.getPreferences(MODE_PRIVATE).edit().putString(“name”, myEditText.getText().toString()).apply();（apply()也可以用commit()代替），这行代码从调用完getPreferences（）方法后，后面的所有方法都是SharedPreferences接口中的， （这是我后面看自己博客时写的这个，接口被SharedPreferencesImpl类实现，） 那么调用这些方法怎么保存EditText的信息到一个xml文件中的呢？而且用这个方式保存数据的activity不管是按back，home，系统自动销毁，自己主动关闭这个activity都会保存数据并且恢复，那么也就是说这中方式适合永久保存数据。然后我就想到如何删除这些数据呢？通过上网查询，发现是用this.getPreferences(MODE_PRIVATE).edit().remove(“name”).commit();其中的”name”是你用putString()方法放进数据时的键，然后在试验的时候我发现一个很有趣的现象，因为一开始我的activity只是实现了onPause(),onCreate(),onDestroy()，onResume()方法，所以我把删除数据的程序放在onDestroy()方法中，但是结果就是无法删除，这时我就纳闷了，为什么呀？难道删除不是这么做的？然后我就又去网上搜索，发现是这样的，我就在onDestroy()方法中输入两条Log语句，将删除程序放在中间，结果发现两条Log语句只会输出第一条，第二条不会输出，但是当你再打开这个应用程序时，它又会输出我在onCreate()方法中的Log语句，也就是说这个activity是被销毁了，但是很明显onDestroy语句没有实现完，如果我把onDestroy()方法中的删除程序去掉，那么Log语句都会打印出来，这说明删除程序阻碍了onDestroy()方法的运行，但我搞不懂是如何实现的额，如果我是按back键返回的话，那么所有的Log语句都会打印出来，而且数据也会被删除，我是用真机测试的，用的是红米note2，我清除活动时是直接按菜单键，在弹出的界面中直接删了的，然后我复写onStop()方法，也是两条Log语句，发现这个Log语句打印出来了，而且也删除了，这就说明onPause()方法比onDestroy()方法更适合处理操作。（这里的我清除活动时是直接按菜单键，在弹出的界面中直接删了的这个做法，可能是miui系统自己写的删除，不是原生的android系统，并且onPause()方法的确比onDestrory()方法更适合处理这种保存的工作，但是onStop()方法应该更适合）。 可是对于SharedPreferences接口是怎么做到这些的我还是不明白，以及onDestroy()怎么实现的我也不懂，看这段源码看不懂。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"测试保存activity状态","slug":"Android-测试保存activity状态","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:20:30.028Z","comments":true,"path":"2016/07/21/Android-测试保存activity状态/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Android-测试保存activity状态/","excerpt":"","text":"今天用onSaveInstanceState(Bundle outState)方法测试保存activity状态，发现跟视频的不一样，结果都是会保存，后来看源代码也没看懂，之后在网上查资料时发现，原来如果我们没有复写onSaveInstanceState这个方法，这个方法的默认实现会自动保存activity的某些数据，同时网上的资料上还有这句话：android应用框架中定义的几乎所有的UI控件都恰当的实现了onSaveInstanceState()方法，因此当activity被销毁和重建时，这个UI控件会自动保存和恢复状态数据，看到这句话时，我就想，这onSaveInstanceState()方法不是activity的吗？为什么又变成了UI控件实现了onSaveInstanceState()方法？是说activity和UI控件同时继承了一个类或实现了同一个接口吗？于是我便查看这两个的继承关系，结果发现UI控件的继承关系是view-object，而activity是ContextThemeWrapper-ContextWrapper-Context-Object这样的层次关系，从上我们可以发现它们共同的只不过是Object这个类，这是一切的父类，然后我在这里没找到onSaveInstanceState()方法，然后我就想不明白了，这个意思是说它们分别定义了这个方法吗？ （于是我便回到activity.java这个类中在看一下这个方法，发现它没有使用@Override标记，也就是说这是自己的方法，然后我去view.java中看，发现这也没有@Override标记，也就是说也是自己的方法，也就是说这是两个不同的方法，果然，它们的方法标签都不相同。–这是我自己回过头来看自己写的博客时重新写的话，这时的我已经回头重新看了一下java，收益良多，发现自己的java知识很薄弱，感觉学android并不像网上说的那样，说什么java会基础的就行，不过也没说错，毕竟他们没说基础的范围。。。） 于是我便在EditText中找onSaveInstanceState()方法，没有找到，，然后我去查找EditText的继承关系,发现它继承自TextView，于是我便在TextView中找，然后我找到了onSaveInstanceState()这个方法，然后这个是复写View的方法，先判断TextView中是否有数据，有的话就开始保存，返回一个parcelable对象，那么还有问题，在声明EditText控件时，是声明为EditText对象，并不是TextView对象，也就是说声明的EditText对象不能使用TextView的onSaveInstanceState()方法，那么它是如何做到保存的呢？然后我上网查询TextView和EditText可以相互转换吗？然后没看到类似的结果，然后我突发奇想，我在eclipse中定义一个EditText对象，然后看它能否调用onSaveInstanceState()方法，结果可以。。。那么为什么呢？（这也是我后面看自己博客时写的，对于上面自己写的话表示汗颜，因为一个类继承了父类后也就继承了父类所有的public和protected修饰的变量，当然如果在同一个包中，那么默认的也会被继承，而这个方法是protected修饰的，自然edittext能用。） 既然能调用，那么EditText对象是什么时候会调用onSaveInstanceState()这个方法呢？当在activity中调用onSaveInstanceState()方法时，EditText对象会调用onSaveInstanceState()方法吗？如果会，这两个方法之间怎么联系呢？整个保存数据和恢复数据的过程是什么？等下实验一下如何让EditText对象调用onSaveInstanceState()方法。实验的结果是直接用EditText对象调用onSaveInstanceState()方法，返回一个parcelable对象，然后直接打印出来的结果就是你在EditText中输入的内容，输出结果是：TextView.SavedState{53e150e start=5end=5 text=dhjvg},其中的dhjvg是自己在EditText输入的内容，可是后面两个我还是不知道，以我的知识很难弄明白它。（ 关于这些问题，其实上面解答了一部分，在控件中的onSaveInstanceState()方法其实就是用几个if语句来判断，首先判断是否为空，不为空就把boole型变量save赋值成true，然后再保存，保存是用SavedState类来实现的，然后返回这个类类型的变量，恢复数据应该是在textview的构造函数中恢复的，）","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://sakurajiang.github.io/tags/Android/"},{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"}],"keywords":[]},{"title":"java类与继承","slug":"Java-java类与继承","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:30:21.713Z","comments":true,"path":"2016/07/21/Java-java类与继承/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Java-java类与继承/","excerpt":"","text":"最近认真的看了一下java的类与继承，感觉收益良多，以前不知道或者记得不是很清楚的现在都比较清晰了，首先，对于java这种面向对象的 语言而言，一切都是类，所有的代码都是写在类中的，在java的世界中，人，电脑，树等等都可以称为类，那么，类怎么定义呢？与现实相同人拥有年龄，眼睛等等信息，这些信息在构建一个people.java这个类时就是属于数据成员，一个人能够奔跑，吃饭，睡觉，思考等等，这些是人能做的事，这在java中是属于方法(函数),那么如何奔跑就需要在这个方法中的方法体内定义了，比如快步走，跑等，事实上我们老是说人，其实还不够具体形象，因为人是一个泛称，因为每个人都是不同的，那难道我们需要定义无数个类吗？当然不是，就好比难道女娲将所有的人都造出来了吗？并不是，那么地球上这么多人怎么来的呢？哎呀，需要说一些羞羞的事了，好高兴呀！当然是通过“生”这种方式来的，那么总得有个最初的吧，的确，这在java中对应的是Object这个类，那么现实中我们是称呼把自己生下来的人称为父母，这在java中被称为父类，这个父类代表的就是现实中的父母，那么在现实中，你只可能由一个父母生下来，不可能有两个亲生父母，这在java中被称为单一继承，那么，当我们还是一个刚生下来的小孩时，我们有什么呢？我们依然有年龄，眼睛等等信息，但是我们并不是拥有父母的所有数据成员，比如，他们拥有阅历，经验，我们并没有，这就对应于java的父类中的私有成员或者是不同包的在父类中定义为默认的成员，我们依然会睡觉，思考(这一个就不知道会不会了)等，但是我们会奔跑吗？不会，也就是说我们只是会其中一部分，另外的一部分还需要我们自己长大，也就对应于java的重写方法，那么我们跟父母一样吗？很明显我们不一样，因为我们拥有自己的性格，自己的阅历，以及自己的奔跑方式，思考方式等，可是，在现实中经常会有人说，哇，你长的好像你的父母，那么这个对应于什么呢？这个对应于java中的每个子类对象都拥有自己的父类对象，那么，等你有一天有了自己的小孩，这在java中就对应于每个父类也可以是别的类的子类，那么，你可以称呼自己的小孩为儿子，而你的父母则是称呼他为孙子，那么这个小孩是你和你老婆生下来的，他跟你们会有相似之处，跟你的父母也会有相似之处，同时你们的父母，都可以叫你们吃饭，睡觉等等做一些事情，当你的父母叫你睡觉时，你可能会说知道了，但是并不会马上睡觉，而你的父母跟你小孩说的时候，他可能马上就会睡觉，那么这对应于java中的什么呢？这对应于java中一个很重要的称为多态的机制，就是说父类的引用可以指向子类的对象，当父类执行某个大家都有的方法时，会根据具体的对象去执行具体的方法中的方法体(当子类的对象指向父类的引用，当这个引用执行父类和子类都有的方法时，会去执行子类的方法，而不是父类的方法)，这就是多态。假设你父母由于年纪大了，容易生病会咳嗽，但是他们不可能叫你咳嗽，因为你们年轻，不太会生病咳嗽(这就是说当子类的对象指向父类的引用，那么当这个引用执行父类独有的方法时，是执行父类的方法，而不是子类的方法，其实也是白说，因为子类都没有这个方法。)，对于你的这个家族，你们可以相互帮忙，家族这对应于java的包。","categories":[],"tags":[{"name":"干货","slug":"干货","permalink":"http://sakurajiang.github.io/tags/干货/"},{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]},{"title":"如何在github上建立自己的个人博客","slug":"Github-如何在github上建立博客","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T12:03:30.970Z","comments":true,"path":"2016/07/21/Github-如何在github上建立博客/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Github-如何在github上建立博客/","excerpt":"","text":"如何在github上建立博客呢？ 我前期都是按照this link这个链接进行了操作，这里解释一下同步内容至Github中的第五步操作，我因为这个步骤没弄明白，搞了两天，这个步骤的意思是，将运行命令hexo g生成的public文件夹下的所有内容复制到你的对应仓库目录里，注意是里面，同时，还有一点，如果你建立的这个仓库是发布过的，那么你就将那些东西全部删除，最好最开始这个仓库里不要包括任何东西，然后将public文件夹中的东西复制过来。不过这里还有一种方式，那就是配置hexo的_config.yml文件，配置的内容如下，找到deploy，将配置为下: 这样就不需要手动复制public文件夹中的内容到仓库目录里，只需要再运行hexo d命令行就可以。如果你的博客内容更新了，那么在hexo g生成public文件夹之前，最好先运行hexo clean来删除之前的public。至于如何更换网页的主题，只需要将你需要的主题下载到hexo的themes文件夹中，然后在_config.yml中修改主题就可以。","categories":[],"tags":[{"name":"Github","slug":"Github","permalink":"http://sakurajiang.github.io/tags/Github/"}],"keywords":[]},{"title":"java基础知识之static","slug":"Java-java基础知识之static","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:24:34.697Z","comments":true,"path":"2016/07/21/Java-java基础知识之static/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Java-java基础知识之static/","excerpt":"","text":"static对于static这个关键字，我们可以用它来修饰类，代码块，方法，变量。用这个关键字修饰了之后，就说明你跟类的对象没有依赖关系，比如如果你在一个内部类中声明静态变量，编译器会报错，因为内部类需要使用类的对象来创建，所以依赖对象，也就意味着不能声明静态变量，当加载类时会执行static修饰的方法，变量，代码块，然后，当创建对象时会执行没有用static修饰的变量，方法，代码块。也就是说，在没有创建对象时，非静态变量，方法，代码块是没有被执行的，而static修饰的这些是执行了的，这也就意味着，在用static修饰的方法，代码块中，不能出现非静态变量，因为这时非静态变量还不存在，此时编译器会报错，大意是无法从静态上下文中引用非静态变量。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]},{"title":"this简介","slug":"Java-this的简介","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:30:30.898Z","comments":true,"path":"2016/07/21/Java-this的简介/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Java-this的简介/","excerpt":"","text":"this这个变量是什么呢？我们可以在挺多地方看到，在类的每个实例方法中都有一个名为this的变量，它指向调用该方法的对象，这也就解决了我们不会为每个对象都提供一个实例方法的副本（因为这样太浪费资源了），我们使用的使用this这个变量进行标记，这时一个用途，还有一个就是当我们需要为类创建多个构造函数时，我们需要使用this()来引用类中无参数的构造函数（当然也可以使用this(参数)来调用类的有参数的构造函数）。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]},{"title":"如何在win8.1上搭建React-Native环境","slug":"ReactNative-在win8上搭建ReactNative环境","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:31:02.377Z","comments":true,"path":"2016/07/21/ReactNative-在win8上搭建ReactNative环境/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/ReactNative-在win8上搭建ReactNative环境/","excerpt":"","text":"这么火的ReactNative让我也把持不住了，一言不合我就开始搭建环境了，之前在网上查，好多人都说在win上搭建好难，个人表示好方，于是我怀着忐忑的心情开始搭建，我按照this开始搭建，由于之前我写android就是用AS，所以就跳过，接着VS我也有，感觉这都是程序员必备，Git也有，接下来问题来了，python？我很早就想学这门语言，但是最近都在学习android，所以就没时间，然后安装python没成功，我就自动下一步先，打算等会再说这个，接下来是node.js，不好意思，这个我也有，这么写着我的尴尬症都犯了，因为之前要搭建hexo来写博客，额，都是天意，接下来就是重点了，运行命令 npm install -g react-native-cli，出现下面这张图片没毛病，再运行下面的命令react-native init MyProject，这个命令是创建你的ReactNative项目，再运行这行命令之前进入你想将项目存放的路径，出现下面这两张张图片没毛病，细心的同学会发现这两张图片其实就是运行完上面的命令之后的结果，之所以分成两张，是因为截不下来，然后进入你的项目的目录运行命令react-native start，注意是要进入项目的目录，出现下面两张图片,没毛病，然后保证这个窗口打开，重新打开一个命令窗口，一样先进入项目的目录，然后运行命令react-native run-android，如果出现下面图片的错误，,那么，恭喜你，跟我一样踩坑了，讲道理，一直这么顺我都好方，终于出现问题了，那么我们如何解决呢？首先，你要明白这个问题产生可能是因为你没有将ANDROID_HOME环境变量设置为你sdk所在目录，也可能是platform-tools没有设到了PATH环境变量中，运行adb devices看不到设备，解决了这个问题之后，就离成功真的只差一步了，我们再次进入项目的目录，运行react-native run-android，接下来出现的应该是下图的画面了，,然后你就可以在你的Genymotion模拟器上看到了，如果你想修改显示的样子，只要在项目中找到文件index.android.jx，进入修改，然后问题又来了，并没有像网上说的那样，直接就显示了，而是需要把之前保证打开的哪个窗口关闭，其实就是关闭packager，然后重新运行执行react-native start和react-native run-android命令就可以了，同时这里需要说一下，因为react-native start执行需要时间，所以只有等它执行完后才能在Genymotion模拟器上看到修改后的样子，至此，整个搭建完成了，大家有问题，可以上React-Native中文社区http://bbs.reactnative.cn/看看","categories":[],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"http://sakurajiang.github.io/tags/React-Native/"}],"keywords":[]},{"title":"关于java各个访问属性的问题","slug":"Java-关于java各个访问属性的问题","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:30:40.688Z","comments":true,"path":"2016/07/21/Java-关于java各个访问属性的问题/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Java-关于java各个访问属性的问题/","excerpt":"","text":"在同一个包中，private修饰的变量和方法都只能在类中使用，这里的类是指这个定义的类中使用，而不是指在别的类中声明这个类的对象引用能调用，而对于默认属性修饰的变量和方法能在同一个包中使用，也就是说在同一个包中的别的类中声明这个类的对象引用，这个对象引用能访问默认属性的变量和方法，对于protected修饰的变量和方法，允许同一个包的其他任何类以及它的任意位置的子类访问，这里得说明一点，如果你在这个子类中声明父类的对象引用，这个对象引用并不能访问自己本身的protected修饰的变量和方法，其实很好理解，因为protected修饰的变量和方法允许的是同一个包的其他任何类以及它的子类访问。没有说自己本身的对象引用能访问，这很容易让人误解，自然，根据上面的规则，在不同包的类中声明一个类的对象引用，这个对象引用同样不能访问protected修饰的变量和方法，初学者可能觉得我在任何地方声明自己的类的对象引用，自然能够引用本身所有的变量和方法，其实不然，这跟你声明这个类的对象引用的位置有关，对于public修饰的变量和方法，所有的任意位置的类对象的引用都能访问。其实总结起来就是private修饰的数据成员只能在定义的类中访问，默认属性只能在同一个包中访问，protected修饰的只能在同一个包中或者任意位置的子类访问（其实后半部分是因为protected修饰的能被子类继承，如果理解各个访问属性修饰的数据成员能否被继承的话，后半部分可以不看，因为后半部分说的不太对，其实efault修饰的和protected修饰的数据成员的被访问属性是一样的。只是差别在被继承上。），public修饰的数据成员允许任意位置的类访问。不管你有无声明这个类的对象引用，然后用这个类的引用去访问自己的数据成员，结果都一样，也就是说你声明的这个引用只能是指定这个数据成员是属于哪个类，而不能涉及到访问权限。同时，这里得提一下，这里的引用的类型是跟声明它的类的类型一致，而不是跟new的类的类型一致。因为引用类型和new的类型可能是不一样的，这里涉及到多态。这里的变量和方法包括静态的和非静态的。 同时这里要提一点，对于子类继承父类的数据成员，private修饰的是无法被继承，默认属性在同一个包中的子类能被继承，不同包中的子类能继承protected，public修饰的成员和变量。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]},{"title":"关于函数方法的返回类型是一个类类型时的情况","slug":"Java-关于函数方法的返回类型是一个类类型时的情况","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:30:47.523Z","comments":true,"path":"2016/07/21/Java-关于函数方法的返回类型是一个类类型时的情况/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Java-关于函数方法的返回类型是一个类类型时的情况/","excerpt":"","text":"在一个方法中，如果你想返回的是一个类类型时，那么这个方法中的return语句返回的类型就需要和方法的返回类型一致，如果你在方法中定义了一个类并且指向一个变量时，这个new构造的对象决定在你调用这个方法时能不能转换成别的对象，而指向的那个变量决定的是需不需要强制类型转换，我们都知道，一个子类的对象可以指向父类的引用，假如在方法中写了这样的代码，并且方法的返回类型是父类类型，那么在调用这个方法时，我们可以将这个方法赋值给一个子类的引用，但是由于这个方法的返回类型是父类类型，而将父类引用变为子类引用是需要强制类型转换的，我们只需要在前面加上(子类名)即可，当然如果是子类类型变为父类类型就不需要强制转换了，而如果你在方法中的语句是new的父类类型，那么你在调用这个方法的时候将这个方法赋值给一个子类引用时编译通过，但是运行不通过。会报jang.lang.ClassCastException这个错误。PS(一个方法的返回类型可以和return的语句的类型不同，返回类型才是这个方法的返回类型，而不是return语句，转换的方式也是一样，子类可以自动转换为父类，父类需要强制转换为子类，如果你将父类的对象指向父类的引用，而函数的返回是子类类型，那么编译时也会通过，但是运行时会报错，错误与之前一样，也就是说编译器只是检查类型之间有无继承关系，有则正确，运行时检查真正类型，是则通过)。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]},{"title":"java中的混合运算","slug":"Javajava中的混合运算","date":"2016-07-20T16:00:00.000Z","updated":"2020-07-06T09:30:54.965Z","comments":true,"path":"2016/07/21/Javajava中的混合运算/","link":"","permalink":"http://sakurajiang.github.io/2016/07/21/Javajava中的混合运算/","excerpt":"","text":"今天看了一下java的显式转换和隐式转换，因为对这一块有些忘了，在看到混合算术表达式时看到这样一段话，如果其中一个操作数是double类型，就在进行运算之前将另一个转换为double类型，看到这句话时，我想到如果double a=3.9,double b=2.2,然后int i=(int)a+b,结果会是什么？结果是错误，因为将double转换到int会有丢失，也就是说这个式子的右边依然是double类型，然后我想这是不是说a在显示转换为int类型后，然后由于b还是double类型，所以按照上述规则，a又转换为double类型，然后我就想a是不是又变为3.9了，然后我将式子变为int i=(int)((int)a+b);，结果答案是5，也就是说a其实还是3，然后我想难道这个规则是只适合隐式转换吗？也就是说遇到显示转换时，这个规则就不成立，不然为什么a没有变成3.9呢？然后我想到其实答案应该是这样的，a经过显示转换的确变成了3，但是这个规则同样适用有显示转换的表达式，也就是说在进行运算之前，a变成了double类型，但是值却是3.0，所以结果是5，而不是6，也许在显示转换时，将int用括号括起来（也就是写成(int)a+b）的一个原因可能是让a先变成int类型，毕竟括号内的先运算。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://sakurajiang.github.io/tags/Java/"}],"keywords":[]}]}